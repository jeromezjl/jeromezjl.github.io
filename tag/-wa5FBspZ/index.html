<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Jerome">
<meta name="description" content="Jerome&#39;s blog">
<meta name="theme-color" content="#343a40">
<title>Jerome</title>
<link rel="shortcut icon" href="/favicon.ico?v=1680157976544">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?912d7399b0bd888a157481e9409a2639";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Jerome</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Jerome</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">71</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">18</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/jeromezjl">
              <i class="fa fa-github" title="Github"></i>
            </a>
          
            <a href="https://space.bilibili.com/430199065">
              <i class="fa fa-bold" title="b站"></i>
            </a>
          
            <a href="https://jeromezjl.github.io/post/wechat/">
              <i class="fa fa-wechat" title="Wechat"></i>
            </a>
          
            <a href="https://www.instagram.com/jeromezjl/">
              <i class="fa fa-instagram" title="Instagram"></i>
            </a>
          
            <a href="">
              <i class="fa fa-envelope-o" title="zhangjilong@bupt.edu.cn"></i>
            </a>
          
        
        
      </div>
    </div>
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          形式语言与自动机
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="http://localhost:4001/post/lesslessxing-shi-yu-yan-yu-zi-dong-ji-greatergreater-bi-ji/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              06-15
              <small>《形式语言与自动机》笔记</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      <a href="http://localhost:4001/post/xing-shi-yu-yan-python-shi-xian-e-nfa-greater-dfa/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              05-16
              <small>【形式语言】python实现 ε-ΝFA -&gt; DFA</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      <a href="https://jeromezjl.github.io/post/shuo-du-ke-yi-shuo/" target="_blank">Jerome</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="https://tse1-mm.cn.bing.net/th/id/R-C.0b7b7f15b83e7326de9078d0998d5eac?rik=KDIsnoDnAZ%2b5mw&amp;riu=http%3a%2f%2fwww.obzhi.com%2fwp-content%2fuploads%2f2020%2f09%2fkejigan.jpg&amp;ehk=6nuckhqgEl%2fAyE7ZDxsZnTs1%2bLpurRBJEk6V%2fhbe1cw%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/bpe/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43902773/article/details/115191790&#34;&gt;基于BPE的汉语tokenization&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;基于bpe的子词压缩&#34;&gt;基于BPE的子词压缩&lt;/h1&gt;
&lt;p&gt;对于英文语料来讲，特别是在预训练模型兴起之前，一种常见的分词方式是通过空格对英文语句直接进行分词。然而这种分词方式可能也会带来一些问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;英文单词由于时态、单复数、大小写等因素，可能具有多个单词变体，比如单词go具有这样的变体： going, gone, goes，单纯基于空格从语料中收集单词，可能会导致词表过大，进而导致模型学习过程中，需要设置较大的词向量矩阵，增加模型参数。&lt;/li&gt;
&lt;li&gt;由于词表难以穷尽所有单词，以及网络中会出现一些新的词，导致某些词无法出现在词表中，即出现集外词（OOV）。&lt;br&gt;
BPE（Byte-Pair Encoding）是缓解这些问题的一种算法，其不再按照完整的单词进行分词，而是将单词划分成了子词（sub-word）的粒度。例如单词showed可以被划分为show和ed， 如此做法，可以有效缩减单词个数，同时通过拆解子词也能够缓解OOV问题。图1展示了一种BPE算法效果的示例，一方面通过右侧的子词组合可以表示左侧任意一个单词，另一方面通过子词的表示大大减小了原本词表的大小。&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1680157576369.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图1 BPE算法示例&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;12-实现流程&#34;&gt;1.2 实现流程&lt;/h1&gt;
&lt;p&gt;如图2所示，使用BPE算法进行对文本进行分词，首先需要根据英文语料构建BPE的子词词表，根据此词表即可对给定的文本序列进行编码，即分词，获取分词后的文本序列。同时提供根据编码后的结果还原原始语句的方法。&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1680157622297.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图2 BPE实现流程&lt;/p&gt;
&lt;h1 id=&#34;13-词表构建&#34;&gt;1.3 词表构建&lt;/h1&gt;
&lt;p&gt;词表构建是BPE算法的核心，首先需要准备一批语料，然后从语料中逐步统计词频，构建BPE子词词表。具体来讲，首先需要将训练数据中的每个单词切分成字符作为初始子词，并统计语料中的子词初始化子词词表。接下来，可以按照如下步骤逐步迭代：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统计每一个连续子词对的出现频率，选择最高频子词对合并成新的子词，并将该子词对加入词表中；&lt;/li&gt;
&lt;li&gt;根据最高频子词对，将语料中的这两个相邻子词进行合并；&lt;/li&gt;
&lt;li&gt;如果组成最高频子词对的子词在原始语料中不再存在，则在词表中进行删除；&lt;/li&gt;
&lt;li&gt;重复第1-3步直到达到设定的子词词表大小或迭代次数；&lt;br&gt;
下面通过一个例子说明如何构造子词词典，假设通过统计获得了如下预处理好的语料库，其中每个单词中的字符通过空格进行分割为子词，同时单词后使用&lt;/w&gt;作为单词结尾符号：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;train_data = {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n i n g &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a n g u a g e &amp;lt;/w&amp;gt;&#39;: 3,&#39;p r o c e s s i n g &amp;lt;/w&amp;gt;&#39;:7}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用以上训练数据，初始化子词词表为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;bpe_vocab = {&#39;a&#39;, &#39;e&#39;, &#39;p&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;o&#39;, &#39;s&#39;, &#39;l&#39;, &#39;r&#39;, &#39;u&#39;, &#39;d&#39;, &#39;n&#39;, &#39;i&#39;, &#39;t&#39;, &#39;c&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，便可以逐步统计最高频的相邻子词对，并对训练数据进行子词合并。&lt;/p&gt;
&lt;p&gt;第1次迭代： 最高频连续子词对&amp;quot;n&amp;quot;和&amp;quot;g&amp;quot;出现了7+3+7=17次，合并成&amp;quot;ng&amp;quot;加入词表。&amp;quot;n&amp;quot;和&amp;quot;g&amp;quot;在语料库中依旧存在，因此不需要在词表中删除，语料库和词表在本次迭代之后的结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;train_data = {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n i ng &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3,&#39;p r o c e s s i ng &amp;lt;/w&amp;gt;&#39;:7}
bpe_vocab = {&#39;a&#39;, &#39;e&#39;, &#39;p&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;o&#39;, &#39;s&#39;, &#39;l&#39;, &#39;r&#39;, &#39;u&#39;, &#39;d&#39;, &#39;n&#39;, &#39;i&#39;, &#39;t&#39;, &#39;c&#39;, &#39;ng&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第2次迭代： 最高频连续子词对&amp;quot;i&amp;quot;和&amp;quot;ng&amp;quot;出现了7+7=14次，合并成&amp;quot;ing&amp;quot;加入词表。子词&amp;quot;i&amp;quot;在语料库中不再存在，因此在词表中进行删除，语料库和词表在本次迭代之后的结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;train_data = {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n ing &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3,&#39;p r o c e s s ing &amp;lt;/w&amp;gt;&#39;:7}
bpe_vocab = {&#39;a&#39;, &#39;e&#39;, &#39;p&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;o&#39;, &#39;s&#39;, &#39;l&#39;, &#39;r&#39;, &#39;u&#39;, &#39;d&#39;, &#39;n&#39;, &#39;t&#39;, &#39;c&#39;, &#39;ng&#39;, &#39;ing&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第3次迭代： 最高频连续子词对&amp;quot;ing&amp;quot;和&amp;quot;&lt;/w&gt;&amp;quot;出现了7+7=14次，合并成&amp;quot;ing&lt;/w&gt;&amp;quot;加入词表。&amp;quot;ing&amp;quot;在语料库中不再存在，因此在词表中进行删除，语料库和词表在本次迭代之后的结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;train_data = {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n ing&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3,&#39;p r o c e s s ing&amp;lt;/w&amp;gt;&#39;:7}
bpe_vocab = {&#39;a&#39;, &#39;e&#39;, &#39;p&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;o&#39;, &#39;s&#39;, &#39;l&#39;, &#39;r&#39;, &#39;u&#39;, &#39;d&#39;, &#39;n&#39;, &#39;t&#39;, &#39;c&#39;, &#39;ng&#39;,&#39;ing&amp;lt;/w&amp;gt;&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重复以上迭代过程，直到子词词表规模达到预先设定的大小或下一个最高频的子词对出现频率为1。&lt;/p&gt;
&lt;p&gt;首先，定义函数get_subwords，用以统计子词以及对应的词频，并获取初始化后的子词词表bpe_vocab。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re
import collections

def get_subwords(data):
    &amp;quot;&amp;quot;&amp;quot;
    统计子词以及对应的词频
    &amp;quot;&amp;quot;&amp;quot;
    subwords = collections.defaultdict(int)
    for word, freq in data.items():
        for subword in word.split():
            subwords[subword] += freq

    return subwords

train_data = {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n i n g &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a n g u a g e &amp;lt;/w&amp;gt;&#39;: 3,&#39;p r o c e s s i n g &amp;lt;/w&amp;gt;&#39;:7}
subwords = get_subwords(train_data)
# 获取初始化的子词词表
bpe_vocab = set(subwords.keys())
print(&amp;quot;词表：&amp;quot;, bpe_vocab)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;词表： {&#39;d&#39;, &#39;s&#39;, &#39;a&#39;, &#39;u&#39;, &#39;o&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;i&#39;, &#39;g&#39;, &#39;c&#39;, &#39;r&#39;, &#39;l&#39;, &#39;t&#39;, &#39;n&#39;, &#39;p&#39;, &#39;e&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，在构造词表过程中，需要统计相邻子词对的词频，以便获取最高频的词对，代码实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_pair_with_frequency(data):
    &amp;quot;&amp;quot;&amp;quot;
    获取子词对以及子词集合
    &amp;quot;&amp;quot;&amp;quot;
    pairs = collections.defaultdict(int)
    for word, freq in data.items():
        sub_words = word.split()
        for i in range(len(sub_words)-1):
            pair = (sub_words[i],sub_words[i+1])
            pairs[pair] += freq
    return pairs

pairs = get_pair_with_frequency(train_data)
print(&amp;quot;子词词对：&amp;quot;, pairs)
best_pair = max(pairs, key=pairs.get)
print(&amp;quot;当前最高频的子词对: &amp;quot;, best_pair)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;子词词对： defaultdict(&amp;lt;class &#39;int&#39;&amp;gt;, {(&#39;d&#39;, &#39;e&#39;): 5, (&#39;e&#39;, &#39;e&#39;): 5, (&#39;e&#39;, &#39;p&#39;): 5, (&#39;p&#39;, &#39;&amp;lt;/w&amp;gt;&#39;): 5, (&#39;l&#39;, &#39;e&#39;): 7, (&#39;e&#39;, &#39;a&#39;): 7, (&#39;a&#39;, &#39;r&#39;): 7, (&#39;r&#39;, &#39;n&#39;): 7, (&#39;n&#39;, &#39;i&#39;): 7, (&#39;i&#39;, &#39;n&#39;): 14, (&#39;n&#39;, &#39;g&#39;): 17, (&#39;g&#39;, &#39;&amp;lt;/w&amp;gt;&#39;): 14, (&#39;n&#39;, &#39;a&#39;): 6, (&#39;a&#39;, &#39;t&#39;): 6, (&#39;t&#39;, &#39;u&#39;): 6, (&#39;u&#39;, &#39;r&#39;): 6, (&#39;r&#39;, &#39;a&#39;): 6, (&#39;a&#39;, &#39;l&#39;): 6, (&#39;l&#39;, &#39;&amp;lt;/w&amp;gt;&#39;): 6, (&#39;l&#39;, &#39;a&#39;): 3, (&#39;a&#39;, &#39;n&#39;): 3, (&#39;g&#39;, &#39;u&#39;): 3, (&#39;u&#39;, &#39;a&#39;): 3, (&#39;a&#39;, &#39;g&#39;): 3, (&#39;g&#39;, &#39;e&#39;): 3, (&#39;e&#39;, &#39;&amp;lt;/w&amp;gt;&#39;): 3, (&#39;p&#39;, &#39;r&#39;): 7, (&#39;r&#39;, &#39;o&#39;): 7, (&#39;o&#39;, &#39;c&#39;): 7, (&#39;c&#39;, &#39;e&#39;): 7, (&#39;e&#39;, &#39;s&#39;): 7, (&#39;s&#39;, &#39;s&#39;): 7, (&#39;s&#39;, &#39;i&#39;): 7})
当前最高频的子词对:  (&#39;n&#39;, &#39;g&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，根据获取的最高频子词对，对训练语料中的相应子词进行合并，代码实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def merge_data_with_pair(pair, data):
    &amp;quot;&amp;quot;&amp;quot;
    将语料中的最高频子词对进行合并
    输入：
        - pair: 最高频子词词对
        - data: 字典形式，统计好的输入语料
    &amp;quot;&amp;quot;&amp;quot;
    result = {}
    bigram = re.escape(&#39; &#39;.join(pair))
    p = re.compile(r&#39;(?&amp;lt;!\S)&#39; + bigram + r&#39;(?!\S)&#39;)
    for word in data:
        merged_word = p.sub(&#39;&#39;.join(pair), word)
        result[merged_word] = data[word]
    return result

train_data = merge_data_with_pair(best_pair, train_data)
print(&amp;quot;语料库: &amp;quot;, train_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;语料库:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n i ng &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s i ng &amp;lt;/w&amp;gt;&#39;: 7}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，将最高频的子词对加入词表，对于不再存在于语料库中的子词在词表中进行删除。基于上述这流程，下面正式定义构建词表函数build_vocab，代码实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def build_vocab(train_data, num_merges):
    &amp;quot;&amp;quot;&amp;quot;
    根据训练语料构建词表
    输入：
        - train_data: 字典形式，统计好的输入语料
        - num_merges: 迭代次数
    &amp;quot;&amp;quot;&amp;quot;

    # 初始化词表
    subwords = get_subwords(train_data)
    bpe_vocab = set(subwords.keys())
    print(bpe_vocab, len(bpe_vocab))
    i = 1
    # 逐步生成词表
    for _ in range(num_merges):
        # 根据语料统计相邻子词对的词频
        pairs = get_pair_with_frequency(train_data)
        # 取频率最大的子词对, 如果pairs 为空或子词对的最大频次为1，则停止
        if not pairs:
            break
        best_pair = max(pairs, key=pairs.get)
        if pairs[best_pair] == 1:
            break
        # 合并语料
        train_data = merge_data_with_pair(best_pair, train_data)
        # 将子词加入词表中
        merged_word = &amp;quot;&amp;quot;.join(best_pair)
        bpe_vocab.add(merged_word)
        # 删除子词
        subwords = get_subwords(train_data)
        if best_pair[0] not in subwords:
            bpe_vocab.remove(best_pair[0])
        if best_pair[1] not in subwords:
            bpe_vocab.remove(best_pair[1])

        print(&amp;quot;Iter - {}, 最高频子词对: {}&amp;quot;.format(i, best_pair))
        print(&amp;quot;训练数据: &amp;quot;, train_data)
        print(&amp;quot;词表: {}, {}\n&amp;quot;.format(len(bpe_vocab), bpe_vocab))
        i += 1
    return bpe_vocab

num_merges = 14

train_data = {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n i n g &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a n g u a g e &amp;lt;/w&amp;gt;&#39;: 3,&#39;p r o c e s s i n g &amp;lt;/w&amp;gt;&#39;:7}

bpe_vocab = build_vocab(train_data, num_merges)
print(&amp;quot;词表: &amp;quot;, bpe_vocab)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&#39;d&#39;, &#39;s&#39;, &#39;a&#39;, &#39;u&#39;, &#39;o&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;i&#39;, &#39;g&#39;, &#39;c&#39;, &#39;r&#39;, &#39;l&#39;, &#39;t&#39;, &#39;n&#39;, &#39;p&#39;, &#39;e&#39;} 15
Iter - 1, 最高频子词对: (&#39;n&#39;, &#39;g&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n i ng &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s i ng &amp;lt;/w&amp;gt;&#39;: 7}
词表: 16, {&#39;d&#39;, &#39;s&#39;, &#39;a&#39;, &#39;u&#39;, &#39;o&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;i&#39;, &#39;g&#39;, &#39;c&#39;, &#39;r&#39;, &#39;ng&#39;, &#39;l&#39;, &#39;t&#39;, &#39;n&#39;, &#39;p&#39;, &#39;e&#39;}

Iter - 2, 最高频子词对: (&#39;i&#39;, &#39;ng&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n ing &amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s ing &amp;lt;/w&amp;gt;&#39;: 7}
词表: 16, {&#39;d&#39;, &#39;ing&#39;, &#39;s&#39;, &#39;a&#39;, &#39;u&#39;, &#39;o&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;c&#39;, &#39;r&#39;, &#39;ng&#39;, &#39;l&#39;, &#39;t&#39;, &#39;n&#39;, &#39;p&#39;, &#39;e&#39;}

Iter - 3, 最高频子词对: (&#39;ing&#39;, &#39;&amp;lt;/w&amp;gt;&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;l e a r n ing&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 16, {&#39;d&#39;, &#39;s&#39;, &#39;a&#39;, &#39;u&#39;, &#39;o&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;c&#39;, &#39;r&#39;, &#39;ng&#39;, &#39;l&#39;, &#39;t&#39;, &#39;n&#39;, &#39;p&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;e&#39;}

Iter - 4, 最高频子词对: (&#39;l&#39;, &#39;e&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;le a r n ing&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 17, {&#39;a&#39;, &#39;u&#39;, &#39;c&#39;, &#39;l&#39;, &#39;n&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;le&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;, &#39;o&#39;}

Iter - 5, 最高频子词对: (&#39;le&#39;, &#39;a&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;lea r n ing&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 17, {&#39;a&#39;, &#39;u&#39;, &#39;c&#39;, &#39;l&#39;, &#39;n&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;lea&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;, &#39;o&#39;}

Iter - 6, 最高频子词对: (&#39;lea&#39;, &#39;r&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;lear n ing&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 17, {&#39;a&#39;, &#39;u&#39;, &#39;c&#39;, &#39;l&#39;, &#39;n&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;lear&#39;, &#39;ng&#39;, &#39;t&#39;, &#39;o&#39;}

Iter - 7, 最高频子词对: (&#39;lear&#39;, &#39;n&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learn ing&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 17, {&#39;a&#39;, &#39;u&#39;, &#39;c&#39;, &#39;l&#39;, &#39;n&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;learn&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;, &#39;o&#39;}

Iter - 8, 最高频子词对: (&#39;learn&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learning&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;p r o c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 17, {&#39;a&#39;, &#39;u&#39;, &#39;c&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;, &#39;o&#39;}

Iter - 9, 最高频子词对: (&#39;p&#39;, &#39;r&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learning&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;pr o c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 18, {&#39;a&#39;, &#39;u&#39;, &#39;c&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;pr&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;, &#39;o&#39;}

Iter - 10, 最高频子词对: (&#39;pr&#39;, &#39;o&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learning&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;pro c e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 17, {&#39;a&#39;, &#39;u&#39;, &#39;c&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;pro&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;}

Iter - 11, 最高频子词对: (&#39;pro&#39;, &#39;c&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learning&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;proc e s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 16, {&#39;proc&#39;, &#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;}

Iter - 12, 最高频子词对: (&#39;proc&#39;, &#39;e&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learning&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;proce s s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 16, {&#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;proce&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;}

Iter - 13, 最高频子词对: (&#39;proce&#39;, &#39;s&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learning&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;proces s ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 16, {&#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;proces&#39;, &#39;r&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;s&#39;, &#39;ng&#39;, &#39;t&#39;}

Iter - 14, 最高频子词对: (&#39;proces&#39;, &#39;s&#39;)
训练数据:  {&#39;d e e p &amp;lt;/w&amp;gt;&#39;: 5, &#39;learning&amp;lt;/w&amp;gt;&#39;: 7, &#39;n a t u r a l &amp;lt;/w&amp;gt;&#39;: 6, &#39;l a ng u a g e &amp;lt;/w&amp;gt;&#39;: 3, &#39;process ing&amp;lt;/w&amp;gt;&#39;: 7}
词表: 15, {&#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;process&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;ng&#39;, &#39;t&#39;}

词表:  {&#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;process&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;ng&#39;, &#39;t&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-语料编码&#34;&gt;1.4 语料编码&lt;/h1&gt;
&lt;p&gt;在获得子词词表之后，便可以根据该词表将文本序列进行编码，即分词。这里可以采用贪心的思想，根据子词词表中的子词长度对子词词表由大到小进行排序，然后对于一个待编码的单词，从前向后依次遍历词表中的子词，如果该子词在单词之后，则将该单词在子词位置进行切分，这样便可以获得最多三个单词子串：子词前的单词子串、子词串、子词后的单词子串，然后按照同样的思路继续遍历剩余的单词子串。如果在子词词表遍历完成之后，依然有一些单词子串没有被切分，则使用&#39;&lt;UNK&gt;&#39;进行替代。&lt;/p&gt;
&lt;p&gt;下面来看一个例子，假设给定子词词表为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[“ning&amp;lt;/w&amp;gt;”, “lear”, “deep&amp;lt;/w&amp;gt;”, “est&amp;lt;/w&amp;gt;”, “the&amp;lt;/w&amp;gt;”, “a&amp;lt;/w&amp;gt;”]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;待分词的文本序列为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[“the&amp;lt;/w&amp;gt;”, “deep&amp;lt;/w&amp;gt;”, “learning&amp;lt;/w&amp;gt;”]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则最后分词编码的结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[“the&amp;lt;/w&amp;gt;”, “deep&amp;lt;/w&amp;gt;”, &amp;quot;lear&amp;quot;, “ning&amp;lt;/w&amp;gt;”]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，先定义函数tokenize_word用于对单词进行编码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re

def tokenize_word(word, sorted_vocab, unknown_token=&#39;&amp;lt;unk&amp;gt;&#39;):
    &amp;quot;&amp;quot;&amp;quot;
    输入:
        - word: 待编码的单词
        - sorted_vocab: 排序后的子词词典
        - unknown_token: 不能被切分的子词替代符
    &amp;quot;&amp;quot;&amp;quot;
    # 如果传入的词为空
    if word == &amp;quot;&amp;quot;:
        return []
    # 如果词表为空，则将输入的词替换为&amp;lt;UNK&amp;gt;
    if sorted_vocab == []:
        return [unknown_token] + len(string)

    word_tokens = []
    # 遍历词表拆分单词
    for i in range(len(sorted_vocab)):
        token = sorted_vocab[i]
        # 基于该token定义正则，同时将token里面包含句号的变成[.]
        token_reg = re.escape(token.replace(&#39;.&#39;, &#39;[.]&#39;))
        # 在当前word中进行遍历，找到匹配的token的起始和结束位置
        matched_positions = [(m.start(0), m.end(0)) for m in re.finditer(token_reg, word)]
        # 如果当前token没有匹配到相应串，则跳过
        if  len(matched_positions) == 0:
            continue
        
        # 获取匹配到的子串的起始位置
        end_positions = [matched_position[0] for matched_position in matched_positions]
        start_position = 0

        for end_position in end_positions:
            subword = word[start_position: end_position]
            word_tokens += tokenize_word(subword, sorted_vocab[i+1:], unknown_token)
            word_tokens += [token]
            start_position = end_position + len(token)
        # 匹配剩余的子串
        word_tokens += tokenize_word(word[start_position:], sorted_vocab[i+1:], unknown_token)
        break
    else:
        # 如果word没有被匹配，则映射为&amp;lt;unk&amp;gt;
        word_tokens = [unknown_token] * len(word)
    
    return word_tokens
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义函数tokenize用于对语句进行编码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def tokenize(text, bpe_vocab):
    &amp;quot;&amp;quot;&amp;quot;
    使用BPE对输入语句进行编码
    &amp;quot;&amp;quot;&amp;quot;
    # 对子词词表按照子词长度进行排序
    sorted_vocab = sorted(bpe_vocab, key=lambda subword: len(subword), reverse=True)
    print(&amp;quot;待编码语句: &amp;quot;, text)
    tokens = []
    for word in text.split():
        word = word + &amp;quot;&amp;lt;/w&amp;gt;&amp;quot;
        word_tokens = tokenize_word(word, sorted_vocab, unknown_token=&#39;&amp;lt;unk&amp;gt;&#39;)
        tokens.extend(word_tokens)
    
    return tokens

text = &amp;quot;natural language processing&amp;quot;
tokens = tokenize(text, bpe_vocab)
print(&amp;quot;词表: &amp;quot;, bpe_vocab)
print(&amp;quot;编码结果: &amp;quot;, tokens)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;待编码语句:  natural language processing
词表:  {&#39;a&#39;, &#39;u&#39;, &#39;l&#39;, &#39;n&#39;, &#39;learning&amp;lt;/w&amp;gt;&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;g&#39;, &#39;p&#39;, &#39;e&#39;, &#39;r&#39;, &#39;process&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;, &#39;d&#39;, &#39;ng&#39;, &#39;t&#39;}
编码结果:  [&#39;n&#39;, &#39;a&#39;, &#39;t&#39;, &#39;u&#39;, &#39;r&#39;, &#39;a&#39;, &#39;l&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;l&#39;, &#39;a&#39;, &#39;ng&#39;, &#39;u&#39;, &#39;a&#39;, &#39;g&#39;, &#39;e&#39;, &#39;&amp;lt;/w&amp;gt;&#39;, &#39;process&#39;, &#39;ing&amp;lt;/w&amp;gt;&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;15-语料解码&#34;&gt;1.5 语料解码&lt;/h1&gt;
&lt;p&gt;在将一串语句使用BPE进行编码后，如何还原成原来的语句呢。这种情况下，单词后设置的&amp;lt;\w&amp;gt;便起了作用。即可以一直合并分词后的子词，直到遇见&amp;lt;\w&amp;gt;便可以解码出一个完整单词。下面给出了一个例子。&lt;/p&gt;
&lt;p&gt;假设使用BPE编码后的序列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[“the&amp;lt;/w&amp;gt;”, “deep&amp;lt;/w&amp;gt;”, “lear”, “ning&amp;lt;/w&amp;gt;”]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则对应的解码结果为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[&amp;quot;the&amp;quot;, &amp;quot;deep&amp;quot;,&amp;quot;learning&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def restore(tokens):

    text = []
    word = []
    for token in tokens:
        if token[-4:] == &amp;quot;&amp;lt;/w&amp;gt;&amp;quot;:
            if token != &amp;quot;&amp;lt;/w&amp;gt;&amp;quot;:
                word.append(token[:-4])
            text.append(&amp;quot;&amp;quot;.join(word))
            word.clear()
        else:
            word.append(token)
    return text

tokens = [&amp;quot;the&amp;lt;/w&amp;gt;&amp;quot;, &amp;quot;deep&amp;lt;/w&amp;gt;&amp;quot;, &amp;quot;lear&amp;quot;, &amp;quot;ning&amp;lt;/w&amp;gt;&amp;quot;]
text = restore(tokens)
print(&amp;quot;还原结果: &amp;quot;, text)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;还原结果:  [&#39;the&#39;, &#39;deep&#39;, &#39;learning&#39;]
&lt;/code&gt;&lt;/pre&gt;
">BPE</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shi-pin-mu-biao-jian-ce/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_40557160/article/details/109536612&#34;&gt;视频目标检测VID论文及代码（更新至2020.12）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/94986199&#34;&gt;写给小白的YOLO介绍&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/breeze_blows/article/details/105323491&#34;&gt;视频目标检测(video object detection)简单综述&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_43702653/article/details/123973629?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167842568816782427467521%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=167842568816782427467521&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123973629-null-null.142%5Ev73%5Einsert_down4,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;amp;utm_term=R-CNN&amp;amp;spm=1018.2226.3001.4187&#34;&gt;R-CNN史上最全讲解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_40716944/article/details/114822515&#34;&gt;YOLO系列详解：YOLOv1、YOLOv2、YOLOv3、YOLOv4、YOLOv5、YOLOv6、YOLOv7&lt;/a&gt;&lt;/p&gt;
">视频目标检测</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/linux-nei-he-mo-kuai-kai-fa/"" data-c="
          &lt;p&gt;https://zhuanlan.zhihu.com/p/420194002&lt;/p&gt;
&lt;p&gt;Linux 内核模块开发，首先需要下载和Linux系统内核相匹配的内核文件。&lt;br&gt;
&lt;a href=&#34;https://mirror.bjtu.edu.cn/kernel/linux/kernel/&#34;&gt;国内Linux内核下载镜像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linux 内核文件编译（这步不需要，走弯路了）&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/378149586&#34;&gt;Linux内核编译很简单，6步编译一个自己的内核&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/hxxjxw/article/details/105899282&#34;&gt;编译安装linux内核&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个博客讲vim和gcc编译c文件&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/m0_47668487/article/details/115289154&#34;&gt;VMware下安装Ubuntu系统并编译运行C语言程序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_36417014/article/details/98239337&#34;&gt;【linux环境下】【C语言编译】【使用makefile】【详细版】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在内核模块中使用printk()函数输出信息，而不是使用printf()等C语言标准库函数。&lt;/p&gt;
&lt;p&gt;编写内核模块makefile和普通的不一样，需要按照一下格式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;make 时报的错&lt;/strong&gt;&lt;br&gt;
makefile里要用tab，不能用空格&lt;br&gt;
一个函数在没有参数的情况下没有赋参数void&lt;/p&gt;
&lt;p&gt;查看已经存在的mod：lsmod&lt;br&gt;
删除mod：rmmod modname&lt;br&gt;
将编译好的mod加载进去：sudo insmod hello.ko&lt;br&gt;
查看内核日志，最后为新模块产生的日志：dmesg&lt;br&gt;
看最近的内核日志：dmesg | tail&lt;br&gt;
实时监视内核日志的变化，并输出最新的日志信息：tail -f /var/log/kern.log&lt;br&gt;
删除make产生的所有文件：make clean&lt;/p&gt;
">【Linux】内核模块开发</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ccha-que-bu-lou/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yourfriendyo/article/details/119544221&#34;&gt;C语言详解：结构体&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/m0_52902391/article/details/120614881&#34;&gt;模板类/模板函数 template 的用法(超详细)&lt;/a&gt;&lt;br&gt;
template：模板&lt;/p&gt;
&lt;h1 id=&#34;循环&#34;&gt;循环&lt;/h1&gt;
&lt;p&gt;while (cin &amp;gt;&amp;gt; x){}&lt;br&gt;
cin函数，输入NULL时返回0，输入其他值返回它的地址&lt;/p&gt;
&lt;h1 id=&#34;结构体&#34;&gt;结构体&lt;/h1&gt;
&lt;p&gt;typedef struct xxx {} yyy；yyy为结构体xxx的别名，是一种数据类型，需要实例化。&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/jacksls/article/details/108529761&#34;&gt;定义结构体 typedef struct 的用法总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在结构体别名中定义结构体指针&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct DNode{
	ElemType data;
	DNode* prior, * next;
}DNode, * DLinkList;  // * DLinkList 就是指向DNode类型的指针，声明时用DNode和DLinkList都可以
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;指针&#34;&gt;指针&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_39640298/article/details/84900326&#34;&gt;C++指针详解&lt;/a&gt;&lt;br&gt;
&amp;amp;：取地址&lt;br&gt;
*：取地址里面的值&lt;br&gt;
&lt;a href=&#34;https://www.w3cschool.cn/cpp/cpp-passing-arrays-to-functions.html&#34;&gt;向函数传递数组的写法&lt;/a&gt;&lt;br&gt;
用“-&amp;gt;”的情况：&lt;br&gt;
A是一个类 class / struct&lt;br&gt;
p是一个指向A类型的指针，那么用p访问A中的成员变量和函数时，使用p-&amp;gt;x，p-&amp;gt;f(x)来访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向函数传入变量的指针和引用的区别&lt;/strong&gt;&lt;br&gt;
传入指针时，函数参数中是对指针的定义 int* a，传入函数的是变量的地址，&amp;amp;a；&lt;br&gt;
传入引用时，函数参数中是对原变量的引用 int &amp;amp;a，传入函数的是原变量，a。&lt;br&gt;
总之，传入指针是 通过指针，对指针指向的内存地址进行操作；传入变量的引用是直接对原变量进行修改。二者效果一样，但是原理不一样。&lt;br&gt;
&lt;code&gt;指针&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct SqList{
	int data[MaxSize];
	int length;
};

void InitList(SqList *list){
	cout&amp;lt;&amp;lt;&amp;quot;type in the length of list:&amp;quot;&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;list-&amp;gt;length;
	cout&amp;lt;&amp;lt;&amp;quot;type in the data:&amp;quot;&amp;lt;&amp;lt;endl; 
	for(int i = 0; i&amp;lt;list-&amp;gt;length; i++)
		cin&amp;gt;&amp;gt;list-&amp;gt;data[i];
}
int main(){
	SqList sqlist;
	InitList(&amp;amp;sqlist);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;引用&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct SqList{
	int data[MaxSize];
	int length;
};

void InitList(SqList &amp;amp;list){
	cout&amp;lt;&amp;lt;&amp;quot;type in the length of list:&amp;quot;&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;list.length;
	cout&amp;lt;&amp;lt;&amp;quot;type in the data:&amp;quot;&amp;lt;&amp;lt;endl; 
	for(int i = 0; i&amp;lt;list.length; i++)
		cin&amp;gt;&amp;gt;list.data[i];
}
int main(){
	SqList sqlist;
	InitList(sqlist);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面两段代码，如果用指针访问结构体，则需要用-&amp;gt;访问结构体成员；如果用原结构体，则用 . 由此可见，指针和引用的差别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向函数中传入指针类型的数据&lt;/strong&gt;&lt;br&gt;
和上面的不同，上面传入的是变量的地址，在函数列表中被定义，成为指针。而本问题描述的是直接将指针类型的数据传入函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

typedef struct DNode{
	ElemType data;
	DNode* prior, * next;
}DNode, * DLinkList;  //DLinkList为指向结构体的指针类型
 
//初始化双链表
bool InitDLinkList(DLinkList L) {  //此处和变量的指针一样，也可该写作 DNode* L
	L = (DLinkList)malloc(sizeof(DLinkList));
	if (L == NULL) {
		return false;          
	}
	L-&amp;gt;prior = NULL;
	L-&amp;gt;next = NULL;
	return true;
}

int main() {
	DLinkList L;  //定义指针类型数据L
	InitDLinkList(L);  //由于指针的值即为变量的地址，所以和&amp;amp;+变量名一样，都是将地址传入函数。
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;swap的例子&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;指针&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# include&amp;lt;iostream&amp;gt;
using namespace std;

void MySwap(int* a, int* b){  //在列表中定义两个指针a，b，分别指向传入变量a，b的地址 
	int t = 0;  
	t = *a;  //交换值 
	*a = *b;
	*b = t;
	
	//错误的思路：用指针交换来交换 
	int *t = NULL;  //定义中间指针t，用于指针之间的赋值 
	t = a;
	a = b;
	b = t;
	//以上操作只是让函数内的指针ab分别指向了ba，但没有对对应地址内的值进行任何改变 
}

int main(){
	int a = 1,b = 2;
	MySwap(&amp;amp;a, &amp;amp;b);  //传入变量ab的地址 
	cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;b;
}
//向函数传入变量的地址。把函数声明和传入函数的形式整体来看，就是 int* a = &amp;amp;a; 
//也就是指针定义操作 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;引用&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# include&amp;lt;iostream&amp;gt;
using namespace std;

void MySwap(int　&amp;amp;a, int　&amp;amp;b){  //在列表中定义两个地址引用
	int t = 0;  
	t = a; //直接修改原变量
	a = b;
	b = t;
}

int main(){
	int a = 1,b = 2;
	MySwap(a, b);  //直接传入原始变量ab
	cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;类和对象&#34;&gt;类和对象&lt;/h1&gt;
&lt;p&gt;类中不带返回类型的函数为构造函数。造函数可用于为某些成员变量设置初始值。&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_42565910/article/details/90346236&#34;&gt;c语言malloc函数的用法和意义&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++三种常见的实例化方法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态实例化：在程序的全局或静态作用域中定义并初始化一个对象，该对象在程序整个生命周期内只存在一个实例。&lt;/li&gt;
&lt;li&gt;堆实例化：使用 new 运算符在动态存储区域中分配内存并实例化一个对象。这样创建的对象在程序运行期间一直存在，直到使用 delete 运算符显式释放其内存。&lt;/li&gt;
&lt;li&gt;栈实例化：在函数或代码块的作用域中定义并实例化一个对象，该对象的生命周期与所在的函数或代码块相同。对象在离开该作用域时自动销毁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;静态实例化的例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MyClass {
public:
    MyClass() : m_x(0) {}
    void setX(int x) { m_x = x; }
    int getX() const { return m_x; }
private:
    int m_x;
};

MyClass globalObject;  // 全局实例

int main() {
    static MyClass staticObject;  // 静态实例
    globalObject.setX(5);
    staticObject.setX(10);
    int globalX = globalObject.getX(); // globalX = 5
    int staticX = staticObject.getX(); // staticX = 10
    // ...
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中，通过调用 setX 和 getX 来对全局对象 globalObject 和静态对象 staticObject 的成员变量进行访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆实例化的例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MyClass {
public:
    MyClass() : m_x(0) {}
    void setX(int x) { m_x = x; }
    int getX() const { return m_x; }
private:
    int m_x;
};

int main() {
    MyClass* heapObject = new MyClass;  // 堆实例
    heapObject-&amp;gt;setX(5);
    int heapX = heapObject-&amp;gt;getX(); // heapX = 5
    // ...
    delete heapObject;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中，通过调用 setX 和 getX 来对堆对象 heapObject 的成员变量进行访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈实例化的例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MyClass {
public:
    MyClass() : m_x(0) {}
    void setX(int x) { m_x = x; }
    int getX() const { return m_x; }
private:
    int m_x;
};

void someFunction() {
    MyClass stackObject;  // 栈实例
    stackObject.setX(5);
    int stackX = stackObject.getX(); // stackX = 5
    // ...
}

int main() {
    someFunction();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中，通过调用 setX 和 getX 来对栈对象 stackObject 的成员变量进行访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数模板&lt;/strong&gt;&lt;br&gt;
若想向函数传入不同类型的数据，则还需要另外定义不同的函数。为解决该问题，引入函数模板template。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template&amp;lt;typename T&amp;gt;  //定义模板数据类型 T
T add(T&amp;amp; a, T&amp;amp; b){  //把T当作一种数据类型来用
	return a+b;
}

int main()
{
	float a = 10.3, b = 20.5;  //如果是int，则直接传入函数即可
	cout&amp;lt;&amp;lt;add(a, b);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上例中，可以直接传入int/float等类型，而不用重新定义函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类模板&lt;/strong&gt;&lt;br&gt;
参考如下构建栈的写法，照着写就行，功能也是可以随便定义函数的数据类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# include&amp;lt;iostream&amp;gt;
using namespace std;

const int StackSize = 1024;			//定义栈的最大长度
template&amp;lt;class T&amp;gt;
class SeqStack {					//定义顺序栈的模板类
	public:
		SeqStack() { top = -1; }	//构造函数，初始化空栈
		void Push(T x);				//入栈操作
		T Pop();					//出栈操作
		T GetTop();					//查找栈顶元素
		bool Empty();				//判别栈是否为空
	private:
		T data[StackSize];			//定义数组
		int top;					//栈顶指针
};


template&amp;lt;class T&amp;gt;
void SeqStack&amp;lt;T&amp;gt;::Push(T x) {
	if (top &amp;gt;= StackSize - 1) throw &amp;quot;上溢&amp;quot;;
	data[++top] = x;
}

template&amp;lt;class T&amp;gt;
T SeqStack&amp;lt;T&amp;gt;::Pop() {
	if (Empty()) throw &amp;quot;下溢&amp;quot;;
	return data[top--];
}

template&amp;lt;class T&amp;gt;
T SeqStack&amp;lt;T&amp;gt;::GetTop() {
	if (Empty()) throw &amp;quot;下溢&amp;quot;;
	return data[top];
}

template&amp;lt;class T&amp;gt;
bool SeqStack&amp;lt;T&amp;gt;::Empty() {
	if(top == -1) return true;
	else return false;
}

int main() {
	SeqStack&amp;lt;int&amp;gt; stack;  //声明的时候要加上数据类型
	stack.Push(1);
	stack.Push(2);
	stack.Push(3);
	cout &amp;lt;&amp;lt; stack.GetTop();
	cout&amp;lt;&amp;lt;endl;
	
	cout &amp;lt;&amp;lt; stack.Pop();
}
&lt;/code&gt;&lt;/pre&gt;
">C++查缺补漏</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/gan-wang-luo/"" data-c="
          &lt;h1 id=&#34;图像预处理&#34;&gt;图像预处理&lt;/h1&gt;
&lt;p&gt;本次项目只有八张图片，我们需要进行数据增强，获取更大的数据集。&lt;/p&gt;
&lt;p&gt;首先，要对图像进行&lt;strong&gt;分辨率的统一&lt;/strong&gt;。分辨率，即为图像中像素点的个数，例如，一个分辨率为 1920x1080 的图像，表示它在水平方向上有 1920 个像素，在垂直方向上有 1080 个像素。&lt;/p&gt;
&lt;p&gt;问：为什么相同分辨率，相同文件类型，但是图片的文件大小不一样？&lt;br&gt;
答：&lt;br&gt;
图像内容的复杂程度：相同分辨率的图像，如果其内容越复杂，文件大小就可能越大。因为图像的复杂程度与其所包含的信息量有关，而信息量越大，文件大小也就越大。&lt;/p&gt;
&lt;p&gt;像素的位深度：像素的位深度指的是每个像素能够表示的颜色的数量。例如，8 位深度的像素可以表示 256 种颜色，而 16 位深度的像素可以表示 65,536 种颜色。相同分辨率的图像，如果其像素的位深度不同，文件大小也可能会不同。&lt;/p&gt;
&lt;p&gt;元数据的不同：图像文件中可能包含一些元数据，例如创建时间、修改时间、拍摄设备等信息，这些元数据的不同也可能会导致文件大小的差异。&lt;/p&gt;
&lt;p&gt;在神经网络中，我们通常需要将输入图像的尺寸规范化为相同的分辨率。&lt;/p&gt;
&lt;p&gt;然后我们进行数据增强&lt;/p&gt;
&lt;p&gt;训练循环顺序：&lt;br&gt;
步骤1&lt;br&gt;
生成器不动，生成器产生一批假图片，再拿取一批真实图片，喂给判别器，训练判别器。&lt;br&gt;
我们希望判别器对假图片打上标签0，对真图片打上标签1&lt;br&gt;
步骤2&lt;br&gt;
判别器不动，训练生成器&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_44887621/article/details/120535309&#34;&gt;pytorch保存图片 save_image ，读取图片&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;训练GAN网络训练多少次比较合适？&lt;br&gt;
最好使用一种称为 &amp;quot;early stopping&amp;quot; 的方法，即在模型在验证集上的表现开始下降时停止训练。这样可以避免模型出现过拟合的情况。&lt;/p&gt;
&lt;p&gt;另外，也可以使用 &amp;quot;learning rate decay&amp;quot; 的方法来防止模型出现过拟合的情况。这种方法的原理是，在训练过程中，会逐渐降低学习率，以便模型能够更加稳定地收敛到最优解。&lt;/p&gt;
">GAN网络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shu-ju-gui-yi-hua-chu-li/"" data-c="
          &lt;p&gt;数据归一化是一种常用的预处理技术，它的目的是将不同范围的数据转换为相同范围的数据，这样可以使不同的数据具有相似的分布和取值范围。&lt;/p&gt;
&lt;p&gt;常见的数据归一化方法有以下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最值归一化（Min-Max Normalization）&lt;/strong&gt;&lt;br&gt;
最值归一化是将数据映射到[0,1]范围内，公式如下：&lt;/p&gt;
&lt;p&gt;X_normalized = (X - Xmin) / (Xmax - Xmin)&lt;/p&gt;
&lt;p&gt;其中，Xmin和Xmax分别是数据集中的最小值和最大值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;均值方差归一化（Standardization）&lt;/strong&gt;&lt;br&gt;
均值方差归一化是将数据转换为均值为0，方差为1的数据，公式如下：&lt;/p&gt;
&lt;p&gt;X_normalized = (X - Xmean) / Xstd&lt;/p&gt;
&lt;p&gt;其中，Xmean和Xstd分别是数据集的均值和标准差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小数定标归一化&lt;/strong&gt;&lt;br&gt;
小数定标归一化是将数据的小数点移动到某一位置，使得数据范围在一定程度上缩小。例如，将数据的小数点向左移动2位，可以将数据的范围缩小100倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对数归一化&lt;/strong&gt;&lt;br&gt;
对数归一化是将数据取对数后进行归一化处理。这种方法通常用于处理数据的取值范围差异很大的情况。&lt;/p&gt;
&lt;p&gt;数据归一化的目的是使得数据的分布更加规律&lt;br&gt;
归一化处理可以使不同的数据具有相似的分布和取值范围，这在许多机器学习算法中是很有用的。例如，在使用梯度下降算法进行模型训练时，如果数据的范围差异很大，模型可能会在局部最小值附近来回震荡，导致收敛速度减慢。归一化处理可以使梯度下降算法更快地收敛，并且可以使模型的泛化能力更强。&lt;/p&gt;
&lt;p&gt;但是，也要注意，如果数据已经具有相似的分布和取值范围，则不需要进行归一化处理。另外，在使用归一化处理后的数据进行模型训练后，在使用模型进行预测时，还需要将输入数据进行相应的反归一化处理，才能得到正确的预测结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用pytorch进行归一化操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;normalize = transforms.Normalize((mean,), (std,))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 mean 为均值，std为方差，想进行归一化操作需要先计算出数据的均值和方差。&lt;/p&gt;
&lt;p&gt;例如对MNIST数据集的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义图像处理方法
tranform = transforms.Compose([
    transforms.ToTensor(),  # 将图片转换成Tensor
    transforms.Normalize((0.1307,), (0.3081,))  # 进行数据归一化处理
])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 0.1307 和 0.3081 分别是MNIST的均值和方差，可以自己计算，也可以网上查&lt;br&gt;
等同于 X_normalized = (X - 0.1307) / 0.3081，转化为均值为0，方差为1的数据。&lt;/p&gt;
">数据归一化处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/xian-xing-dai-shu-ju-zhen-de-te-zheng-zhi-he-te-zheng-xiang-liang/"" data-c="
          &lt;p&gt;所谓凡事见微知著，由简推繁，要理解多维矩阵的特征值和特征向量的意思，我们不如从二维推起。&lt;br&gt;
矩阵，又称为矩阵空间，矩阵包含空间信息。1x2 的矩阵，是二维空间上的矩阵&lt;/p&gt;
&lt;p&gt;若非零向量 x 满足 Ax = λx，则 λ 为特征值，x 为特征向量。&lt;br&gt;
特征向量在经过矩阵 A 的变换后，不改变，只需要乘上一个常数 λ&lt;/p&gt;
&lt;p&gt;对于矩阵特征值和特征向量公式的理解：一个矩阵点乘一个向量就相当于对该向量进行旋转或者拉伸等一系列线性变换。在我们求解矩阵的特征值和特征向量的时候就是要求解矩阵 A，A能够使得这些特征向量只发生伸缩变换，而变换的效果等价于特征向量与某个常量 λ 相乘。&lt;br&gt;
在二维空间理解一下这个式子的含义。&lt;/p&gt;
">【线性代数】矩阵的特征值和特征向量</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/sql-qi-zhong-fu-xi/"" data-c="
          &lt;p&gt;复习策略：&lt;br&gt;
看网络资料的数据库复习&lt;br&gt;
弄懂知识点，然后做一下里面的题&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jeromezjl.github.io/post/sql/&#34;&gt;SQL笔记&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;第三章-sql&#34;&gt;第三章 SQL&lt;/h1&gt;
&lt;p&gt;熟练编写 sql 语句，创建、删除语句也要看，数据类型&lt;/p&gt;
&lt;h1 id=&#34;第四章&#34;&gt;第四章&lt;/h1&gt;
&lt;p&gt;◼ Join Expressions（连接表达式）&lt;br&gt;
◼ Views 视图&lt;br&gt;
◼ Transactions&lt;br&gt;
◼ Integrity Constraints&lt;br&gt;
◼ SQL Data Types and Schemas&lt;br&gt;
◼ Authorization&lt;br&gt;
◼ Security in SQL&lt;/p&gt;
&lt;p&gt;Join 参见 sql 的总结，natural join，inner join 等&lt;/p&gt;
&lt;h1 id=&#34;第五章-高级-sql&#34;&gt;第五章 高级 SQL&lt;/h1&gt;
&lt;p&gt;这章期中没考&lt;/p&gt;
&lt;p&gt;使用程序设计语言访问数据库&lt;br&gt;
通过两种方式从通用编程语言访问 SQL：&lt;br&gt;
动态 SQL：通过函数或方法&lt;br&gt;
嵌入式 SQL：在编译时全部确定&lt;/p&gt;
&lt;p&gt;JDBC 标准定义了 java 和 SQL 的 API&lt;/p&gt;
&lt;h1 id=&#34;第六章-关系代数&#34;&gt;第六章 关系代数&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/quinnnorris/article/details/70739094&#34;&gt;SQL 形式化语言——关系代数&lt;/a&gt;&lt;br&gt;
重点是如何将sql语句转化为关系代数&lt;/p&gt;
&lt;p&gt;选择运算 select operation σ&lt;br&gt;
选择关系instructor中属于物理系的元组：&lt;br&gt;
σ dept_name=“Physics”(instructor)&lt;br&gt;
选择关系 instructor 中 salary&amp;gt;90000 的元组：&lt;br&gt;
σ salary&amp;gt;90000 (instructor)&lt;br&gt;
⋀ (and), ⋁ (or), (not)&lt;/p&gt;
&lt;p&gt;投影运算 project operation  ∏&lt;br&gt;
用于选择表中想要的属性&lt;br&gt;
∏ name, salary (instructor)&lt;br&gt;
找出物理系中所有教师的名字：&lt;br&gt;
∏ name (σ dept_name=“Physic’ (instructor))&lt;/p&gt;
&lt;p&gt;并运算 union operation ∪&lt;br&gt;
找出开设在 2009 年球季或者 2010 年春季学期，或者二者皆开的课程集合&lt;br&gt;
∏course_id (σ semester=“Fall” Λ year=2009 (section)) ∪&lt;br&gt;
∏course_id (σ semester=“Spring” Λ year=2010 (section))&lt;/p&gt;
&lt;p&gt;集合差运算 Set Difference Operation -&lt;br&gt;
找出开设在 2009 年秋季但不开设在 2010 年春季的课程&lt;br&gt;
∏course_id (σ semester=“Fall”Λ year=2009(section))-&lt;br&gt;
∏course_id (σ semester=“Spring”Λ year=2010(section))&lt;/p&gt;
&lt;p&gt;笛卡尔积运算 Cartesian-Product Operation x&lt;br&gt;
∏ name (σ dept_name=“Physic’ (instructor x teaches))&lt;/p&gt;
&lt;p&gt;更名运算 Rename Operation&lt;br&gt;
选出 instructor 中 salary 最高的：&lt;br&gt;
σ instructor.salary &amp;lt; d.salary (instructor ╳ ρ d(instructor))&lt;/p&gt;
&lt;p&gt;select T.salary&lt;br&gt;
from instructor T, instructor S&lt;br&gt;
where T.salary &amp;gt; S.salary&lt;/p&gt;
&lt;h1 id=&#34;第七章-e-r-图&#34;&gt;第七章 E-R 图&lt;/h1&gt;
&lt;p&gt;非ER关系中，两个实体关联，每个实体中可能会有对方实体的主码，从而产生冗余&lt;br&gt;
在ER关系中，如果一个实体的属性是另一个实体的主码，则删除该属性。二者的关联会在联系集里表达。（P183）&lt;/p&gt;
&lt;p&gt;双线表示一对一关系，实体集唯一对应关系集&lt;/p&gt;
&lt;p&gt;大学实体集及属性（P154 输入183）&lt;/p&gt;
&lt;p&gt;大学 E-R 图（P159 输入188）&lt;/p&gt;
&lt;p&gt;E-R 图图形含义（P172 输入 201）&lt;/p&gt;
&lt;p&gt;练习题（P179 输入208）&lt;/p&gt;
&lt;p&gt;弱实体集：如果保留某些属性，则在和别的集合关联时，会造成属性的冗余。所以我们选择删掉该属性。但删掉后，当前剩余的属性就不能保证唯一标识元素。这样的实体集称为弱实体集。弱实体集必须与强实体集关联才有意义。&lt;/p&gt;
&lt;p&gt;E-R 图中，双线表示有且仅有一个相关的对象&lt;br&gt;
箭头：A → B 表明 每个 A 至多有一个 B&lt;/p&gt;
&lt;p&gt;构造关系表时，如果有多个候选键，最好选取数值型（int, float）候选键作为关系表主键，便于提高基于主键的查询速度&lt;br&gt;
—不要选字符串型属性，如varchar、datetime&lt;br&gt;
—e.g. studentname, instructorName&lt;/p&gt;
&lt;p&gt;双菱形表示弱实体集的标识性联系集&lt;/p&gt;
&lt;p&gt;构建 E-R 图步骤&lt;br&gt;
从关系集入手，分别判断其关联的两个实体集的对应关系。看是采用双线、箭头，还是单线。&lt;br&gt;
判断弱实体集：看关联的两个实体集的属性，是否有相同的，如果有，去掉其中一个的属性，将其变为弱实体集，然后将关系变为双菱形。&lt;/p&gt;
&lt;h1 id=&#34;第八章-关系数据库的设计&#34;&gt;第八章 关系数据库的设计&lt;/h1&gt;
&lt;p&gt;◼ Features of Good Relational Design&lt;br&gt;
◼ Atomic Domains and First Normal Form&lt;br&gt;
◼ Decomposition Using Functional Dependencies&lt;br&gt;
◼ Functional Dependency Theory&lt;br&gt;
◼ Algorithms for Functional Dependencies&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好的关系设计的特点&lt;/strong&gt;&lt;br&gt;
取决于E-R图质量&lt;br&gt;
是否有重复，是否可以很好的表示所有信息&lt;br&gt;
删除和更新问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/sky20080101/articles/8445061.html&#34;&gt;原子性和第一范式&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;第十章-数据存储和文件结构&#34;&gt;第十章 数据存储和文件结构&lt;/h1&gt;
&lt;p&gt;◼ File organization (at physical level, §10.5)&lt;br&gt;
◼ Organization of records in files (at logical level, §10.6 ),&lt;br&gt;
i.e. file structures&lt;br&gt;
◼ Data-dictionary Storage (§10.7)&lt;br&gt;
◼ Data Buffer (§10.8)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10.5 文件组织&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;第十一章-索引&#34;&gt;第十一章 索引&lt;/h1&gt;
&lt;p&gt;搜索码：用于在文件中查找记录的属性或属性集&lt;br&gt;
索引&lt;br&gt;
什么是&lt;br&gt;
聚集索引 clustering index ，非聚集索引，稠密索引，稀疏索引，&lt;/p&gt;
&lt;p&gt;每个索引对数据增删改查是否有影响，&lt;/p&gt;
&lt;p&gt;索引创建在搜索码（属性）上面，可提高检索速度&lt;br&gt;
要会说明原因&lt;/p&gt;
&lt;p&gt;在除了查询之外，delete update insert 时如何提高效率，搜索码&lt;br&gt;
索引也有空间、时间开销，增加/删除，所以不一定能对增加删除修改起到提高效率的作用&lt;br&gt;
也可能拖慢速度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;on which attributes the indices can be further defined to speed up the query? 在哪里添加索引会继续加快查找？&lt;/strong&gt;&lt;br&gt;
1.找语句中频繁使用的元素&lt;br&gt;
2.找where后面的元素&lt;br&gt;
3.找join on后面的元素&lt;br&gt;
例：&lt;br&gt;
select branch_city, sum(amount)&lt;br&gt;
from branch inner join loan on branch_name&lt;br&gt;
where assets&amp;gt;1000&lt;br&gt;
group by branch_city&lt;br&gt;
1.branch_city加索引&lt;br&gt;
2.assets加索引&lt;br&gt;
3.branch_name加索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Give a SQL statement to define a composite index on combined search key(branch_name, amount) on the table loan.  创建索引&lt;/strong&gt;&lt;br&gt;
语法：&lt;br&gt;
create index branch_name_amount_index on loan(branch_name, amount);&lt;br&gt;
create index 索引名 on 表名（属性名）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Can this index be efficiently used for the following query, and why? 是否可以提升查询速度？&lt;/strong&gt;&lt;br&gt;
答题角度：看被索引的对象在什么关键词后面。&lt;br&gt;
比如在where后/经常被查询使用&lt;/p&gt;
&lt;h1 id=&#34;第十二章-查询处理&#34;&gt;第十二章 查询处理&lt;/h1&gt;
&lt;p&gt;熟悉关系代数的表示&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/bianyamei/article/details/89491358&#34;&gt;启发式查询树优化实例&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1Fp4y1a7Cs/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;B站讲解 数据库语法树优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;步骤&lt;br&gt;
1、写出关系代数表达式&lt;br&gt;
2、画出查询树&lt;br&gt;
3、选择关系下移&lt;br&gt;
4、投影下移，注意投影要在选择关系之上；每个自然连接前面必须有投影&lt;/p&gt;
&lt;h1 id=&#34;函数依赖&#34;&gt;函数依赖&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/m0_46670811/article/details/109526906&#34;&gt;求属性集闭包(AB+)&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/Game_Zmh/article/details/88058069&#34;&gt;求属性集闭包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List all the candidate keys of R. 求候选键&lt;/strong&gt;&lt;br&gt;
1.&lt;a href=&#34;https://blog.csdn.net/YYbLQQ/article/details/124508824&#34;&gt;即只出现在F箭头左边的一定是候选码&lt;/a&gt;&lt;br&gt;
上例中，A和C只出现在箭头左边，我们用闭包计算可以得到U，则（AC）是该关系的候选码&lt;br&gt;
注：除了候选键，其余都是非主属性&lt;br&gt;
2.可以推出所有的字母的是候选键&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What is the highest normal form of R 关系R的最高范式是什么（判断是第几范式）&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/m0_37345402/article/details/106163096&#34;&gt;如何判断范式（1NF、2NF、3NF、BCNF）&lt;/a&gt;&lt;br&gt;
1.求候选码。候选键可以是连着的几个字母，而主属性是分开的独立字母；除了主属性之外的字母都是非主属性&lt;br&gt;
2.如果F中，存在左部没有候选码的关系，则有非平凡FD，则不是BCNF&lt;br&gt;
3.如果上述关系中，右部都是主属性，则为3NF&lt;br&gt;
4.如果任何主属性都不能推出非主属性，则为2NF&lt;br&gt;
5.否则为1NF&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lossless-join decomposition 判断无损分解&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_41338249/article/details/112724127&#34;&gt;无损分解讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Compute the canonical cover Fc 求最小函数依赖&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.zhihu.com/question/21235096&#34;&gt;知乎讲解&lt;/a&gt;&lt;br&gt;
1.将右部都化为单一字母&lt;br&gt;
2.去掉左边多余属性，具体方法：只需关注非单属性，求左侧的闭包，但不要加上左边推出的字母，比如 DG-&amp;gt;C：判断(DG)+ = DG，不要再把C加上再推了。观察得到的闭包，如果闭包含有右侧推出的字母，则删除；否则保留。DG不含C，则保留。&lt;br&gt;
3.剩余的单个关系，判断是否存在形如 D-&amp;gt;C, C-&amp;gt;A, D-&amp;gt;A 这样的，删除 D-&amp;gt;A 即可&lt;br&gt;
综上可得出最小函数依赖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Give a lossless-join and dependency-preserving decomposition of R into 3NF&lt;/strong&gt;&lt;br&gt;
在最小函数依赖上进行构建&lt;/p&gt;
&lt;h1 id=&#34;事务&#34;&gt;事务&lt;/h1&gt;
&lt;p&gt;concurrent transactions：并发事务&lt;br&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=U3SHusK80q0&#34;&gt;画优先图 precedence graph 并 判断是否可串行化 serializable：油管清晰讲解&lt;/a&gt;&lt;br&gt;
关注三对关系：R-&amp;gt;W，W-&amp;gt;R，W-&amp;gt;W&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否是可恢复调度？ Is S a recoverable schedule, and why?&lt;/strong&gt;&lt;br&gt;
对于可恢复调度，如果一个调度从另外一个调度的结果中读取数据，那么它必须在另外以后调度的commit之后commit。&lt;br&gt;
不是可恢复调度的例子：&lt;br&gt;
T2 读取 student 表中 stuID=10 的元组时，该元组内容已由 T1 修改过，但 T2 提交操作&lt;br&gt;
commit 早于 T1 提交 commit。一旦 T1 在 T2 的 commit 操作之后回滚其 update student 操作，将 stuName 回滚为旧值，则 T2 的 select 操作无法随着回滚，T2 读取的仍然是 stuName 修改后的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否是无级联调度？Is S a cascadeless schedule, and why?&lt;/strong&gt;&lt;br&gt;
如果事务要对某个值执行读操作，则必须等到执行写入该值的事务 commit。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否满足二阶段锁？ obey the two-phase locking protocol？&lt;/strong&gt;&lt;br&gt;
在同一个事务中，前半部分全是lock，后面全是unlock，则满足，否则不满足&lt;br&gt;
注意是在同一个事务中，如在T1这一列中看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否满足严格二阶段锁？ Strict two phase locking protocol&lt;/strong&gt;&lt;br&gt;
共享锁（share）：lock_s；排他锁（exclusive）：lock_x&lt;br&gt;
S2PLP 可以在 lock_s上锁之后随时释放它，但只能在 commit 的时候释放 lock_x&lt;br&gt;
严锁在commit的时候同时释放所有锁。其主要区别简单来说，就是：2PL能随时释放锁，S2PL只能在事务结束后释放锁。但注意，随时释放不是指&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否满足严格二阶段锁？Rigorous two phase locking protocol&lt;/strong&gt;&lt;br&gt;
R2PLP 只能在 commit 的时候释放所有锁， lock_s 和 lock_x&lt;/p&gt;
">SQL 复习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/mldl-zhong-chang-jian-de-ying-wen/"" data-c="
          &lt;p&gt;parameters / params：参数&lt;br&gt;
epochs：总训练次数，使用全部数据训练一次是一个epochs&lt;br&gt;
learning rate：学习率&lt;br&gt;
optimize：优化&lt;br&gt;
regularization：正则化&lt;br&gt;
normalize：归一化、标准化&lt;br&gt;
Regularization： 正则化&lt;/p&gt;
">ML/DL 中常见的英文</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ti-du-xia-jiang-gradient-descent/"" data-c="
          &lt;p&gt;本篇关键词：损失函数/代价函数/误差函数、梯度下降、学习率、Momentum（动量）&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/68468520&#34;&gt;梯度下降&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/357963858&#34;&gt;随机梯度下降&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数机器学习模型都会有一个损失函数。比如常见的 均方误差 （Mean Squared Error —— MSE）损失函数，其输出值为 模型的输出值和实际值的偏差。&lt;br&gt;
损失函数的输出值越小，模型精度越高。我们用梯度下降的方法最小化损失函数。&lt;/p&gt;
&lt;p&gt;梯度下降（Gradient Descent）：使用所有样本进行梯度下降&lt;br&gt;
小批量样本梯度下降（Mini Batch GD）：使用小批量样本进行梯度下降&lt;br&gt;
随机梯度下降（Stochastic GD）：使用一个样本进行梯度下降&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/395685065/answer/2535950728&#34;&gt;怎么通俗易懂的理解SGD中Momentum的含义？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SGD 的改进形式 —— Adam&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/42115548/answer/1636798770&#34;&gt;SGD有多种改进的形式(RMSprop,Adadelta等),为什么大多数论文中仍然用SGD?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_42109740/article/details/105401197&#34;&gt;深度学习各类优化器详解（动量、NAG、adam、Adagrad、adadelta、RMSprop、adaMax、Nadam、AMSGrad）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_36589234/article/details/89330342&#34;&gt;PyTorch学习之 torch.optim 的6种优化器及优化算法介绍&lt;/a&gt;&lt;/p&gt;
">以梯度下降（Gradient Descent）展开的优化器总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/kpl-yu-yan/"" data-c="
          &lt;h1 id=&#34;编译过程&#34;&gt;编译过程&lt;/h1&gt;
&lt;p&gt;编译 package Hello 生成 Hello.s&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;kpl Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译 Hello.s 生成 Hello.o&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;asm Hello.s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;combine all of the &amp;quot;.o&amp;quot; object files into an executable file&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;lddd System.o Hello.o Runtime.o -o Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with the &amp;quot;-o&amp;quot; option , the new file will be named &amp;quot;Hello&amp;quot; or will be &amp;quot;a.out&amp;quot;&lt;/p&gt;
&lt;p&gt;To run the package &amp;quot;Hello&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;blitz -g Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;-g&amp;quot; means run it directly&lt;/p&gt;
&lt;p&gt;After execution completes,enter &amp;quot;q&amp;quot; to quit&lt;/p&gt;
&lt;h1 id=&#34;the-header-and-code-files&#34;&gt;The Header and Code Files&lt;/h1&gt;
&lt;p&gt;A program is made of several packages and each package is described by a header file and a code file&lt;/p&gt;
&lt;p&gt;The header file is the specification for the package. It provides the external interface to that package,giving all information other packages will need about what is in the package. In the Hello-World example, the file “Hello.h” specifies the package will contain a function called “main” and tells what parameters this function takes and returns. (The main function takes no parameters and returns no results.)&lt;/p&gt;
&lt;p&gt;The code file contains the implementation details for the package. All executable code appears in the code file. In the Hello-World example, the “Hello.c” file contains the actual code for the main function&lt;/p&gt;
&lt;h1 id=&#34;编译过程-2&#34;&gt;编译过程&lt;/h1&gt;
&lt;p&gt;直接输入 make，在文件夹内会根据 makefile 中的规则编译所有文件&lt;br&gt;
再次输入 blitz -g os 运行所有代码&lt;/p&gt;
&lt;p&gt;https://github.com/ayushishri/OS-Blitz-Labs&lt;/p&gt;
">KPL 语言</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/mnist-shou-xie-shu-zi-shi-bie/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/m0_58092763/article/details/125631991?spm=1001.2101.3001.6650.1&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125631991-blog-112980305.t5_landing_title_tags&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125631991-blog-112980305.t5_landing_title_tags&amp;amp;utm_relevant_index=2&#34;&gt;手把手实战PyTorch手写数据集MNIST识别项目全流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/wqy1837154675/article/details/108003698&#34;&gt;pytorch读取MNIST数据集并显示&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;理论&#34;&gt;理论&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数据读取和预处理&lt;/strong&gt;&lt;br&gt;
CUDA：显卡驱动，有了CUDA显卡才能进行复杂运算&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/wuzhongqiang/article/details/105499476&#34;&gt;数据读取 DataLoader 和 图像预处理 transforms 详解（这篇值得反复阅读）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/22c50ded4cf7&#34;&gt;深度学习 | 三个概念：Epoch, Batch, Iteration&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_43135178/article/details/115133115&#34;&gt;使用 transforms.Compose() 将图像变换方法整合在一起&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_37555071/article/details/107532319&#34;&gt;torchvision.transforms 对有限的图片数据进行各种变换，如缩小或者放大图片的大小、对图片进行水平或者垂直翻转等，这些都是数据增强的方法。&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.pudn.com/news/6355f71da4b7e43a5ea8bc09.html#%E3%80%90%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E3%80%91&#34;&gt;使用sklearn实现对数据集划分，从而进行交叉验证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可视化工具包&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/zkp_987/article/details/81748098&#34;&gt;以进度条形式可视化迭代器运行的包：tqdm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1K64y1Q7wu?p=3&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;李沐 Softmax 函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对 softmax 回归的感性理解：&lt;br&gt;
线性回归模型多输入，单输出，而 softmax 多输入，多输出。输出结果为输入的向量所属类别，由于类别有多个，所以多输出。输出概率最大的为所属类别。但由于直接输出的概率值 总和不一定为1，且可能有负值，所以对多个输出结果进行 softmax 方法的计算，从而使得输出结果为 总和为1，且均为正值的概率值。&lt;/p&gt;
&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入库
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torchvision import datasets, transforms
from sklearn.model_selection._split import KFold
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义超参数
BATCH_SIZE = 128  # 每批处理的数据量
DEVICE = torch.device(&amp;quot;cuda&amp;quot; if torch.cuda.is_available() else &amp;quot;cpu&amp;quot;)  # 用CPU还是GPU训练
EPOCHS = 10  # 定义总训练次数
k_split_value = 5  # 定义 5 折交叉验证
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义图像处理方法
tranform = transforms.Compose([
    transforms.ToTensor(),  # 将图片转换成Tensor
    transforms.Normalize((0.1307,), (0.3081,))  # 进行数据归一化处理
])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 下载、加载数据集
from torch.utils.data import DataLoader

train_data = datasets.MNIST(root=&amp;quot;./MNIST&amp;quot;,
                            train=True,
                            transform=tranform,
                            download=False)  # 注，如果已经下载了一遍，也需要用该命令设置data的路径

test_data = datasets.MNIST(root=&amp;quot;./MNIST&amp;quot;,
                           train=False,
                           transform=tranform,
                           download=False)

# 将测试集和训练集合并，以便后续对数据集进行分割
dataFold = torch.utils.data.ConcatDataset([train_data, test_data])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 构建网络模型，使用 AlexNet
class AlexNet(nn.Module):
    def __init__(self):
        super(AlexNet, self).__init__()

        # 由于MNIST为28x28， 而最初AlexNet的输入图片是227x227的。所以网络层数和参数需要调节
        self.conv1 = nn.Conv2d(1, 32, kernel_size=3, padding=1)  # AlexCONV1(3,96, k=11,s=4,p=0)
        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)  # AlexPool1(k=3, s=2)
        self.relu1 = nn.ReLU()

        # self.conv2 = nn.Conv2d(96, 256, kernel_size=5,stride=1,padding=2)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)  # AlexCONV2(96, 256,k=5,s=1,p=2)
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)  # AlexPool2(k=3,s=2)
        self.relu2 = nn.ReLU()

        self.conv3 = nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1)  # AlexCONV3(256,384,k=3,s=1,p=1)
        # self.conv4 = nn.Conv2d(384, 384, kernel_size=3, stride=1, padding=1)
        self.conv4 = nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1)  # AlexCONV4(384, 384, k=3,s=1,p=1)
        self.conv5 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)  # AlexCONV5(384, 256, k=3, s=1,p=1)
        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)  # AlexPool3(k=3,s=2)
        self.relu3 = nn.ReLU()

        self.fc6 = nn.Linear(256 * 3 * 3, 1024)  # AlexFC6(256*6*6, 4096)
        self.fc7 = nn.Linear(1024, 512)  # AlexFC6(4096,4096)
        self.fc8 = nn.Linear(512, 10)  # AlexFC6(4096,1000)
        self.dropout = nn.Dropout(p=0.5)

    def forward(self, x):
        x = self.conv1(x)
        x = self.pool1(x)
        x = self.relu1(x)
        x = self.conv2(x)
        x = self.pool2(x)
        x = self.relu2(x)
        x = self.conv3(x)
        x = self.conv4(x)
        x = self.conv5(x)
        x = self.pool3(x)
        x = self.relu3(x)
        x = x.view(-1, 256 * 3 * 3)  # Alex: x = x.view(-1, 256*6*6)
        x = self.fc6(x)
        x = self.dropout(x)
        x = F.relu(x)
        x = self.fc7(x)
        x = self.dropout(x)
        x = F.relu(x)
        x = self.fc8(x)
        return x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义优化器
model = AlexNet().to(DEVICE)
optimizer = optim.Adam(model.parameters())  # 使用 Adam 优化器
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义训练方法
def train_model(model, device, train_loader, optimizer, epoch):
    model.train()  # PyTorch 提供的训练方法
    for batch_index, (data, label) in enumerate(train_loader):
        # 部署到DEVICE
        data, label = data.to(device), label.to(device)
        # 梯度初始化为0
        optimizer.zero_grad()
        # 训练后的结果
        output = model(data)
        # 计算损失（针对多分类任务交叉熵，二分类用sigmoid）
        loss = F.cross_entropy(output, label)
        # 找到最大概率的下标
        pred = output.argmax(dim=1)
        # 反向传播Backpropagation
        loss.backward()
        # 参数的优化
        optimizer.step()
        if batch_index % 3000 == 0:
            print(&amp;quot;Train Epoch : {} \t Loss : {:.6f}&amp;quot;.format(epoch, loss.item()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义测试方法
def test_model(model, device, test_loader):
    # 模型验证
    model.eval()
    # 统计正确率
    correct = 0.0
    # 测试损失
    test_loss = 0.0
    with torch.no_grad():  # 不计算梯度，不反向传播
        for data, label in test_loader:
            data, label = data.to(device), label.to(device)
            # 测试数据
            output = model(data)
            # 计算测试损失
            test_loss += F.cross_entropy(output, label).item()
            # 找到概率值最大的下标
            pred = output.argmax(dim=1)
            # 累计正确率
            correct += pred.eq(label.view_as(pred)).sum().item()
        test_loss /= len(test_loader.dataset)
        print(&amp;quot;Test —— Average loss : {:.4f}, Accuracy : {:.3f}\n&amp;quot;.format(test_loss,
                                                                          100.0 * correct / len(test_loader.dataset)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 对数据进行 K 折交叉划分并且调用前面的方法训练模型
def KFold_and_Train(k_split_value):
    counter = 1  # 自定义一个交叉验证计数器
    kf = KFold(n_splits=k_split_value, shuffle=True, random_state=0)  # 定义K折交叉验证的方法
    for train_index, test_index in kf.split(dataFold):  # 使用kf方法将dataFold分成测试集和验证集
        print(f&amp;quot;第{counter}次交叉验证&amp;quot;)
        counter += 1  # 计数器自增1

        # get train, val
        train_fold = torch.utils.data.dataset.Subset(dataFold, train_index)
        test_fold = torch.utils.data.dataset.Subset(dataFold, test_index)

        # package type of DataLoader
        train_loader = torch.utils.data.DataLoader(dataset=train_fold, batch_size=BATCH_SIZE, shuffle=True)
        test_loader = torch.utils.data.DataLoader(dataset=test_fold, batch_size=BATCH_SIZE, shuffle=True)

        # training and test
        for epoch in range(EPOCHS):
            train_model(model, DEVICE, train_loader, optimizer, epoch)
            test_model(model, DEVICE, test_loader)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 调用函数
KFold_and_Train(k_split_value)
&lt;/code&gt;&lt;/pre&gt;
">MNIST 手写数字识别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/novelai-shi-yong/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1EV4y1L7dX/?vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;启动：浏览器输入域名：127.0.0.1:6969&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/572865961&#34;&gt;参数教程&lt;/a&gt;&lt;/p&gt;
">Novelai 使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ru-he-yong-ying-yu-si-kao/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1TD4y1q7u9/?spm_id_from=333.999.0.0&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;b站&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;reading&#34;&gt;Reading&lt;/h1&gt;
&lt;p&gt;阅读帮助建立特定单词的特定语境&lt;/p&gt;
&lt;h1 id=&#34;new-words&#34;&gt;New Words&lt;/h1&gt;
&lt;p&gt;看全英文的单词解释，用英语解释英语，形成英语思维。如果用中文，那么还是在用中文思考。&lt;br&gt;
学习一个单词的所有变形，尽量学习所有意思&lt;br&gt;
在语境中学习&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.vocabulary.com/&#34;&gt;vocabulary 英文单词查询网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#Idioms&lt;br&gt;
在正确的情况下正确使用谚语&lt;/p&gt;
">如何用英语思考？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/dian-nao-cao-zuo/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1T54y177W2/?vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;一键禁用电脑键盘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://baijiahao.baidu.com/s?id=1634287239598842140&#34;&gt;用 Excel 打开 CSV 格式文件乱码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全半角切换：&lt;br&gt;
电脑设置中启用 shift+空格切换全半角&lt;br&gt;
使用全角模式，在markdown中输入空格，则会显示空格&lt;/p&gt;
">电脑操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/liu-ji/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.hjenglish.com/new/p1334552/&#34;&gt;分值分布&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/373774215&#34;&gt;时间安排&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhenti.burningvocabulary.com/login?uid=632280fbaafe55b3c209ddb6&#34;&gt;做题的神仙网站（随时更新，能看单词意思）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高级词同义替换；使用复杂句式；灵活使用时态、语态&lt;/p&gt;
&lt;h1 id=&#34;六级作文类型&#34;&gt;六级作文类型&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;第一段
1~2 句提出问题，3过渡句

第二段
论点1 论据1
论点2 论据2
论点3 论据3

第三段
重申观点
提出希望
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观点对立 / 分析利弊&lt;br&gt;
Some people think its bad others think its good&lt;/p&gt;
&lt;p&gt;议论型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;作文模板&lt;/code&gt;&lt;br&gt;
第一段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;In the contemporary world 当今世界
there is no consensus among colledge students about the choice of career 没有定论
this proverb reveals that 
according to a recent survey conducted by
with the rapid growth of online shopping 
The popularity of smartphones makes the smartphone addiction increasingly commonplace

引起社会广泛关注
this phenomenon has become a worldwide social problem
... has stirred wide social concern

 反应了很多人对于...的看法
the concept of ... is gaining more popularity and striking deeper roots in people&#39;s heart
it reflects a number of people&#39;s concepts about ...
people come to realize that it is of practical value to stick to the famous saying:

引出谚语
As the well-known proverb goes
Though it is the insight summarized by our forefathers, it is correct and applicable in many case today.

解释谚语
The message it conveys is that

过渡句
Among countless reasons which support my view, there are three conspicuous aspects as follow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;First and foremost, there is no doubt that ...
Moreover no one can deny that 
Last but not least, i firmly believe that


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;in conclusion / To sum up / All in all
while stressing... we should not neglect...

joint efforts should be made to promote...
we spare no efforts to do
if we try our upmost to do
the more.. the more...

our future will be both hopeful and rosy
The pursuit of ... should never be ceased 追逐...的步伐从不应该停止

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;高级短语&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;as it literally shows
the reason why
the overwhelming majority of 绝大多数
be reluctant to 不情愿
of practical value to do 有实际意义做
stick to 
reflect 反映
remarkable
reveal 揭示
tend to 
a high population of 56 percent of people
Thus
its urgent to do
as is universally acknowledged 
be of great significance
increasingly important
people believe that
extend to
the popularity of 
exerts multiple adverse impacts 造成多重不利影响
individual
all-pervasive 无所不在
quit a few peoper would deem that ... 少数人会认为
in contrast
intriguing 有趣
modern citizens
enhance
its obvious that
it&#39;s a high time that
joint efforts from relative authorities, teachers and students are required
Do bear in mind: 一定要记住
attach importance to
reinforce
one should adapt himself to the environment
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;阅读&#34;&gt;阅读&lt;/h1&gt;
&lt;p&gt;找和题干最匹配的句子，句意、同义词替换&lt;br&gt;
读句子抓主谓宾，副词、形容词实在不知道可以先不卡看&lt;br&gt;
对比相似选项，看哪个和原文最匹配，防止误选&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;段落匹配&lt;/strong&gt;&lt;br&gt;
先读题干句子，抓关键词&lt;br&gt;
看首尾句，明确段意&lt;br&gt;
抓句子关键词，带回段落定位&lt;/p&gt;
">六级</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/linux-ubuntu/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/m0_47668487/article/details/115289154&#34;&gt;VMware下安装Ubuntu系统并编译运行C语言程序&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_44301630/article/details/122390018?app_version=5.7.5&amp;amp;code=app_1562916241&amp;amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22122390018%22%2C%22source%22%3A%22unlogin%22%7D&amp;amp;uLinkId=usr1mkqgl919blen&amp;amp;utm_source=app&#34;&gt;WSL2 Ubuntu 安装 /该方法的图形界面安装出错&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.788.recommend_more_video.-1&amp;amp;vd_source=0c47757b752e4a1eb04429ea32a157dc&#34;&gt;VMware 安装&lt;/a&gt;&lt;br&gt;
该版本安装包：&lt;br&gt;
链接：https://pan.baidu.com/s/14I13g2N6hdeQf6RpL6Y9_g?pwd=xf0c&lt;br&gt;
提取码：xf0c&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/top_worker/article/details/45918399&#34;&gt;Ubuntu 教程&lt;/a&gt;&lt;br&gt;
Tasksel 安装出错&lt;br&gt;
解决：&lt;a href=&#34;https://mlog.club/article/3125331&#34;&gt;系统范围的安装都需要 root 权限，使用 sudo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Davidietop/article/details/88909622&#34;&gt;failed to fetch/配置 DNS 网关&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进入 ROOT 模式：root -i&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_42175986/article/details/82770878&#34;&gt;文件操作&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_43798960/article/details/106891641&#34;&gt;保存文件并退出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1w741147G9?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;环境变量讲解1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1nS4y1o7LG?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;环境变量讲解2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1pZ4y1N7pr?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;Linux 环境变量&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/K_K_yl/article/details/119756206&#34;&gt;环境变量的配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/sydongjx/article/details/44081265&#34;&gt;解决bash:没有那个文件或目录的方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Joker00007/article/details/122526177&#34;&gt;Ubuntu报错 写入失败(设备上没有空间)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用vmware配置ubuntu&#34;&gt;使用VMware配置Ubuntu&lt;/h1&gt;
&lt;p&gt;使用VMware安装时，界面显示不全：按住win键 然后按住鼠标左键拖动， 安装完再去设置vmware&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/130984945&#34;&gt;VMware虚拟机网络配置-NAT篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;共享文件夹加载问题：在虚拟机中刷新文件夹，点向下的箭头，点击重新加载刷新&lt;/p&gt;
">【Linux】Ubuntu</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/linux-shell/"" data-c="
          &lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/linux_tutorial/&#34;&gt;Linux 教程1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.runoob.com/linux/linux-tutorial.html&#34;&gt;Linux 教程2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.runoob.com/linux/linux-intro.html&#34;&gt;Linux shell 教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于 Windows 而言，其 cmd 和 powershell 都属于 shell 程序，但 cmd 能干的事 powershell 都能干。&lt;a href=&#34;https://zhuanlan.zhihu.com/p/390464588#:~:text=powershell%E5%92%8Ccmd%E5%8C%BA%E5%88%AB%EF%BC%9A1%E3%80%81CMD%E5%86%99%E7%9A%84BAT%E8%84%9A%E6%9C%AC%E6%88%91%E4%BB%AC%E7%9C%8B%E4%BD%9C%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%EF%BC%8C%E8%80%8CPowerShell%E5%88%99%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%2C%E6%98%AF%E4%B8%80%E7%A7%8D%E7%AB%99%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%80%85%E7%9A%84%E8%A7%92%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%9B2%E3%80%81CMD%E5%8F%AA%E8%83%BD%E6%89%A7%E8%A1%8C%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%8CPowerShell%E5%9B%A0%E4%B8%BA%E6%98%AF%E5%9F%BA%E4%BA%8E%E3%80%90.NET%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E3%80%82,%E6%9C%AC%E6%96%87%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%EF%BC%9Awindows7%E7%B3%BB%E7%BB%9F%E3%80%81Dell%20G3%E7%94%B5%E8%84%91%E3%80%82&#34;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
">【Linux】Shell</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shu-ju-jie-gou-di-gui/"" data-c="
          &lt;p&gt;&lt;strong&gt;递归乘法的实现（未考虑负数版）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def multi(a, b):  # 返回 b 个 a 的和
    if b == 0:
        return 0
    else:
        return multi(a, b-1) + a

print(multi(2,3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;递归实现斐波那契数列&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(n):  # 斐波那契
    if n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        return f(n - 1) + f(n - 2)


print(f(10))
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】递归</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-shen-jing-wang-luo-yu-shen-du-xue-xi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://nndl.github.io/&#34;&gt;邱锡鹏版&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zh-v2.d2l.ai/&#34;&gt;《动手学深度学习》&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.deeplearningbook.org/&#34;&gt;Deep Learning Book&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37471802&#34;&gt;one-hot 编码&lt;/a&gt;：&lt;br&gt;
将类别数据编码为数字，在 pandas 中采用 pd.get_dummies 函数&lt;/p&gt;
">【ML】神经网络与深度学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/sql/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.lintcode.com/course/14/learn/?chapterId=79&amp;amp;sectionId=530&#34;&gt;入门学习网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本博客练习数据获取网站：&lt;a href=&#34;https://www.db-book.com/&#34;&gt;https://www.db-book.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Kr4y1i7ru/?p=3&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;MySQL 启动&lt;/a&gt;&lt;br&gt;
以管理员启动 cmd，输入 net start mysql80 启动服务，输入 net stop mysql80 关闭服务&lt;br&gt;
在启动服务之后，找到 MySQL 8.0 Command Line Client ，输入密码即可访问数据库&lt;/p&gt;
&lt;p&gt;MySQL IDE —— Workbench&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1PY411b7Y2/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;基础教学&lt;/a&gt;&lt;br&gt;
单条运行快捷键：选中单条语句，CTRL + enter&lt;br&gt;
格式化：选中代码块 CTRL + B&lt;/p&gt;
&lt;p&gt;SQL 不区分大小写，注意句尾一定加分号&lt;/p&gt;
&lt;p&gt;SQL shell 中使用向上箭头复制刚才输入的命令&lt;/p&gt;
&lt;h1 id=&#34;mysql-语法&#34;&gt;MySQL 语法&lt;/h1&gt;
&lt;h1 id=&#34;ddl-data-definition-language&#34;&gt;DDL （Data Definition Language）&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数据定义语言，用于定义数据库对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询所有数据库（注意一定分号结尾&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询当前正在使用的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select database();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建数据库 （中括号中为可选内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除数据库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;drop database [if exists] 数据库名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用数据库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;use 数据库名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据库中的表操作&lt;/strong&gt;&lt;br&gt;
查询当前数据库中所有的表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询表结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;desc 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table 表名(
    字段1 字段1类型 comment 字段1 注释,
    字段2 字段2类型 comment 字段2 注释,
    ...
    字段n 字段n类型 comment 字段n 注释
) comment 注释;

例子：
create table sheet1(
id int comment &#39;编号&#39;,
name varchar(50) comment &#39;姓名&#39;,
age int comment &#39;年龄&#39;
)comment &#39;用户表&#39;;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询指定表的建表语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;show create table 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];  

例子：
alter table sheet1 add nickname varchar(10) comment &#39;昵称&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改数据类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;alter table 表名 modify 字段名 新数据类型(长度);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改字段名和字段类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;alter table 表名 change 旧字段名 新字段名 数据类型(长度) [comment 注释] [约束];  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;alter table 表名 drop 字段名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改表名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;alter table 表名 rename to 新表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;drop table [if exists] 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除表，并重新创建表（等价于清除表内所有数据）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;truncate table 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;dmldata-manipulation-language&#34;&gt;DML（Data Manipulation Language）&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数据操作与语言，用于增删改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向表中插入数据，注意列名和 values 的对应关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into 表名 (字段名1, 字段名2, ...) values(值1, 值2, ...);

例：
insert into test (id, name, age, username) values(1, &amp;quot;jerome&amp;quot;, 20, &#39;zjl&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;向表中全部字段插入数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into 表名 values(值1, 值2, ...);

例：
insert into test values(1, &amp;quot;jerome&amp;quot;, 20, &#39;zjl&#39;);

Add a new tuple to student with tot_creds set to null

insert into student
values (’3003’, ’Green’, ’Finance’, null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;批量插入用逗号分隔每一行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;例：
insert into test values(1, &amp;quot;jerome&amp;quot;, 20, &#39;zjl&#39;), (2, &amp;quot;raymond&amp;quot;, 21, &#39;R&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加 select&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;Add all instructors to the student relation with tot_creds set to 
0

insert into student
select ID, name, dept_name, 0
from instructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改数据（注，若安全模式报错：&lt;a href=&#34;https://www.cnblogs.com/willingtolove/p/12368712.html&#34;&gt;解决方案&lt;/a&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;update 表名 set 字段名1 = 值1, 字段名2 = 值2, ... [where 条件];

例：
update test set name = &#39;Jerome&#39; where id = 1;

修改整列：
update test set age = 30;

Increase salaries of instructors whose salary is over 
$100,000 by 3%, and all others by a 5% 

update instructor
set salary = salary * 1.03
where salary &amp;gt; 100000;
update instructor
set salary = salary * 1.05
where salary &amp;lt;= 100000;

case 版本：
update instructor
set salary = case
                    when salary &amp;lt;= 100000 then salary * 1.05
                    else salary * 1.03
                    end

Recompute and update tot_creds value for all students

update student S 
set tot_cred = (
select sum(credits)
from takes, course
where takes.course_id = course.course_id and 
S.ID= takes.ID.and 
takes.grade &amp;lt;&amp;gt; &#39;F&#39; and
takes.grade is not null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;delete from 表名 [where 条件];

例：
delete from test where gender = male;

Delete all tuples in the instructor relation for those instructors 
associated with a department located in the Watson building.

delete from instructor
where dept name in (select dept name
from department
where building = ’Watson’);

Delete all instructors whose salary is less than the average 
salary of instructors

delete from instructor
where salary &amp;lt; (select avg (salary) 
from instructor);

删除所有数据：
delete from test;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;dqldata-query-language&#34;&gt;DQL（Data Query Language）&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数据查询语言，用于查询数据库中表的记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DQL 语句的编写顺序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 
    字段列表
from
    表名列表
where
    条件列表
group by
    分组字段列表
having
    分组后条件列表
order by
    排序字段列表
limit
    分页参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DQL 语句的执行顺序&lt;br&gt;
执行顺序影响了变量别名的使用顺序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;from
    表名列表
where
    条件列表
group by
    分组字段列表
having
    分组后条件列表
select 
    字段列表
order by
    排序字段列表
limit
    分页参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询多个字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 字段1,字段2, ... from 表名;

查询所有字段
select * from 表名;

例：
select id,name from student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置别名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 字段1 as 别名1, 字段2 as 别名2, ... from 表名;

例：
select name as &amp;quot;姓名&amp;quot; from student;

as 可以省略：
select name &amp;quot;姓名&amp;quot; from student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去重查询&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct 字段列表 from 表名;

例：
select distinct dept_name &amp;quot;课程&amp;quot; from student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;条件查询 where&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 字段列表 from 表名 where 条件列表;

多种条件的案例：
普通条件
select * from student where name = &#39;Zhang&#39;;
select ID,tot_cred from student where name = &#39;Zhang&#39;;

不等关系
select * from student where tot_cred &amp;lt;= 60;
select * from student where tot_cred != 60;

查询空值
select * from student where tot_cred is null;

查询非空值
select * from student where tot_cred is not null;

区间查找
select * from student where tot_cred &amp;gt; 50 and tot_cred &amp;lt;= 60;
select * from student where tot_cred between 50 and 60;
注：between and 既包含最大也包含最小

多条件查找
select * from student where dept_name = &amp;quot;Physics&amp;quot; and tot_cred &amp;lt;= 60;

使用元组进行比较
select *
from instructor, teaches
where (instructor.ID, dept_name) = (teaches.ID, &#39;Biology&#39;);
等价于
where instructor.ID = teaches.ID, dept_name = &#39;Biology&#39;;

或关系查找
select * from student where dept_name = &amp;quot;Physics&amp;quot; or dept_name = &amp;quot;Music&amp;quot;;
select * from student where dept_name in(&amp;quot;Physics&amp;quot;,&amp;quot;Music&amp;quot;);

模糊查询 like
匹配七个字长的名字，like 后加七个下划线
select * from student where dept_name like &#39;_______&#39;;
匹配最后一位 / 最后几位：查询以 Sci. 结尾的课程名，%代表匹配前面所有字符
select * from student where dept_name like &#39;%Sci.&#39;;
匹配名字中含有 da 的 instructor
select name 
from instructor
where name like &#39;%da%&#39;
使用“\”转义
select *
from sheet
where score like &#39;100 \%&#39; escape &#39;\&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见聚合函数。用于对列进行操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;count 统计数量
max 最大值
min 最小值
avg 平均值
sum 求和

语法：
select 聚合函数(字段列表) from 表名;
注：所有的 null 值不参与聚合函数计算

例：
select count(*) from student;
select avg(tot_cred) from student;
select max(tot_cred) from student;
select min(tot_cred) from student;
select sum(tot_cred) from student where dept_name = &amp;quot;Comp. Sci.&amp;quot;;

找出在 Spring 2010 semester 教课的 instructor 总数
select count(distinct ID)
from teaches
where semester = &#39;Spring&#39; and year = 2010;
注意，以 ID 为统计对象，并注意去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分组查询&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;语法：
select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];
先满足 where 条件，再满足 having 条件；where 中不能使用聚合函数，having 中可以

例：
按照课程名称统计数量
select dept_name, count(*) 
from student 
group by dept_name;

按照课程名称分组，统计平均得分
select dept_name, avg(tot_cred) 
from student 
group by dept_name;

查询总分小于 60 的学生，按照课程名分组，获取选课人数等于 3 的课程
select dept_name, count(*) 
from student 
where tot_cred &amp;lt; 60 
group by dept_name 
having count(*) = 3;

注：分组查询后返回一般为聚合函数或分组字段。如果查询单个值是没有意义的，只显示第一个值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;排序查询&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 字段列表 from 表名 order by 字段1 排序方式1, 字段2 排序方式2;
先按字段1排，相同再按字段2排序

asc 表示升序，desc 表示降序
select * from student order by tot_cred asc;
select * from student order by tot_cred desc;

先按照总分进行升序排序，若总分相同，再按照学号进行降序排序
select * from student order by tot_cred asc, ID desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分页查询&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 字段列表 from 表名 limit 起始索引, 查询记录数;
起始索引的计算公式：（当前页码数-1）x 每页记录数
起始索引从 0 开始

例：
查询第一页，每页 6 条记录
select * from student limit 0, 6;
可省略作：
select * from student limit 6;

查询第二页六条记录：
select * from student limit 6, 6;

查询第二页六条记录：
select * from student limit 12, 6;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注&lt;/code&gt; 执行多个条件的时候，可以把每个条件加括号，看起来更清晰&lt;/p&gt;
&lt;p&gt;嵌套查询&lt;br&gt;
Find courses offered in Fall 2009 but not in Spring 2010&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct course_id
from section
where semester = &#39;Fall&#39; and year= 2009 and 
course_id not in (
select course_id 
from section
where semester = &#39;Spring&#39; and year= 2010
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多关系表查询&lt;br&gt;
由于要查询的数据在不同关系表中，所以要从多张表中查询数据&lt;br&gt;
&lt;strong&gt;一对多 / 多对一的关系&lt;/strong&gt;&lt;br&gt;
案例：部门 与 员工的关系，一个部门对应多个员工&lt;br&gt;
实现：在多的一方建立外键，指向一的一方的主键&lt;br&gt;
&lt;strong&gt;多对多的关系&lt;/strong&gt;&lt;br&gt;
案例：学生 与 选修课的关系，一个学生对应多个课程，一个课程也可以对应多个学生&lt;br&gt;
实现：建立第三张中间表，至少包含两个外键，分别关联两方的主键&lt;br&gt;
&lt;strong&gt;一对一的关系&lt;/strong&gt;&lt;br&gt;
案例：用户 与 用户详情的关系，将基础字段和详情字段拆分，提高查询效率&lt;br&gt;
实现：在任意一张表加入外键，关联另一方主键&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;例：
查找教艺术的所有教师姓名和课程 ID
select name, course_id
from instructor , teaches
where instructor.ID = teaches.ID and instructor. dept_name =  &#39;Art&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注&lt;/code&gt;&lt;br&gt;
select name, course_id from instructor , teaches；这条语句将 instructor 和 teaches 表做笛卡尔积，是没有进行主键自动匹配等操作的，即 但看这个表是没有任何意义的。而后面的 where 语句条件限制，从 笛卡尔积得到的结果的一张大表 中 筛选出有意义的行数。&lt;br&gt;
　　from 子句中包括多个关系表时，一定要在 where 子句中加入连接条件！过滤掉无效的笛卡尔积（两个集合连接时每个元素会分别组合，但是只有键相同的组合是有用的）&lt;br&gt;
实际应用中，对频繁执行的SQL查询，其 from 子句中的表的个数不要过多，如不要超过4个！避免耗时费力的多表连接操作。&lt;br&gt;
如果频繁执行的 SQL 查询涉及的查询数据存放在 N≥4 张表中，可以考虑将这N张表中的数据进行合并&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_45404693/article/details/120630581?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166506743816782391878796%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=166506743816782391878796&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-120630581-null-null.142%5Ev51%5Epc_rank_34_queryrelevant25,201%5Ev3%5Econtrol_2&amp;amp;utm_term=mysql%20join&amp;amp;spm=1018.2226.3001.4187&#34;&gt;MySQL 中 join 的用法&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_44747858/article/details/107720930?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166506743816782391878796%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=166506743816782391878796&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-107720930-null-null.142%5Ev51%5Epc_rank_34_queryrelevant25,201%5Ev3%5Econtrol_2&amp;amp;utm_term=mysql%20join&amp;amp;spm=1018.2226.3001.4187&#34;&gt;MySQL 中 join 的用法，含有 natural join、using 等简化版语句&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下三种写法都是取二者的笛卡尔积，但在加限定条件时，只有 带有 join 的语句才能用 on 和 using 语法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from teaches, takes;
select * from teaches join takes;
select * from teaches cross join takes;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;natural join 自动匹配两表中键相同的列（注意，natural 一定不要拼错，要不会变成重命名语句）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *
from instructor natural join teaches

等价于

select *
from instructor join teaches
using(ID)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用 natural join 简化语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT customer.customer_name
FROM customer
JOIN depositor ON customer.customer_id = depositor.customer_id
JOIN account ON depositor.account_number = account.account_number
JOIN branch ON account.branch_name = branch.branch_name
WHERE customer.city = &#39;Beijing&#39;
  AND branch.city = &#39;Tianjin&#39;
  AND account.balance &amp;gt; 100;

简化为

SELECT customer.customer_name
FROM customer
NATURAL JOIN depositor
NATURAL JOIN account
NATURAL JOIN branch
WHERE customer.city = &#39;Beijing&#39;
  AND branch.city = &#39;Tianjin&#39;
  AND account.balance &amp;gt; 100;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/94659348&#34;&gt;all/any/some/in&lt;/a&gt;&lt;br&gt;
用 A B 两个实数集合举例&lt;br&gt;
all：A &amp;gt; all( B ) ，则 A 中选出的数要比 B 中所有的数都大&lt;br&gt;
some/any：A &amp;gt; some/any( B )，则 A 中选出的数只要有比 B 中的数大的就行，选出的结果往往是原列表除去最小值后的列表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;Find the names of all instructors whose salary is greater 
than the salary of all instructors in the Biology department.

select name
from instructor
where salary &amp;gt; all (
select salary
from instructor
where dept name = &#39;Biology&#39; 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/sql/sql-exists.html&#34;&gt;EXISTS&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.geeksforgeeks.org/sql-except-clause/&#34;&gt;Except&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;unique&lt;/strong&gt;&lt;br&gt;
如果作为参数的子查询结果中无重复元组，则 unique 返回 true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;with as 的用法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;Find all departments where the total salary is greater than 
the average of the total salary at all departments

with dept _total (dept_name, value) as
    (select dept_name, sum(salary)
    from instructor
    group by dept_name),
dept_total_avg(value) as
    (select avg(value)
    from dept_total)
select dept_name
from dept_total, dept_total_avg
where dept_total.value &amp;gt; dept_total_avg.value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析：其中，dept _total 和 dept_total_avg 是两个临时创立的表，括号里是表定义的特征，分别对应 as 后面 select 后选出的特征。定义临时表后，在后续 select 语句中就可以直接使用。&lt;/p&gt;
&lt;p&gt;标量子查询（Scalar subquery）：只需要查询单个值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select dept_name, 
(select count(*) 
from instructor 
where department.dept_name = instructor.dept_name)
as num_instructors
from department;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析：括号中 select count 语句只查询了单个值，将其命名为 num_instructors，作为外层 select 的子查询，表示 instructor 的数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合案例&lt;/strong&gt;&lt;br&gt;
找出工资高于 Comp. Sci. 学院的所有 instructors 的 instructors 名字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct T.name
from instructor as T, instructor as S
where T.salary &amp;gt; S.salary and S.dept_name = &#39;Comp. Sci.&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：利用 T 、S 重命名以区分不同的 instructor，实现了对同一属性的不同值的比较。&lt;/p&gt;
&lt;p&gt;从 2009 年秋季开设的每个课程段中，找出最多的选课人数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sec_id , max(countid)
from (
select sec_id, count(ID) countid
from takes
where semester = &amp;quot;Fall&amp;quot; and year = &#39;2009&#39;
group by sec_id
) as countidlist
group by sec_id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;视图 —— view&lt;/strong&gt;&lt;br&gt;
视图关系可以定义为包含查询结果的关系。可以隐藏不需要的信息，可以把信息从多个关系收集到一个单一的试视图中。&lt;/p&gt;
&lt;p&gt;创建视图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create view com_instructor as(
select *
from instructor
where dept_name = &#39;Comp. Sci.&#39;
);
select *
from com_instructor;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;drop view com_instructor;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://m.biancheng.net/sql/transaction.html&#34;&gt;&lt;strong&gt;事务——transaction&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
　　将一条/几条语句关联在一起，要么全部执行成功，要么全部执行失败。如果成功，则提交（Commit）如果其中有一条执行失败，则全部回滚（Rollback）（重新执行）防止数据库信息受损。&lt;br&gt;
事务有很多实用的场景。例如对于电商网站，通常将用户订单存储在一张表中，将商品库存情况存储在另一张表中，当有用户下单时，需要执行两条 SQL 语句，一条负责更新订单表，一条负责更新库存表，这两条 SQL 语句必须同时执行成功。如果只有一条语句执行成功，另一条语句执行失败，将导致数据库出错，这种后果是无法接受的。&lt;br&gt;
　　为了避免出现意外，可以将以上两条语句放到一个事务中，其中一条语句执行失败时，数据库将回滚到原来未修改的状态。对于买家来说，数据库回滚会导致下单失败，但这很容易处理，让买家再次下单即可。数据库的正确性永远是最重要的。&lt;br&gt;
　　其实我们平时使用数据库时，就已经在使用事务了，只不过这种事务只包含一条 SQL 语句，并且由数据库引擎自动封装和提交。这意味着，对于任何一条 SQL 语句，要么执行成功，要么执行失败，不能成功一部分，失败一部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整性约束&lt;/strong&gt;&lt;br&gt;
保证授权用户对数据库做出的改变不会导致数据一致性的破坏，在创建表的时候添加关键字添加约束&lt;br&gt;
常用约束总结：&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1669360961356.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主键约束 primary key&lt;br&gt;
该项为主键，唯一且非空&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table student_1(
    id varchar(10) primary key,
    name varchar(15),
    age int(2),
    sex varchar(1)
)
desc student_1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;唯一约束 unique&lt;br&gt;
指该项在表中不能重复&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table student(
	id int(8),
	name varchar(20) unique,
	school varchar(10),
	age int(2),
	sex varchar(1)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非空约束 not null&lt;br&gt;
直接写在非空变量的后面即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table instructor(
    ID varchar (5),
    name varchar (20), not null
    dept_name varchar (20)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认约束 default&lt;br&gt;
指在没有对某字段插入具体值的时候，使用默认的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table student(
	id int(8),
	name varchar(20),
	age int(2),
	sex varchar(1) default &#39;男&#39;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;外键约束 foreign key&lt;br&gt;
某一表中某字段的值依赖于另一张表中某字段的值&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1669362336311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
check 子句&lt;br&gt;
可以定义某一字段满足某种限定&lt;br&gt;
用check子句模拟了一个枚举类型，限定了semester必须是四个中的一个&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1669362564221.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
限定了该字段值的范围&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1669362622241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43524214/article/details/122850808&#34;&gt;参照完整性约束：当一个表作为另几个表的参照时，对该表的操作会影响参照该表的表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/molihuakai_118/article/details/85224637&#34;&gt;触发器约束&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;dcldata-control-language&#34;&gt;DCL（Data Control Language）&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数据控制语言，用于创建数据库用户、控制数据库的访问权限&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/happyheng/article/details/53143345&#34;&gt;SQL索引详解&lt;/a&gt;&lt;br&gt;
　　索引是一种特殊的查询表，可以被数据库搜索引擎用来加速数据的检索。简单说来，索引就是指向表中数据的指针。数据库的索引同书籍后面的索引非常相像。&lt;br&gt;
　　索引分为聚集索引和非聚集索引&lt;br&gt;
&lt;strong&gt;聚集索引 clustering index&lt;/strong&gt;&lt;br&gt;
　　有主键的表，主键即为聚集索引。MySQL 不能手动创建聚集索引，在创建主键的时候自动创建聚集索引。如果没有创建主键，那么默认非空的列为聚集索引，如果没有非空的列那么会自动生成一个隐藏列为聚集索引。&lt;br&gt;
　　聚集索引可以理解为顺序排列，比如一个主键自增的表即为聚集索引，即 id 为1的存在于第一条，id为 2 的存在于第二条... 假使数据库中是使用数组来存放的这张表中的数据，那么如果我需要查找第100条，那么直接第一条数据的地址加上100即为第一百条的地址，一次就能查询出来。&lt;br&gt;
　　因为数据库中的数据只能按照一个顺序进行排列，所以聚集索引一个数据库只能有一个。所以一般在MySQL 中，我们创建的主键即为聚集索引，数据是按照我们的主键顺序进行排列。所以在根据主键进行查询时会非常快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非聚集索引 nonclustering index&lt;/strong&gt;&lt;br&gt;
非聚集索引可以简单理解为有序目录，是一种以空间换取时间的方法。举个例子，在一个user表中，有一个id_num，即身份号，此不为主键id，那么这些数据在存储的时候都是无序的，比如&lt;br&gt;
id为1的id_num为100，id为2的id_num为97，id为3的id_num为98，id为4的id_num为99，id为5的id_num为96。。。id为67的id_num为56。。。&lt;br&gt;
那么如果我要查找id_num为56的人，那么只能一条一条的遍历，n条就需要查询n次，时间复杂度为O(n)，这是非常耗费性能的。&lt;/p&gt;
&lt;p&gt;所以，现在就需要为id_num增加非聚集索引，添加了非聚集索引后，会给id_num进行排序（内部使用结构为B+树），并且排序后，我只需要查询此目录(即查询B+树)，很快就知道为id为56的在数据库中的第67条，而不需要在去遍历表中的所有数据。&lt;br&gt;
所以，在非聚集索引中，不重复的数据越多，那么索引的效率越高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jeaforea/article/details/61420445&#34;&gt;稠密索引 dense index、稀疏索引 sparse index&lt;/a&gt;&lt;br&gt;
稠密：为每个搜索码都建立索引       稀疏：只为一部分搜索码建立索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引的选择原则&lt;/strong&gt;&lt;br&gt;
　　非聚集索引在数据库创建、增加、删除、修改的时候都需要作出相应的修改，所以，使用索引也是有一定的原则，即：&lt;/p&gt;
&lt;p&gt;1、较频繁的作为查询条件的字段应该创建索引&lt;br&gt;
2、重复太多的字段不适合单独创建索引，即使频繁作为查询条件&lt;br&gt;
3、不会出现在WHERE子句中的字段不应该创建索引&lt;/p&gt;
&lt;p&gt;以下情况不建议使用索引&lt;br&gt;
　1、小量的数据不用建索引（参考值一万条数据往下为小量数据），如果对小量数据建立索引可能会更慢，因为索引查找是二次查找，直接全表查询即可。&lt;br&gt;
　2、需要频繁进行大批量的更新或者插入操作的表；&lt;br&gt;
　3、如果列中包含大数或者 NULL 值，不宜创建索引；&lt;br&gt;
　4、频繁操作的列不宜创建索引。&lt;br&gt;
　5、不重复的字段越多，那么索引的价值越高，查看不重复的字段占总体的比例可以使用下面的sql语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;    SELECT count(DISTINCT(name))/count(*) AS Selectivity FROM index_test;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如上面这个sql就是判断index_test表中name字段中不重复的值占整体的比例，这个比例应该在(0,1]之间，这个数值越大，越应该使用索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建索引&lt;/strong&gt;&lt;br&gt;
创建普通索引&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX index_name ON table_name(属性名);
或者
修改表: ALTER TABLE 表名 ADD INDEX 索引名 (列名1，列名2,...);
或者
创建表时指定索引：CREATE TABLE 表名 ( [...], INDEX 索引名 (列名1，列名 2,...) );
eg:
CREATE INDEX name_index ON index_test(name);
此为在index_test表上的name列上创建一个索引name_index。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建唯一索引（添加UNIQUE字段）&lt;br&gt;
下面三种模式都可以创建唯一索引：&lt;br&gt;
1、创建索引：CREATE UNIQUE INDEX 索引名 ON 表名(列的列表);&lt;br&gt;
2、在表上增加索引：ALTER TABLE 表名ADD UNIQUE 索引名 (列的列表);&lt;br&gt;
3、创建表时指定索引：CREATE TABLE 表名( [...], UNIQUE 索引名 (列的列表) );&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE UNIQUE INDEX id_num_index ON index_test(idNum);
也可以写成下面的形式：
 ALTER TABLE index_test ADD UNIQUE id_num_index(idNum);
此为在index_test表的idNum列上创建一个唯一索引id_num_index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除索引&lt;br&gt;
以下两种模式都可以删除索引：&lt;br&gt;
DROP INDEX index_name ON talbe_name&lt;br&gt;
ALTER TABLE table_name DROP INDEX index_name&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;eg:
DROP INDEX name_index ON index_test;
此为删除在index_test表上的name_index索引       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/149287061&#34;&gt;B+树看这一篇就够了（B+树查找、插入、删除全上）&lt;/a&gt;&lt;/p&gt;
">SQL</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shu-ju-jie-gou-dong-tai-gui-hua/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1xb411e7ww?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;B站讲解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/365698607&#34;&gt;知乎好文&lt;/a&gt;&lt;br&gt;
&lt;code&gt;适用题目特点&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计数&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;有多少种方式走到右下角&lt;/li&gt;
&lt;li&gt;有多少种方法选出 k 个数使得和是 Sum&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;求最大最小值&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从左上角走到右下角路径的最大数字和&lt;/li&gt;
&lt;li&gt;最长上升子序列长度&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;求存在性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;取石子游戏，先手是否必胜&lt;/li&gt;
&lt;li&gt;能不能选出 k 个数使得和是 Sum&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;最值型解题步骤&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;最后一步（最优策略中使用的最后一枚硬币 ak）&lt;/li&gt;
&lt;li&gt;化成子问题（最少的硬币拼出前面的面值 27-ak）  {前两步和递归很像}&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;转移方程&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;f(x) = min{f(x-2)+1, f(x-5)+1, f(x-7)+1}&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;初始条件和边界情况&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;f(0) = 0，如果不能拼出Y，f(Y) = +∞&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;计算顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从小到大计算，f(0)，f(1)，f(2)....&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.cn/problems/coin-change/&#34;&gt;leetcode 零钱兑换&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目分析：&lt;br&gt;
假设有面值为 2，5，7 的三种硬币无数个，要求用最少的硬币个数凑出 27&lt;br&gt;
&lt;code&gt;步骤&lt;/code&gt;&lt;br&gt;
先假定最优解的最后一个硬币面值为 ak，则之前的硬币总面值为 27-ak&lt;br&gt;
则定义一个函数 f(x) ，表示构成面值 x 最少要  f(x) 个硬币&lt;br&gt;
找到 f(x) 的递归定义， f(x) 是减去最后一枚硬币的面值的最小值&lt;br&gt;
对特殊情况分别讨论&lt;br&gt;
从小到大计算各个递归阶段的值，从而避免了递归中的重复计算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def coinChange(self, coins, amount):
        f = [float(&#39;inf&#39;) for i in range(amount + 1)]  # 开辟从 0 到 amount 大小的数组，初始值设置为正无穷
        f[0] = 0  # 初始化 f[0] = 0 面值为 0 需要 0 个硬币
        # 这个 for 循环求凑出每一个面值最少需要多少硬币 f[1]、f[2]、f[3]...
        for i in range(1, amount + 1):  # i 代表面值，从 f[1] 开始，到 amount+1 共 amount 个数
            for j in coins:  # 遍历硬币的集合
                if i &amp;gt;= j and f[i - j] != float(&#39;inf&#39;):  # 如果 i 的面值比 j 大，且要判断的数有值
                    # f[i] 的值为 构成 i 面值去掉最后一枚 coin 的面值所需的硬币数，加一（最后一枚 取最小值
                    f[i] = min(f[i - j] + 1, f[i])
        if f[amount] == float(&#39;inf&#39;):  # 如果最后没有被更新，则说明无法构成
            f[amount] = -1
        return f[amount]


coins = [2, 5, 7]
amount = 27
s = Solution()
print(s.coinChange(coins, amount))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;例&lt;/code&gt; &lt;strong&gt;动态规划实现斐波那契数列&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(n):  # 动态规划斐波那契函数（从 n = 1 开始）
    a = [1 for _ in range(n + 1)]  # 开辟 0 ~ n 的数组
    a[1] = 1  # 初始化第一项，注意，第 0 项不用
    if n &amp;gt;= 2:  # 当 n 大于等于二的时候
        for i in range(3, n + 1):  # 第三项往后满足递推关系
            a[i] = a[i - 2] + a[i - 1]
    return a[-1]  # 返回最后一项的值

# for i in range(1, 11):  # 检查前 10 项
#     print(f(i))
print(f(100))  # 直接出第 100 项的值，用暴力递归不行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【优化版本】根据分析实际进行操作的只有三个内存，所以直接用三个变量进行替代&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(n):  # 动态规划斐波那契函数（从 n = 1 开始）
    if n == 1 or n == 2:
        return 1
    else:
        a = 1
        b = 1
        for i in range(2, n):
            sum = a + b  # 更新 c 的值
            a = b
            b = sum
    return sum  # 返回最后一项的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;例&lt;/code&gt; &lt;a href=&#34;https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/&#34;&gt;&lt;strong&gt;剑指 Offer 10- II. 青蛙跳台阶问题&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【分析】此问题和斐波那契数列几乎一模一样，根据上面的类比此题即可&lt;/p&gt;
&lt;p&gt;常规动态规划版&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def numWays(self, n):  # 跳了 n 个台阶有几种跳法
        a = [1 for _ in range(n + 1)]  # 开辟数组，初始化都为 1，a[0] = 1
        if n == 1:  # 单独判断 n 为 1 的时候，防止数组溢出
            a[1] = 1
        elif n &amp;gt; 1:
            a[1] = 1  # 初始化前两个
            a[2] = 2
            for i in range(3, n + 1):  # 从第三位开始到最后写递推式
                a[i] = a[i - 1] + a[i - 2]
        return a[-1] % 1000000007  # 题目要求取模
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【优化版本】根据分析实际进行操作的只有三个内存，所以直接用三个变量进行替代&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def numWays(self, n):  # 跳了 n 个台阶有几种跳法
        # 单独判断前三个取值
        if n == 0:  
            return 1
        elif n == 1:
            return 1
        elif n == 2:
            return 2
        # 计算一般情况
        a = 1  # 初始化
        b = 2
        for i in range(2, n):  # 执行 n-2 步迭代
            sum = a + b  # 更新 sum 的值
            a = b
            b = sum
        return sum % 1000000007
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【再优化版】初始化 a，b 在一行；去掉了第三个变量 c ，直接用计算结果替换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numWays(self, n):
        a, b = 1, 1
        for _ in range(n):
            a, b = b, a + b  # a = b；b = a+b
        return a % 1000000007
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】动态规划（Dynamic programming，DP）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/cao-zuo-xi-tong-bi-ji/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43914604/article/details/104415990&#34;&gt;CSDN 王道笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用户运行程序不需要向操作系统预定时间&lt;br&gt;
系统吞吐量指的是系统在&lt;strong&gt;单位时间&lt;/strong&gt;内可处理的事务的数量，是用于衡量系统性能的重要指标。&lt;br&gt;
批处理的缺点是缺少交互性，交互性指用户可以控制操作系统处理指令&lt;br&gt;
多道程序设计技术是为了提高系统利用率和吞吐量&lt;br&gt;
内核可以执行 CPU 能处理的任何指令，而用户程序只能执行除特权指令之外的指令。所以特权指令只能由内核（操作系统）使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断处理&lt;/strong&gt;&lt;br&gt;
计算机通过硬件中断机制完成从用户态到核心态的转换&lt;/p&gt;
&lt;p&gt;中断（外中断）：指 CPU 执行指令外部的事件。I/O中断、时钟中断&lt;br&gt;
异常（内中断）：指 CPU 执行指令内部的事件。一般都是程序报错，如地址越界、运算溢出、虚拟内存系统的缺页等。&lt;/p&gt;
&lt;p&gt;用户态转换为核心态的情况&lt;br&gt;
1）用户程序要求操作系统的服务，即系统调用&lt;/p&gt;
&lt;p&gt;用户在使用程序时，凡是与资源有关的操作，例如存储分配、I/O传输、文件管理等操作，都必须通过系统调用的方式向操作系统发出请求。&lt;br&gt;
类似于“在内存中取数”、“将运算结果装入内存”、”寄存器清 0“等指令操作，可以用汇编语言实现，所以用户态下也可以使用。&lt;br&gt;
用户程序执行陷入指令（访管指令/trap指令）发起系统调用，CPU由用户态变为核心态。访管指令在用户态使用，所以不可能是特权指令。&lt;br&gt;
这种机制保证了系统的稳定性和安全性，防止用户程序随意更改系统资源&lt;/p&gt;
&lt;p&gt;2）发生一次中断：程序产生错误、用户程序企图执行一条特权指令&lt;/p&gt;
&lt;p&gt;从核心态转用户态&lt;br&gt;
需要使用到中断返回指令，由于使用的时候在核心态，所以中断返回指令是特权指令&lt;/p&gt;
&lt;p&gt;子程序调用只需保存程序断点，即该指令的下一条指令的地址&lt;br&gt;
中断处理不仅要保存断点（PC 的内容），还要保存程序状态字寄存器（PSW）的内容&lt;/p&gt;
&lt;h1 id=&#34;2-进程与线程&#34;&gt;2 进程与线程&lt;/h1&gt;
&lt;p&gt;PCB （Process Control Block）进程控制块&lt;br&gt;
进程实体 / 进程映像 ：由程序段、相关数据段 和 PCB 三部分构成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;br&gt;
进程是资源分配的单位&lt;/p&gt;
&lt;p&gt;I/O 操作对进程的影响&lt;br&gt;
I/O 操作执行时需要中断，此时进程处于阻塞态，进程需要等待 I/O 的执行结果。完成后进程等待事件就绪，变为就绪态。&lt;/p&gt;
&lt;p&gt;程序的封闭性&lt;br&gt;
是指进程执行的结果只取决于进程本身，不受外界影响。进程不管是否断续执行，执行的速度不会影响执行结果。失去封闭性后，不同速度下执行的结果不同。&lt;/p&gt;
&lt;p&gt;进程的撤销&lt;br&gt;
进程可在完成时撤销，或在出现内存错误等时候撤销&lt;br&gt;
进程在时间片结束时是就绪，不是撤销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;&lt;br&gt;
将一个进程划分为多个线程，多个线程可以同时并发执行&lt;br&gt;
内核级线程是处理器调度和分派的单位&lt;/p&gt;
&lt;p&gt;线程没有自己的地址空间，它共享其所属进程的空间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信号量机制&lt;/strong&gt;&lt;br&gt;
信号量可以表示系统中某种资源的数量，比如打印机有 5 个，则信号量值为 5&lt;/p&gt;
&lt;p&gt;原语是一种特殊程序段，执行时只能一气呵成，不可以被中断。&lt;br&gt;
用一对原语实现对信号量的操作：&lt;br&gt;
wait() 和 signal()，也称为 P、V 操作 （源于荷兰语 proberen 和 verhogen）&lt;/p&gt;
&lt;p&gt;wait()、P 操作：对系统资源进行申请，并减少相应的信号量&lt;br&gt;
signal()、V 操作：对系统资源进行释放，并增加相应信号量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;例：&lt;/code&gt;&lt;br&gt;
系统中有一台打印机&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int source = 1;   // 设置系统中可用打印机资源数量为1，是全局变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;wait() 原语的实现；P 操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void wait(int source){
    if(source &amp;lt;= 0)  进入等待队列;     //如果系统资源数量不够，则进入等待队列
    source = source - 1;    //如果够用，则资源数量-1，占用一个资源
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;signal() 原语的实现；V 操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void signal(int source){
    source = source + 1;    //使用完资源后，释放资源，资源数+1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;进程 P0 ：
wait(source);      //num0：此时 source 为1，可以使用，执行 source = source - 1;  source 的值变为 0。然后假设此时 P1 进程试图访问打印机资源，跳到 num1
使用打印机资源
signal(source);   //num2：此时 P0 结束使用打印机，执行 source = source + 1; 释放资源，转到 num3

进程 P1 ：
wait(source);      //num1： 此时 source 为 0，执行 if 语句，进入等待队列。跳转到 num2
//num3：此时 P0 结束使用打印机，全局变量 source = 1; 执行 source = source - 1; 转到 num4
使用打印机资源
signal(source);    //num4： 使用结束，执行 source = source + 1; 释放资源
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中，source 就是信号量，代表系统中 打印机资源 的数量。用 wait 和 signal 两个原语对 source 的值进行更改，从而控制线程是否可用访问资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信号量机制实现进程的互斥和同步&lt;/strong&gt;&lt;br&gt;
互斥锁（Mutex）&lt;br&gt;
进程的互斥需要用到互斥锁。互斥锁是信号量机制 source = 1 的特殊情况，同时间只允许一个进程访问资源。所以各个进程之间是互斥的，所以称为进程的互斥。&lt;br&gt;
初始化 mutex = 1，像上面那样，把 wait 和 signal 中的 source 替换为 mutex 即可&lt;/p&gt;
&lt;p&gt;进程的同步&lt;br&gt;
同步指的是多个进程在同一时间段内如何有序的进行。如代码1必须在代码2前执行，我们需要用信号量机制来保证执行的顺序。&lt;br&gt;
具体实现：初始化 source 为 0 ，表示当前系统没有可用资源，在代码1后使用 V(source) 来释放资源，从而使 source 为 1；在代码 2 前面使用 P(source) 操作来申请资源，如果 source 值为 0，则表示代码1还没执行完，则 P 操作会阻塞代码2的进程，将2进程放入等待序列；若 source 值为 1，则表示代码1已经执行完毕，则 P 操作执行，代码2执行。&lt;br&gt;
总结：前进程后跟 V 操作，后进程前跟 P 操作 —— 前 V 后 P&lt;/p&gt;
&lt;p&gt;同步互斥总结：同步 初始化信号量为 0 ；互斥 初始化信号量为 1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4001/post-images/1676115188396.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1676115194872.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;综上：&lt;/code&gt;&lt;br&gt;
P：理解为申请、减少资源；V：理解为释放、增加资源&lt;br&gt;
当要实现互斥时，在两个·进程前后加PV；当要实现同步时，在先执行的进程后加V，后执行的进程前加P；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者消费者问题&lt;/strong&gt;&lt;br&gt;
分析题目中存在的同步和互斥关系，然后使用信号量控制&lt;br&gt;
访问缓冲区是互斥关系，同一时间只能有一个人访问；生产者和消费者互相等待对缓冲区的操作，是同步关系&lt;/p&gt;
&lt;p&gt;“缓冲区有空余，生产者生产，缓冲区非空，消费者消费”&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1676129782959.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注：为避免死锁，实现互斥的P操作一定要在实现同步的P操作之后&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免死锁——银行家算法&lt;/strong&gt;&lt;br&gt;
1.求Need矩阵&lt;br&gt;
用最大需求量矩阵（Max）减去已分配量矩阵（Allocation）&lt;/p&gt;
&lt;p&gt;2.判断系统是否处于安全状态&lt;br&gt;
如果能找到一个安全序列，则处于安全状态。&lt;br&gt;
判断方法：&lt;br&gt;
a.看Need矩阵中不同进程的资源需求量，先找小于系统可用资源的进程。&lt;br&gt;
b.用当前进程的已分配资源+系统可用资源，得到下一步的系统可用资源。&lt;br&gt;
c.重复上述步骤，如果成功得到进程序列，则该序列为安全序列。&lt;/p&gt;
&lt;p&gt;3.判断是否能满足新请求&lt;br&gt;
a.判断新请求序列是否小于系统资源，并是否小于该进程的最大需求，若都成立，则继续。&lt;br&gt;
b.然后用该进程的已分配资源+新请求，系统可用资源-新请求，Need-新请求。&lt;br&gt;
c.重复2.的步骤，如果成功得到安全序列，则可以满足新请求。&lt;/p&gt;
&lt;h1 id=&#34;3-内存管理&#34;&gt;3 内存管理&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Y44y1D7vv/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;&lt;strong&gt;页面置换算法&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
题干形如：&lt;br&gt;
在一个请求分页系统中，采用最近最少使用（LRU）页面置换算法时，假设一个&lt;br&gt;
作业的页面引用串为 1,3,2,1,1,3,5,1,3,2,1,5，当分配给该作业的物理块数分别为 3 和 4&lt;br&gt;
时，计算在访问过程中发生的缺页次数和缺页率。&lt;/p&gt;
&lt;p&gt;页面引用串为页面编号，物理块数为下面的行数。&lt;br&gt;
缺页次数：除了空的列，剩下都是缺页，都算在缺页次数&lt;br&gt;
缺页率：缺页次数/总页数&lt;br&gt;
页面置换次数：发生页面替换的列数&lt;/p&gt;
&lt;p&gt;OPT算法：最佳置换算法&lt;br&gt;
做题时，在下面标出，等到要替换的时候，从该处往后面找，最后看到的该列中的元素，为最近未使用的元素，则用当前元素替换掉该元素。&lt;/p&gt;
&lt;p&gt;LRU算法：最近最久未使用算法&lt;br&gt;
做题时，在下面标出，等到要替换的时候，从该处往前面找，最后看到的该列中的元素，为最近未使用的元素，则用当前元素替换掉该元素。&lt;/p&gt;
&lt;p&gt;FIFO算法：先进先出算法&lt;br&gt;
淘汰最先进入内存的页面。替换在列中存在时间最长的页面。&lt;/p&gt;
&lt;h1 id=&#34;5-io管理&#34;&gt;5 IO管理&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;磁盘&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1c4411w7Tn/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;&lt;strong&gt;磁盘调度算法&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
FIFO 先进先出：给定什么顺序就走什么顺序&lt;br&gt;
SSTF 最短服务时间优先：找与当前磁道号间隔最短的磁道号，用两个磁道号相减再绝对值，注意只看磁道号就行&lt;br&gt;
SCAN 扫描算法（电梯算法）：先向上走到头，找到最大磁道号，再向下走到最小磁道号&lt;br&gt;
C-SCAN 扫描算法：一直向上走，走到最大磁道号之后继续轮回，从最小磁道向上找。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1P54y1D7Jv/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;&lt;strong&gt;磁盘计算&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
存储容量 = 磁头数（盘面数）x 磁道数（柱面数）x 每道扇区数 x 每扇区字节数&lt;br&gt;
访问时间 = 寻道时间（会给） + 读取时间（用转速求）+ 传输时间 + 控制器时间（会给）&lt;/p&gt;
&lt;p&gt;磁盘计算时，1 GB = 1024 MB，1 MB = 1024 KB，1 KB = 1024 B&lt;br&gt;
G M K之间进位为 1024&lt;/p&gt;
&lt;p&gt;&lt;code&gt;例题&lt;/code&gt;&lt;br&gt;
某计算机系统采用 C-SCAN（循环扫描）磁盘调度策略，使用 2KB 的内存空间&lt;br&gt;
记录 16384 个磁盘块的空闲状态。&lt;br&gt;
设某单面磁盘旋转速度为 6000r/min，每个磁道有 100 个扇区，相邻磁道间的平均移动&lt;br&gt;
时间为 1ms。若在某时刻，磁头位于 80 号磁道处，并沿着磁道号增大的方向移动，磁道号&lt;br&gt;
请求队列为 40，90，30，110，对请求队列中的每个磁道需读取 1 个随机分布的扇区，则&lt;br&gt;
读完这 4 个扇区点共需要多少时间？要求给出计算过程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;首先，计算寻道时间。总共移动的磁道数为 110 - 80 = 30。磁盘道的移动时间为 30 * 1ms = 30ms。

然后，计算读取每个扇区的时间。单面磁盘旋转速度为 6000r/min，1min = 60,000ms，则一转的时间为 60,000ms/6000r = 10ms

每个磁道有 100 个扇区，所以每个扇区的读取时间为 10ms / 100 = 0.1ms。

最后，累加读取每个扇区的时间，共为 4 * 0.1ms = 0.4ms。加上磁道的移动时间，总共需要的时间为 0.4ms + 30ms = 30.4ms。
&lt;/code&gt;&lt;/pre&gt;
">操作系统笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/pytorch-ru-men/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/48982978&#34;&gt;Tensor--张量&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.zhihu.com/question/341328124&#34;&gt;「张量」和「多维数组」有什么区别？&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/Lucky_Ape/article/details/113944257&#34;&gt;张量、数组&lt;/a&gt;&lt;/p&gt;
">PyTorch 入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/cnn-juan-ji-shen-jing-wang-luo/"" data-c="
          &lt;p&gt;Convolutional Neural Network&lt;br&gt;
&lt;a href=&#34;https://pytorch.org/&#34;&gt;pyTorch 英文官网&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.pytorch123.com/&#34;&gt;pyTorch 教程中文&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.w3cschool.cn/pytorch/&#34;&gt;pyTorch w3cschool&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_53904578/article/details/124414068?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166971072916800184193705%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=166971072916800184193705&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124414068-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Econtrol_2,213%5Ev2%5Et3_esquery_v2&amp;amp;utm_term=%E6%95%B0%E6%8D%AE%E9%9B%86&amp;amp;spm=1018.2226.3001.4187&#34;&gt;深度学习数据集汇总&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/hotsnow/p/9734375.html&#34;&gt;常见的 CNN&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/47184529&#34;&gt;文档&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/mvtechnology/article/details/9008499&#34;&gt;图像的通道数&lt;/a&gt;&lt;br&gt;
灰度图的通道数为1，彩色图的通道为3&lt;/p&gt;
&lt;p&gt;CNN 基本结构：&lt;br&gt;
输入层&lt;br&gt;
卷积层：对特征进行提取&lt;br&gt;
池化层：对特征进行压缩&lt;br&gt;
全连接层：和传统神经网络一样，用于分类&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; CNN 的层数 = 卷积层数 + 全连接层数&lt;/p&gt;
&lt;p&gt;卷积神经网络和普通神经网络相比，&lt;br&gt;
输入 CNN 的图像为三维图像，即为长、宽、颜色通道数（R、G、B）&lt;br&gt;
CNN 相当于传统神经网络（用于分类）加上了卷积和池化层（对特征的提取和处理）&lt;br&gt;
根据特征进行分类&lt;/p&gt;
&lt;p&gt;卷积核（filter）&lt;br&gt;
包含三个参数，长、宽、通道数。其中长宽相等，通道数和输入通道数相等。&lt;/p&gt;
&lt;p&gt;卷积过程：&lt;br&gt;
划分图像的区域，用卷积核（filter）扫描区域，卷积得到特征矩阵，三个通道同时进行&lt;/p&gt;
&lt;p&gt;卷积核扫描&lt;br&gt;
卷积核与被扫描区域做内积运算，得到一个数值。三个通道相加，再加上 bias 得到最终结果。得到的结果称为特征图（feature map）&lt;/p&gt;
&lt;p&gt;多特征图&lt;br&gt;
使用不同卷积核对图片进行扫描得到不同的特征图，特征更丰富。特征图个数称为深度，作为下一层卷积的通道数。提取特征后，各种特征在原图像的位置就没那么重要了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_41088475/article/details/105766758&#34;&gt;通道数的确定&lt;/a&gt;&lt;br&gt;
第一层通道数为 RGB 三通道，后面卷积层的通道数 = 前一层特征图的总数 = 前一层卷积核个数&lt;/p&gt;
&lt;p&gt;CNN 常用参数&lt;br&gt;
输入通道数（in_channels）：输入通道数，第一层看输入图片，如果是灰度图则为1，后面的和前一层的 out_channels 一样&lt;br&gt;
输出通道数（out_channels）：代表该层用到的卷积核的个数，也代表得到的、传输给下一层的特征图的个数&lt;br&gt;
滑动窗口步长（stride）：卷积核每次移动走过的距离。一般设置为1&lt;br&gt;
卷积核尺寸：常用的为 3x3 （不能太大，特征提取不明显）&lt;br&gt;
边缘填充（pad/padding）：为了解决区域边缘被扫描的次数较少的问题，在边缘添加一圈 0 ，使得原来的边界不为边界&lt;br&gt;
注：padding = n 意思是在外围加 n 层。若原图 28 x 28，padding = 2，则一条边长度增加 4，尺寸变为 32 x 32&lt;br&gt;
卷积核个数：决定了生成的特征图的数量、下一层的通道数。每个卷积核一定不同&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/428448728&#34;&gt;ReLU 激活函数&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/77609689&#34;&gt;Dropout：每一层随机丢弃一些神经元防止过拟合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;池化层：&lt;br&gt;
对卷积得到的特征进行筛选，筛选出重要的特征。&lt;br&gt;
常用池化方法：&lt;br&gt;
Max Pooling：扫描一定区域，选择区域中的最大值（提取最有用的特征）&lt;/p&gt;
&lt;p&gt;网络结构：&lt;br&gt;
卷积（CONV）后面接着 RELU 激活函数，两层该结构，一层池化，重复累加&lt;/p&gt;
&lt;p&gt;从池化层进入全连接层前，需要先把三维的数据转化为一维的向量&lt;/p&gt;
&lt;p&gt;残差神经网络 Resnet&lt;br&gt;
随着 CNN 层数不断增加，效果不一定会越来越好，是为什么呢？因为某一层可能会效果不好，影响了总体的特征提取效果。Resnet 将其中效果不好的层的权重设置为 0 ，只保留对整体效果有益的层数，从而保证了，层数越多，深度越深，学习效果越好。不过提升程度可能很细微，但是总有提升。&lt;/p&gt;
&lt;p&gt;迁移学习&lt;/p&gt;
&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/pillow/&#34;&gt;Pillow（PIL） 库：python 图像处理库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_34714751/article/details/85610804&#34;&gt;tf 实现 CNN&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;各层输入输出计算&#34;&gt;各层输入输出计算&lt;/h1&gt;
&lt;p&gt;卷积层和池化层计算方法一样，带入公式即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 输出图片大小的计算公式为：
inputSize = 28
kernel = 2
stride = 2
padding = 0

outputSize = (inputSize - kernel + 2 * padding) / stride + 1
print(outputSize,&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全连接层计算：&lt;br&gt;
若最后一层输出为 10 x 10 x 20 ，则作为全连接层的输入为 10 x 10 x 20 = 2000&lt;/p&gt;
&lt;h1 id=&#34;批标准化-batch-normalization&#34;&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/24810318&#34;&gt;批标准化 (Batch Normalization)&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_44023658/article/details/105844861&#34;&gt;Batch Normalization（BN）超详细解析&lt;/a&gt;&lt;/p&gt;
">CNN 卷积神经网络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-mo-xing-ping-gu/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/86120987&#34;&gt;知乎总结（有错误，注意看评论）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/sinat_16388393/article/details/91427631&#34;&gt;CSDN 总结&lt;/a&gt;&lt;br&gt;
输入模型中的 x 是特征，y 是分类结果，所以模型评估输入的参数是 y_true, y_predict&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混淆矩阵&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1oz4y1R71a?spm_id_from=333.337.search-card.all.click&#34;&gt;b站讲解&lt;/a&gt;&lt;br&gt;
confusion_matix&lt;br&gt;
对于二分类问题，有 TP，TN，FP，FN 四种情况，True Positive 意思就是正确的正样本，其是被分类正确的正样本；False Positive 是错误的正样本，则该样本本身为负样本。综上，所有的正样本为 TP+FN&lt;br&gt;
对于多分类问题，扩大矩阵维度，对角线是所有预测正确的样本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;F1-score&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_43190189/article/details/105778058&#34;&gt;F1-score、Micro-F1-score、Macro-F1-score&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.kaggle.com/code/guglielmocamporese/macro-f1-score-keras&#34;&gt;使用 tf 和 Keras 计算 Macro F1-Score&lt;/a&gt;&lt;/p&gt;
">【ML】模型评估</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/le-li/"" data-c="
          &lt;h1 id=&#34;和弦&#34;&gt;和弦&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/70724252&#34;&gt;主/属和弦&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/93786223#:~:text=%E4%BB%A5%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%BD%9C%E4%B8%BA%E6%A0%B9%E9%9F%B3%EF%BC%8C%E5%BE%80%E4%B8%8A%E4%B8%89%E5%BA%A6%E5%8F%A0%E5%8A%A0%E6%9E%84%E6%88%90%E7%9A%84%EF%BC%8C%E5%92%8C%E5%BC%A6%E6%98%AF%E7%94%B1%E4%B8%8D%E5%90%8C%E9%9F%B3%E6%9E%84%E6%88%90%E7%9A%84%EF%BC%8C%E6%9C%80%E5%B0%913%E4%B8%AA%E9%9F%B3%EF%BC%8C%E6%9C%80%E5%A4%9A%E6%98%AF7%E4%B8%AA%E9%9F%B3%E3%80%82,%E6%80%BB%E5%85%B1%E6%9C%895%E7%A7%8D%E5%92%8C%E5%BC%A6%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%89%E5%92%8C%E5%BC%A6%E3%80%81%E4%B8%83%E5%92%8C%E5%BC%A6%E3%80%81%E4%B9%9D%E5%92%8C%E5%BC%A6%E3%80%81%E5%8D%81%E4%B8%80%E5%92%8C%E5%BC%A6%E3%80%81%E5%8D%81%E4%B8%89%E5%92%8C%E5%BC%A6%E3%80%82&#34;&gt;三、七和弦&lt;/a&gt;&lt;/p&gt;
">乐理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/meng-te-qia-luo-suan-fa/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/369099011&#34;&gt;蒙特卡洛方法&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode.cn/problems/contains-duplicate/comments/111007&#34;&gt;leetcode 题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;&#34;&gt;哈希表&lt;/a&gt;&lt;br&gt;
哈希函数 hash function ，hash 的英文含义是弄乱，所以哈希函数又称为散列函数&lt;br&gt;
&lt;a href=&#34;https://leetcode.cn/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/&#34;&gt;leetcode 两数之和&lt;/a&gt;&lt;br&gt;
哈希表用于以 O(n) 的时间复杂度查找数据，一般用字典可以实现。&lt;/p&gt;
">leetcode 刷题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/paypal-mian-shi/"" data-c="
          &lt;p&gt;岗位：AI Engineer&lt;br&gt;
一面&lt;br&gt;
根据项目经历问了项目内容，问了专业知识，人工智能算法，数据结构敲代码&lt;/p&gt;
&lt;p&gt;二面&lt;br&gt;
问了项目内容。人工智能的算法，数据结构敲代码&lt;/p&gt;
&lt;p&gt;三面：&lt;br&gt;
问了python的基础知识，让敲代码&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;leetcode 还是要刷，最起码把数据结构中最基本的题看会&lt;/li&gt;
&lt;li&gt;写在简历上的项目一定要熟悉，能复现项目&lt;/li&gt;
&lt;li&gt;人工智能算法一定要熟悉&lt;/li&gt;
&lt;/ol&gt;
">PayPal 面试</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/zhong-guo-dian-xin-yan-jiu-yuan-gong-zuo-ri-zhi/"" data-c="
          &lt;h1 id=&#34;2022712&#34;&gt;2022.7.12&lt;/h1&gt;
&lt;p&gt;-什么是 CV&lt;br&gt;
（Computer Vision）&lt;br&gt;
-什么是 CVPR&lt;br&gt;
IEEE Conference on Computer Vision and Pattern Recognition&lt;br&gt;
IEEE 国际计算机视觉与模式识别会议&lt;br&gt;
该会议是由IEEE举办的一年一度的计算机视觉和模式识别领域的顶级会议&lt;br&gt;
CVPR 的论文数逐年递增&lt;/p&gt;
&lt;p&gt;CVPR 网址：https://cvpr【year】.thecvf.com/&lt;br&gt;
【year】代表会议的年份&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/46426177&#34;&gt;CVPR 入门1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;历年 CVPR 的 workshop URL&lt;br&gt;
https://cvpr2017.thecvf.com/program/workshops&lt;br&gt;
https://cvpr2018.thecvf.com/program/workshops&lt;br&gt;
https://cvpr2019.thecvf.com/program/workshops&lt;br&gt;
https://cvpr2020.thecvf.com/workshops-schedule&lt;br&gt;
https://cvpr2021.thecvf.com/workshops-schedule&lt;br&gt;
https://cvpr2022.thecvf.com/workshop-schedule&lt;/p&gt;
&lt;h1 id=&#34;2022713&#34;&gt;2022.7.13&lt;/h1&gt;
&lt;p&gt;workshop：研讨会，比 conference 难度低一些&lt;br&gt;
DBLP（DataBase systems and Logic Programming）是计算机领域内对研究的成果以作者为核心的一个计算机类英文文献的集成数据库系统。&lt;/p&gt;
&lt;p&gt;其他类似的机构的 workshop&lt;/p&gt;
&lt;p&gt;&lt;code&gt;一些 AI 顶会&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AAAI&lt;/strong&gt;&lt;br&gt;
国际先进人工智能协会（Association for the Advancement of Artificial Intelligence, AAAI）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NeurIPS&lt;/strong&gt;&lt;br&gt;
神经信息处理系统大会(Conference and Workshop on Neural Information Processing Systems) 关于机器学习和计算神经科学的国际会议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACL&lt;/strong&gt;&lt;br&gt;
（The Association for Computational Linguistics）计算语言学年会，由计算语言学学会（Association of Computational Linguistics）举办；ACL 是自然语言处理领域水平最高、最权威的国际会议&lt;/p&gt;
&lt;p&gt;**ICML **&lt;br&gt;
International Conference on Machine Learning，即国际机器学习大会。ICML如今已发展为由国际机器学习学会（IMLS）主办的年度机器学习国际顶级会议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IJCAI&lt;/strong&gt;&lt;br&gt;
国际人工智能联合会议（International Joint Conference on Artificial Intelligence, 简称为IJCAI）是人工智能领域中最主要的学术会议之一&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ICCV&lt;/strong&gt;&lt;br&gt;
全称是 IEEE International Conference on Computer Vision，即国际计算机视觉大会，由IEEE主办，与计算机视觉模式识别会议（CVPR）和欧洲计算机视觉会议（ECCV）并称计算机视觉方向的三大顶级会议&lt;/p&gt;
&lt;h1 id=&#34;2022714&#34;&gt;2022.7.14&lt;/h1&gt;
&lt;p&gt;调研各个顶会网站的项目内容，统计热门技术分类，进行难易程度排序&lt;br&gt;
思路：先统计大标题，对大标题进行上述分析&lt;/p&gt;
&lt;h1 id=&#34;2022718&#34;&gt;2022.7.18&lt;/h1&gt;
&lt;p&gt;标注陌生名词，明显很复杂的/表意模糊的标完先放那，指向性明显的查出意思&lt;/p&gt;
&lt;h1 id=&#34;2022719&#34;&gt;2022.7.19&lt;/h1&gt;
&lt;p&gt;CVPR 关键词调研&lt;br&gt;
多模态学习是多个模态融合学习&lt;br&gt;
细粒度图像分类：&lt;br&gt;
在区分出基本类别的基础上，进行更精细的子类划分，如区分鸟的种类、车的款式、狗的品种等&lt;br&gt;
长视频理解：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/158702087&#34;&gt;识别视频内容&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/127194745&#34;&gt;神经架构搜索 NAS&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/248351130&#34;&gt;合成数据&lt;/a&gt;：人工合成数据用于机器学习&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/huxi2b/p/12989317.html#:~:text=4%E7%A7%8D%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%BE%E5%83%8F%2F%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%201%20%E5%9F%BA%E4%BA%8E%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%202%20DeepCoder,--%20%E5%9F%BA%E4%BA%8E%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203%20%E5%9F%BA%E4%BA%8ECNN%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%204%20%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%EF%BC%88GAN%EF%BC%89%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95&#34;&gt;图像压缩算法&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/300595016&#34;&gt;情感分析&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_37555071/article/details/108357663&#34;&gt;细粒度视觉&lt;/a&gt; &lt;a href=&#34;https://blog.csdn.net/wills798/article/details/88974715&#34;&gt;参考代码&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;2022720&#34;&gt;2022.7.20&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;王老师给定方向：&lt;/strong&gt;&lt;br&gt;
入门课题1：&lt;br&gt;
细粒度分类&lt;/p&gt;
&lt;p&gt;入门课题2：&lt;br&gt;
常规的检测识别姿态人脸&lt;br&gt;
GAN 生成对抗网络&lt;/p&gt;
&lt;p&gt;入门课题3：&lt;br&gt;
高级应用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细粒度分类&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/499273744&#34;&gt;细粒度图像分类模型加实战代码&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/algorithmPro/article/details/113488199&#34;&gt;深度学习: 细粒度图像分类&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/m0_37192554/article/details/103733046&#34;&gt;细粒度分类，比赛，和相关模型介绍&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://cloud.tencent.com/developer/article/1931620&#34;&gt;基于Pytorch细粒度分类实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;精细化分类&lt;br&gt;
识别出物体的大类别（比如：计算机、手机、水杯等）较易，但如果进一步去判断更为精细化的物体分类名称，则难度极大。最大的挑战在于，同一大类别下 不同 子类别 间的 视觉差异 极小。因此，精细化分类 所需的图像分辨率 较高。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;一般步骤：&lt;/code&gt;&lt;br&gt;
首先找到前景对象(鸟)及其局部区域(头、脚、翅膀等), 之后分别对这些区&lt;br&gt;
域提取特征. 对所得到的特征进行适当的处理之后, 用来完成分类器的训练&lt;br&gt;
和预测&lt;/p&gt;
&lt;p&gt;&lt;code&gt;细粒度图像分类模型分类:&lt;/code&gt;&lt;br&gt;
(1)强监督模型: 需要类别以外的标签进行监督&lt;br&gt;
Part-based R-CNN 区域卷积神经网络&lt;br&gt;
Pose-normalized CNN&lt;br&gt;
Multi-proposal Net MT-CNN&lt;br&gt;
(2)弱监督模型: 不需要类别以外的标签&lt;br&gt;
图像过滤&lt;br&gt;
Multi-Attention MA-CNN&lt;br&gt;
双线性卷积神经网络结构(Bilinear CNN)&lt;/p&gt;
&lt;h1 id=&#34;2022721&#34;&gt;2022.7.21&lt;/h1&gt;
&lt;p&gt;调研细粒度视觉获奖代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/moxibingdao/article/details/106700835?spm=1001.2101.3001.6650.6&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6-106700835-blog-103733046.pc_relevant_default&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6-106700835-blog-103733046.pc_relevant_default&amp;amp;utm_relevant_index=11&#34;&gt;CVPR 2020 细粒度分类挑战赛冠军方案：数据增强+知识蒸馏，效果大幅提升&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/zsx1713366249/article/details/92370490&#34;&gt;2019CVPR细粒度论文笔记《Destruction and Construction Learning for Fine-grained Image Recognition》&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;2022722&#34;&gt;2022.7.22&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;AAAI 关键词调研&lt;/strong&gt;&lt;br&gt;
强化学习：&lt;br&gt;
试错，用错误调整参数。环境会返回给系统一个正确/错误的信号，用于调整参数&lt;/p&gt;
&lt;p&gt;进化神经网络（evolutionary neural networks,ENN）&lt;br&gt;
是基于 进化 计算和神经网络两大智能分支，将二者有机融合在一起产生的一种全新 神经网络模型&lt;/p&gt;
&lt;p&gt;细粒度图像分类：&lt;br&gt;
在区分出基本类别的基础上，进行更精细的子类划分，如区分鸟的种类、车的款式、狗的品种等&lt;/p&gt;
&lt;p&gt;分类置信度：&lt;br&gt;
分类置信度confidence是介于0和1 (或100%)之间的数字，它描述模型认为此预测边界框包含某类别目标的概率&lt;/p&gt;
&lt;p&gt;集成学习 Ensemble Learning：&lt;br&gt;
组合这里的多个弱监督模型以期得到一个更好更全面的强监督模型，集成学习潜在的思想是即便某一个弱分类器得到了错误的预测，其他的弱分类器也可以将错误纠正回来&lt;/p&gt;
&lt;h1 id=&#34;2022725&#34;&gt;2022.7.25&lt;/h1&gt;
&lt;p&gt;ACL 关键词调研 和 NeurlPS 关键词调研&lt;br&gt;
细粒度文本分类&lt;/p&gt;
&lt;p&gt;合成泛化：&lt;br&gt;
在机器学习的背景下，合成泛化（compositional generalization）是指机器学习从一组训练示例学习上下文表示。&lt;/p&gt;
&lt;h1 id=&#34;2022726&#34;&gt;2022.7.26&lt;/h1&gt;
&lt;p&gt;ICML 顶会的关键词调研&lt;/p&gt;
&lt;p&gt;我的选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CNN&lt;/li&gt;
&lt;li&gt;强化学习&lt;/li&gt;
&lt;li&gt;NLP 文本情感分析&lt;/li&gt;
&lt;li&gt;细粒度分类&lt;/li&gt;
&lt;li&gt;AI 安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2022 - Snack 物种识别论文方法阅读&lt;/p&gt;
&lt;p&gt;第一名使用方法解读：&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/471531558#:~:text=Visual%20Attention,Network%20%28VAN%29%20VAN%E6%9C%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8D%B3%E4%B8%80%E4%B8%AA%E5%9B%9B%E7%BA%A7%E5%BA%8F%E5%88%97%EF%BC%8C%E8%BE%93%E5%87%BA%E7%A9%BA%E9%97%B4%E5%88%86%E8%BE%A8%E7%8E%87%E9%80%90%E6%B8%90%E9%99%8D%E4%BD%8E%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AFh4%C3%97w4%E3%80%81h8%C3%97w8%E3%80%81h16%C3%97w16%E5%92%8Ch32%C3%97w32%E3%80%82&#34;&gt;VAN (Visual Attention Network) 视觉注意力网络&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/463033740&#34;&gt;CoAtNet 结合卷积和注意力&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/116466239&#34;&gt;label smoothing 标签平滑 1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/477813062&#34;&gt;label smoothing 标签平滑 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二名使用方法解读：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/baidu_36913330/article/details/120198840&#34;&gt;Vision Transformer(ViT)&lt;/a&gt;&lt;/p&gt;
">中国电信研究院工作日志</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shu-ju-fen-xi-de-yi-ban-guo-cheng/"" data-c="
          &lt;h1 id=&#34;读取数据&#34;&gt;读取数据&lt;/h1&gt;
&lt;h1 id=&#34;数据预处理&#34;&gt;数据预处理&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/137175585&#34;&gt;缺失值处理1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/AvenueCyy/article/details/104354132&#34;&gt;缺失值处理2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_42389265/article/details/107013720&#34;&gt;pandas 统计某一列中各个值的出现次数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yyhhlancelot/article/details/82256488&#34;&gt;Pandas 关于pandas.DataFrame.fillna 填充Nan失败的问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;特征工程&lt;br&gt;
可视化考察数据之间的关系，以及数据和结果的关系&lt;br&gt;
如何选择考察的数据？需要通过自己的想象和亲自动手测试&lt;/p&gt;
&lt;h1 id=&#34;归一化&#34;&gt;归一化&lt;/h1&gt;
&lt;h1 id=&#34;划分数据集&#34;&gt;划分数据集&lt;/h1&gt;
&lt;p&gt;交叉验证&lt;/p&gt;
">数据分析的一般过程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-gan-zhi-ji-perceptron/"" data-c="
          &lt;p&gt;多层感知机（MLP：Multi-Layer Perceptron）也叫人工神经网络（ANN：Artificial Neural Network）&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_43704393/article/details/86700712&#34;&gt;感知机与多层感知机&lt;/a&gt;&lt;/p&gt;
">【ML】感知机 Perceptron</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/kaggle-chu-tan/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/27424282&#34;&gt;入门好文：分分钟带你杀入Kaggle Top 1%&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.kaggle.com/code/startupsci/titanic-data-science-solutions/notebook&#34;&gt;大神项目&lt;/a&gt;&lt;br&gt;
&lt;code&gt;项目目的：&lt;/code&gt;&lt;br&gt;
以乘客的不同特征作为输入，输出乘客是生存还是死亡&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sklearn 版本&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;读取数据&#34;&gt;读取数据&lt;/h1&gt;
&lt;h1 id=&#34;数据预处理&#34;&gt;数据预处理&lt;/h1&gt;
&lt;p&gt;缺失值填充&lt;/p&gt;
&lt;h1 id=&#34;划分数据集&#34;&gt;划分数据集&lt;/h1&gt;
&lt;p&gt;用 train 数据集交叉验证&lt;/p&gt;
">【Kaggle】Titanic - MLP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/she-ying-ru-men/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26309412&#34;&gt;曝光三要素&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;曝光三要素的调节：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中心思想&lt;/code&gt;&lt;br&gt;
快门速度保证画面不模糊的情况下，ISO 尽量低，高 ISO 会降低画质&lt;br&gt;
每次调节从低感光度起调&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if 需要景深&lt;/code&gt;&lt;br&gt;
大光圈优先&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if 需要整体清晰（如集体合照&lt;/code&gt;&lt;br&gt;
小光圈优先，然后调节快门速度确定合适的曝光&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if 运动物体&lt;/code&gt;&lt;br&gt;
优先调节快门，保证画面清晰&lt;br&gt;
调节 ISO 确保画质&lt;br&gt;
最后调节光圈达到正确曝光&lt;/p&gt;
&lt;h1 id=&#34;调色思路&#34;&gt;调色思路&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;人文&lt;/code&gt;&lt;br&gt;
青橙、蓝绿&lt;/p&gt;
">摄影入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ji-wang-qi-mo-fu-xi/"" data-c="
          &lt;p&gt;本笔记对应教材为《计算机网络自顶向下方法》&lt;/p&gt;
&lt;h1 id=&#34;第一章-概述&#34;&gt;第一章 概述&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;计算机网络协议分层&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;OSI 七层模型&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;应用层&lt;/strong&gt;  指网络操作系统和具体的应用程序，对应WWW服务器、FTP服务器等应用软件&lt;br&gt;
&lt;strong&gt;表示层&lt;/strong&gt;  数据语法的转换、数据的传送等&lt;br&gt;
&lt;strong&gt;会话层&lt;/strong&gt;  建立起两端之间的会话关系，并负责数据的传送&lt;br&gt;
&lt;strong&gt;传输层&lt;/strong&gt;  负责错误的检查与修复，以确保传送的质量，是TCP工作的地方。（报文）&lt;br&gt;
&lt;strong&gt;网络层&lt;/strong&gt;  提供了编址方案,IP协议工作的地方(数据包）&lt;br&gt;
&lt;strong&gt;数据链路层&lt;/strong&gt;  将由物理层传来的未经处理的位数据包装成数据帧&lt;br&gt;
&lt;strong&gt;物理层&lt;/strong&gt;  对应网线、网卡、接口等物理设备(位)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机网络服务模型&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;TCP/IP 五层模型&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;应用层&lt;/strong&gt;  通过应用进程间交互完成特定的互联网应用，定义应用进程之间通信和交互的规则&lt;br&gt;
&lt;strong&gt;传输层&lt;/strong&gt;  进程之间通信的通用数据传输服务&lt;br&gt;
&lt;strong&gt;网络层&lt;/strong&gt;  网络中不同主机提供通信服务&lt;br&gt;
&lt;strong&gt;数据链路层&lt;/strong&gt;  两个相邻网络结点之间传送数据&lt;br&gt;
&lt;strong&gt;物理层&lt;/strong&gt;  如何在传输媒介中传输比特流&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分层优缺点：&lt;/strong&gt; 分层提供了 一种结构化方式来讨论系统组件。模块化使更新系统组件更为容易。分层的一个潜在缺点 是一层可能冗余较低层的功能。第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的 信息（如时间戳值），这违反了层次分离的目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电路交换和分组交换的优缺点&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;电路交换&lt;/code&gt;&lt;br&gt;
优点：数据直接传送 ，时延小；保证数据有序性；稳定带宽、专用信道、一致的数据速率。&lt;br&gt;
缺点：线路利用率低、不便于进行差错控制；建立物理链路需要时间、资金成本&lt;br&gt;
&lt;code&gt;分组交换&lt;/code&gt;&lt;br&gt;
优点：链接中的故障不会停止数据的传递；带宽利用率高；更简单、有效、成本更低&lt;br&gt;
缺点：通信有延迟；会导致信息丢失；分组需要提供额外信息增加开销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机网络性能指标&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/599c11874f24&#34;&gt;公式总结&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;传输时延、发送时延、处理时延：&lt;/strong&gt; 均指在发送端将比特流打包成分组的时间。&lt;br&gt;
发送时延 = 数据帧长度 / 发送速率（信道带宽）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传播时延：&lt;/strong&gt; 从发送端到接收端过程中消耗的时间&lt;br&gt;
传播时延 = 信道长度 / 电磁波传播速度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用率：&lt;/strong&gt;  D：网络当前时延 D0：网络空闲的时延 U：信道利用率&lt;br&gt;
当前信道利用率：D = D0 / （1 - U）  可见，信道利用率越大，时延越大（包多时延大）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时延带宽积：&lt;/strong&gt; 传播时延 x 带宽&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;吞吐量：&lt;/strong&gt; 单位时间内通过某个网络的实际的数据量&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第二章-应用层&#34;&gt;第二章 应用层&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;P2P 和 C/S 优缺点&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;客户-服务器&lt;/code&gt;&lt;br&gt;
优点：客户、服务器分离，允许网络分布操作；一个服务器可以服务于多个客户端；&lt;br&gt;
缺点：客户机会比较依赖于服务器工作。&lt;br&gt;
&lt;code&gt;P2P&lt;/code&gt;&lt;br&gt;
优点：可扩展性强，传播速度优化；&lt;br&gt;
缺点：用户直连，没有确保安全性，管理困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P2P 和 C/S 模式计算题&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;题目1&lt;/code&gt;&lt;br&gt;
&lt;em&gt;考虑向N个对等方发F=15Gb的一个文件。该服务器具有us=30Mbps的上载速率，每个对等方具有di=1Mbps的下载速率和上载速率u。对于N=10、100和1000并且u=300kps、700kps和2Mbps，对于N和u的每种组合绘制出确定最小分发时间的图表。需要分别针对客户-服务器分发和P2P分发两种情况制作。&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;在计算C-S分发的最小分发时间时，我们使用以下公式：
Dcs=max{NF/us,F/di}  服务器分发前需要先将数据上载，取服务器上载和各链路下载速率的最大值
其中F=15Gb=15*1000Mb
us=30Mbps，dmin=di=1Mbps
注意，300 Kbps=300/1000 Mbps
在计算P2P分发的最小分发时间时，我们使用以下公式：
Dp2p=max{F/us,F/di,NF/(us+∑ui)}
其中F=15Gb=15*1000Mb
us=30Mbps，di=di=1Mbps
注意，300 Kbps=300/1000 Mbps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DNS 域名系统&lt;/strong&gt;&lt;br&gt;
DNS 采用 客户/服务器 模型，运行在 UDP 之上，使用 53 号端口。缓存就是对重复的访问，省去一些重复的解析，节省时间。&lt;br&gt;
&lt;code&gt;域名解析过程&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655655184489.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655656720717.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超文本传输协议 HTTP&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 使用 TCP 连接进行可靠传输，端口号 80，定义了在浏览器和服务器之间的请求和响应的格式。&lt;/li&gt;
&lt;li&gt;HTTP 本身是无连接的，通信双方交换 HTTP 报文前不需要先建立连接&lt;/li&gt;
&lt;li&gt;HTTP 是无记忆的，每次访问都一样，各自独立&lt;/li&gt;
&lt;li&gt;使用 Cookie 保存用户活动数据库，Cookie 是服务器产生的、储存在用户主机中的文本文件&lt;/li&gt;
&lt;li&gt;HTTP 既可以建立持久连接（只需建立一次 TCP 连接，然后传输 HTML 文件，之后可一直传输文件），也可以建立非持久连接（先建立一个 TCP 连接传输 HTML 文件，之后每次传输数据还都需要重新建立 TCP 连接）&lt;/li&gt;
&lt;li&gt;HTTP 响应报文和请求报文开始行不同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;输入 URL 后发生的事情：&lt;/code&gt;&lt;br&gt;
DNS 域名系统解析出 URL 对应的 IP 地址&lt;br&gt;
浏览器与该 IP 对应的服务器建立 TCP 连接&lt;br&gt;
浏览器发出 HTTP 请求&lt;br&gt;
服务器通过 HTTP 响应把文件 index.htm 发送给浏览器&lt;br&gt;
释放 TCP 连接&lt;br&gt;
浏览器解释文件 index.htm ，并将 Web 页展示给用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二章综合例题&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;例1 —— 协议使用&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655646282813.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655646288287.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;例2 —— HTTP 连接计算&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655647446351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655647521822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655647526867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;em&gt;本题注意：&lt;/em&gt; 无论是持久还是非持久，都需要先建立一个 TCP 连接，然后传送一个 HTML 网页文件，然后再进行后续操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;例3 —— HTTP 连接计算&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655654243905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655654248482.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
考虑单个主机：&lt;br&gt;
非持久并行：&lt;br&gt;
(150/150 + 150/150 + 150/150 + 100000/150) +（150/(150/8) + 150/(150/8) + 150/(150/8) + 200000/(150/8) ）=11360&lt;br&gt;
持久并行：&lt;br&gt;
(150/150+ 150/150 + 150/150+ 100000/150) +  (150/(150/8) + 200000/(150/8))=11344&lt;br&gt;
持续连接HTTP相比非持续并没有显著增益&lt;br&gt;
&lt;em&gt;本题注意：&lt;/em&gt; 题干说的包含数据的 100,000b 的分组是 HTML 网页文件，而且仔细审题，后面说仅包含控制的分组为 150b ，说明 100,000b 中已经含有控制比特。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;常见的应用层协议和对应使用的运输层协议&lt;/code&gt;&lt;br&gt;
TCP:HTTP FTP SMTP POP3&lt;br&gt;
UDP:SNMP DHCP NTP TFTP&lt;/p&gt;
&lt;h1 id=&#34;第三章-传输层-运输层&#34;&gt;第三章 传输层 / 运输层&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;可靠性 RDT&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;拥塞控制&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655464901846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在恢复部分：Tahoe：还用慢开始算法，从 1 开始；Reno：快恢复算法，从一半开始&lt;/p&gt;
&lt;h1 id=&#34;第四章-网络层&#34;&gt;第四章 网络层&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;网络层的功能&lt;/strong&gt;&lt;br&gt;
路由选择与分组转发、异构网络互联、拥塞控制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP 地址 &amp;amp; 子网掩码&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/fzlsss/p/9678954.html&#34;&gt;网络号，主机号，主机地址，网络地址，主机地址，子网号，子网地址 概念辨析&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1eV411J7Hv?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;子网掩码B站&lt;/a&gt;&lt;br&gt;
IP 地址的主机号全为 0 表示网络号，全为 1 表示广播号&lt;br&gt;
IP 地址和子网掩码都是一串 32 位的二进制数，二者一一对应。子网掩码为 1 的位对应 IP 地址中的网络号，为 0 的位对应 IP 地址中的主机号。注意，子网掩码肯定是由连续的 1 和连续的 0 组成的，因为网络号和主机号不能交叉。IP 和 子网掩码相与得到该网络的网络号（标识该网络的地址）&lt;br&gt;
CIDR记法：在 IP 后面加一个斜杠和一个数字，表示网络号位数是多少，如 172.16.0.0/16 表示有 16 位网络号，前 16 位称为网络前缀&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/85960091&#34;&gt;总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子网划分&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1a84y1F72Z/?spm_id_from=333.788.recommend_more_video.-1&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;B站讲解&lt;/a&gt;&lt;br&gt;
假如某网络只需要 100 台主机，而主机号可以表示 200 台主机。我们不想对该 IP 进行浪费，将主机号再次进行划分，使用主机字节的前几位标记划分子网的网络号，其余位数用于表示主机地址。&lt;br&gt;
&lt;code&gt;例&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655460590774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655460595483.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; 主机号全 0 表示网络号，全为 1 表示广播号，这两个不能算在主机地址中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络地址转换-NAT&lt;/strong&gt;&lt;br&gt;
将局域网（LAN）址转换为公网（WAN）地址，对外隐藏局域网内部 IP 地址，使得整个局域网只需要一个全球的 IP 即可访问因特网&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/mlgjb/p/8087612.html#:~:text=WLAN%EF%BC%8C%E5%85%A8%E7%A7%B0Wireless%20LAN%2C%20%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E3%80%82%20%E5%92%8CLAN%E4%B8%8D%E5%90%8C%EF%BC%8CWLAN%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%BF%87%E7%94%B5%E7%A3%81%E6%B3%A2%E4%BC%A0%E8%BE%93%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%B8%B8%E8%AF%B4%E7%9A%84%E7%A9%BA%E6%B0%94%E4%BC%A0%E8%BE%93%E3%80%82%20WLAN,%E5%88%A9%E7%94%A8%E7%94%B5%E7%A3%81%E6%B3%A2%E5%9C%A8%E7%A9%BA%E6%B0%94%E4%B8%AD%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E6%97%A0%E9%9C%80%E7%BA%BF%E7%BC%86%E4%BB%8B%E8%B4%A8%E3%80%82%20WLAN%20%E4%BD%BF%E7%94%A8%20ISM%20%28Industrial%E3%80%81Scientific%E3%80%81Medical%29%20%E6%97%A0%E7%BA%BF%E7%94%B5%E5%B9%BF%E6%92%AD%E9%A2%91%E6%AE%B5%E9%80%9A%E4%BF%A1%E3%80%82&#34;&gt;词条辨析：LAN、WAN、WLAN、WIFI&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/434689354&#34;&gt;词条辨析：网关和路由&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ARP 协议&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://kaoyan.koolearn.com/20211028/1468028.html&#34;&gt;同一局域网内，将 IP 地址映射为 MAC 地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DHCP 协议&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/Gherbirthday0916/article/details/125154347&#34;&gt;当一台新主机加入网络时，DHCP 给该主机分配 IP 地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ICMP 协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;距离向量路由算法 - RIP 协议&lt;/strong&gt;&lt;br&gt;
在网络中加入新的路由器时，用于对路由器下一条的更新，更新当前路由表。原则上满足到达下一网络的距离尽量短，距离相同时尽量不改动，同一下一跳改动则必改动的原则。&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1BJ41157rM/?spm_id_from=333.788.recommend_more_video.0&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;B站原理+题目讲解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1C4411375y?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;B站做题步骤讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最长前缀路由选择&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1jk4y127Cu?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33&#34;&gt;b站讲解&lt;/a&gt;&lt;br&gt;
原理：哪条 IP 的匹配度最高选择哪个&lt;br&gt;
&lt;code&gt;例&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655458936247.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;步骤&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把目的 IP 化为二进制&lt;/li&gt;
&lt;li&gt;求得路由表中每一条 IP 路径的网络号&lt;/li&gt;
&lt;li&gt;逐一与目的 IP 对比，符合度最高的为正确路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;例&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655458832077.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655458838336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655458843286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;第五章-数据链路层&#34;&gt;第五章 数据链路层&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;DV算法&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Dijkstra算法&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;画出表格，左边是已经确定的点，右边每个格包含两个数据，第一个是起始点到该点的距离，第二个是该点前一个点是什么&lt;/li&gt;
&lt;li&gt;从第一个点 V1 出发，每次找和当前点相邻点的距离，将最短路径保存在各个点中&lt;/li&gt;
&lt;li&gt;找到该行距离数最小的点，保存在左侧确定点部分&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655617989211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;LS算法&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Bellman-Ford算法&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第六章-链路层和局域网&#34;&gt;第六章 链路层和局域网&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;随机接入协议&lt;/strong&gt;&lt;br&gt;
用户可以根据自己的意愿随机发送信息，可以占用信道全部速率，但有两个或多个用户同时发送信息时，就会产生碰撞，导致双方均发送失败。为解决随机接入发生的碰撞，用户需要按照几种协议反复重传帧，直到无碰撞通过。&lt;br&gt;
&lt;code&gt;纯 ALOHA 协议&lt;/code&gt;&lt;br&gt;
用户可以不进行检测的发数据，若一段时间按内未收到确认，则认为发生了碰撞。发送站点需等待一段时间后再次发送数据，直至发送成功。纯 ALOHA 网络吞吐量低，改进后变为 时隙 ALOHA&lt;br&gt;
&lt;code&gt;时隙 ALOHA 协议&lt;/code&gt;&lt;br&gt;
把所有各站时间同步，划分一段段等长时隙，只能在每个时隙开始才能发送帧&lt;br&gt;
&lt;code&gt;CSMA 协议&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655716220522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;CSMA/CD 协议&lt;/code&gt;&lt;br&gt;
先听后发，边听边发，一旦碰撞，停止发送。只能检测碰撞，不能避免。用于总线型网络，通过检测电缆中电压变化实现。&lt;br&gt;
&lt;code&gt;CSMA/CA 协议&lt;/code&gt;&lt;br&gt;
发送数据时先广播告知其他节点，让其他节点某段时间内不要发送数据，以免碰撞。用于无线网络，通过检测电磁波能量强弱实现。&lt;br&gt;
&lt;code&gt;总结&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655717426387.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAC地址， hop-by-hop&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;第七章-无线网络和移动网络&#34;&gt;第七章 无线网络和移动网络&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;无线 vs 有线&lt;/strong&gt;&lt;br&gt;
协议设计&lt;/p&gt;
&lt;p&gt;区别：有线与无线的区别在于数据传输的方式、标准；在没有干扰的前提下，有线与无线传输速度没有区别。&lt;br&gt;
特点：&lt;br&gt;
1、有线：需要设备之间使用网线连接，这样限制了设备之间的距离。&lt;br&gt;
2、无线：通过无线协议实现数据传输或者网络连接，一般室内50m范围内可以全方位传输数据。不过无线容易被电磁波干扰，而且墙壁对信号削弱也比较大。递减的信号强度、来自其他源的干扰、多路径传播&lt;/p&gt;
&lt;h1 id=&#34;第八章-计算机网络中的安全&#34;&gt;第八章 计算机网络中的安全&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;对称加密 vs. 非对称加密&lt;/strong&gt;&lt;br&gt;
对称 和 非对称指的就是 加密 和 解密 用的 秘钥 是不是同一个。对称：同一个，非对称：不同&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV134411r7Kt?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=**3d9ada7d42c971c0c3f04a22270daf33**&#34;&gt;B站讲解&lt;/a&gt;&lt;br&gt;
&lt;code&gt;对称加密&lt;/code&gt;&lt;br&gt;
一把钥匙一把锁头&lt;br&gt;
加密过程：A 用锁头锁住文件后，把钥匙和密码都发给 B&lt;/p&gt;
&lt;p&gt;&lt;code&gt;非对称加密&lt;/code&gt;&lt;br&gt;
把自己的锁头公开，所有人都可以用你的锁来加密，但只有你自己才有钥匙&lt;br&gt;
加密过程：A 把自己的锁头给 B ，B 用 A 的锁头锁住文件后，再发给 A&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/75a5822d0eec&#34;&gt;traceroute：路由器追踪&lt;/a&gt;&lt;/p&gt;
">【计网】期末复习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/lesslessxing-shi-yu-yan-yu-zi-dong-ji-greatergreater-bi-ji/"" data-c="
          &lt;h1 id=&#34;绪论&#34;&gt;绪论&lt;/h1&gt;
&lt;p&gt;∑（西格玛）表示字母表，字母表中的元素称为该字母表的一个字母&lt;/p&gt;
&lt;p&gt;ɛ 为空串，长度为 0，就是什么都没有。0 次幂代表空串&lt;/p&gt;
&lt;p&gt;字母表的n次幂，得到的集合，其中的元素为字母表中字母构成的句子&lt;br&gt;
字母表的闭包（字母表中所有字母的排列组合）&lt;br&gt;
字母表的正闭包（+）加上字母表的零次幂（空串）为字母表的克林闭包（*）&lt;br&gt;
注意，字母表的闭包是把字母表的 n 次幂并在一起，是各个次幂运算结果之和&lt;/p&gt;
&lt;p&gt;字母表 ∑ 上 的语言 L，是 ∑* 的一个子集 （语言 L 是集合，满足集合运算）&lt;br&gt;
L表示字母表 ∑ 上的一个语言（语言 L 就是所有句子的集合，证明语言相等，则证明集合相等），x 表示语言 L 中的一个句子，abcd表示单个字符&lt;br&gt;
其关系为：a ∈ x ∈ L ⊆ ∑*&lt;/p&gt;
&lt;h1 id=&#34;文法&#34;&gt;文法&lt;/h1&gt;
&lt;p&gt;V ：变量，可以被其他串替换，用大写 ABC 表示&lt;br&gt;
T ：终极符，这个语言里边最终的句子，都是由终极符构成的串（必定含有终极符），用小写 abc 表示&lt;br&gt;
P : 产生式，又叫语法规则、定义式，可以理解为一个语言的语法，字母必须要这么组合，才是该语言。A→B 读作 ：A 可以定义为 / 可以为 B 。 产生式可以是终极符和非终极符构成的串，但是不能仅仅是终极符构成的串&lt;br&gt;
S ：开始符，即，所有推导要从该符号开始。从该符号推导出来的才是里面的句子。开始符必须是变量之一，因为只有在变量集合中才能作为产生式的左部&lt;/p&gt;
&lt;p&gt;若产生式最终只含终极符，那么推导结束&lt;/p&gt;
&lt;p&gt;推导：利用产生式推出新表达式，归约和其相反&lt;/p&gt;
&lt;p&gt;G 表示文法  L(G) 表示由文法 G 定义的语言，也就是符合文法 G 的句子集合&lt;br&gt;
G1 G2为两个文法 ，L(G1) = L(G2) 则，G1 G2等价，也就是句子集合相同&lt;/p&gt;
&lt;p&gt;简化文法：只列出该文法的所有产生式，如：S→A|B|AA|BB，A→0，B→1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乔姆斯基文法体系&lt;/strong&gt;&lt;br&gt;
0型文法：最常规的文法&lt;br&gt;
1型文法（上下文有关文法CSG），只需满足右边比左边长，（左边可以有终极符，可以任意长度）&lt;br&gt;
2型文法（上下文无关文法CFG）：在1型文法（上下文有关文法）前提下，必须满足左边是一个变量（只能有一个变量，长度为1，不能是终极符）&lt;br&gt;
3型文法（正则文法RG）在2型文法的基础上，右侧为终极符串 + 一个串（注意只能有一个变量，可为空串）形如：A→w，A→wB&lt;/p&gt;
&lt;p&gt;对应语言分别是 0，1，2，3型语言，缩写分别为：CSL,CFL,RL&lt;br&gt;
正则语言 RL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性文法&lt;/strong&gt;&lt;br&gt;
线性文法：在正则文法基础上，增加了新产生式形式：终极符串 + 一个串 + 终极符串 （注意，还是只能有一个变量）形如：A→w，A→wBx&lt;/p&gt;
&lt;p&gt;变量代表的串在哪一侧就是哪种线性文法&lt;br&gt;
右线性文法就是正则文法&lt;br&gt;
左线性文法：形如：A→w，A→Bw&lt;br&gt;
同一个语言用左右线性文法都可以构造，故，左线性文法与右线性文法等价&lt;/p&gt;
&lt;p&gt;注：左线性文法 与 右线性文法 混用不是 正则文法&lt;br&gt;
空语句不会改变语言类型&lt;/p&gt;
&lt;h1 id=&#34;有穷状态自动机&#34;&gt;有穷状态自动机&lt;/h1&gt;
&lt;p&gt;有穷状态自动机（finite automata，简称 FA）：识别正则语言，FA是正则语言的识别器&lt;br&gt;
扩展状态转移函数：Q x *∑→ Q ：一个状态读入一个字符串，变成另一个状态，*∑代表字符串&lt;/p&gt;
&lt;p&gt;确定的有穷状态自动机（deterministic finite automata，简称 DFA）一个输入只有一个结果&lt;br&gt;
构造 DFA 步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义 DFA 状态，每一步都干啥&lt;/li&gt;
&lt;li&gt;定义转移函数，每个状态输入值后到达的新状态&lt;/li&gt;
&lt;li&gt;画图，完成构造&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4001/post-images/1655293535417.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于上面图片最下面这几行，意思是&lt;br&gt;
q0x1 是即时描述的初始状态，x1q0是即时描述的终止状态，对于下面几行都一样，左边通过至少一步变为右边的终止状态，最后一个q是终止状态的符号&lt;/p&gt;
&lt;p&gt;不确定的有穷状态自动机（Nondeterministic finite automata，简称 NFA）&lt;br&gt;
输入一个字符可以转移到多个状态（多个状态是同时进行的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFA → DFA&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655294134548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; q3 在 NFA 中为终止状态，在新的 DFA 中含有 q3 的状态也为终止状态。同样 q0 还为起始状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ɛ-NFA → NFA&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655380631215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655294724853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655380638255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;步骤&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把 ɛ-NFA 表格列出来，准备构造 NFA 的表格。&lt;/li&gt;
&lt;li&gt;画图构造 ɛ-闭包&lt;/li&gt;
&lt;li&gt;当输入一个数时，把该闭包中所有能接收该数的状态的 ɛ-闭包 并集&lt;/li&gt;
&lt;li&gt;q0，q1，q2 还是原来的 q0，q1，q2 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;构造与 DFA 等价的正则文法 RG&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655295192637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; 当某一状态 qi 是终止状态时（状态转移图表现为两个套在一起的圆），如 q0 →（0） q1，那么产生式不仅需要 q0 → 0q1，还需要 q0 → 0，因为0可能为该语的最后一位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造与正则文法 RG 等价的 DFA&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655379303621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; 需要单独设置一个终止状态 Z 来接受只含终极符的转移。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左线性文法 → FA （反过来）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655295333056.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; 和正则文法完全相反，可以先按 RG → DFA 构造一遍，然后箭头全部倒置，S 的位置变为 双圆环，Z 的位置变为单元环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FA → 左线性文法&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655382154334.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;步骤&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 FA 先把 RG 构造出来。&lt;/li&gt;
&lt;li&gt;把单独的终极符加上一个终止状态 Z 变成 2Z。&lt;/li&gt;
&lt;li&gt;全体调转，例如 q2 → 2q3 变为  q3 → q2 2&lt;/li&gt;
&lt;li&gt;删除所有起始状态 q0 ，如 q1 → q0 0 变为  q1 → 0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;起始状态前必须加 S→&lt;/li&gt;
&lt;li&gt;若某一状态 qi 只有指入的箭头没有指出的箭头，则盖状态为陷阱状态，可以删除不考虑。&lt;/li&gt;
&lt;li&gt;当自动机以正闭包（+）呈现时必须以空串ɛ开始，以克林闭包（*）呈现时不用。因为一个自动机必须以空串开始，而正闭包中不含空串。&lt;/li&gt;
&lt;li&gt;当由 RG → FA 时，需要自己设置一个终止状态Z，用于接收A→1 | 1C 这样的产生式；相反的，左线性文法构造FA时，需要自己设置一个开始状态Z，同样，产生式箭头也和RG相反，例如，A→1 | C1 , 意思时，由开始状态Z读入1跳转到状态A，由状态C读入一个1跳转到状态A。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h1&gt;
&lt;p&gt;正则表达式（regular expression，RE）&lt;br&gt;
形式定义：&lt;br&gt;
前三条都是定义基本字符串，Ø 为空集，ɛ 为空字符串，a 为任意字符。&lt;br&gt;
第四条说的是前三条的元素根据第四条的运算可以形成正则表达式。&lt;br&gt;
第一种运算 (r+s) 是集合的并集。&lt;br&gt;
第二种运算 (rs) 是指 r 和 s 串的连接&lt;br&gt;
第三种是克林闭包，(r*) = ( r0+r1+r2+….. )&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; 正则表达式必须加括号&lt;br&gt;
正则表达式RE r ，记作L(r)，也是一种语言，是一个集合，也可直接记作r&lt;/p&gt;
&lt;p&gt;注：Ø的零次幂是 ɛ&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RE → FA&lt;/strong&gt;&lt;br&gt;
记住下面几个基本元素，拼接即可&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655391708163.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正则语言 RL / DFA → RE&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先增加两个状态，一个起始状态 X 一个终止状态 Y ，为了终止状态唯一&lt;/li&gt;
&lt;li&gt;选取一个状态分析（最好是终止状态前一个状态，因为好分析），找出该状态的出度入度，分析是闭包运算，还是并集运算还是连接运算。然后用正则表达式替换&lt;br&gt;
&lt;code&gt;注&lt;/code&gt; 并弧用加号&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655393874197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;正则语言的性质&#34;&gt;正则语言的性质&lt;/h1&gt;
&lt;p&gt;如果一个语言是正则语言，那么一定满足泵引理，反之不成立。&lt;br&gt;
正则语言的封闭性：经过运算还为正则语言&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DFA 极小化&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;步骤&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造表格，如果有不可达状态则先删除，左边列是 1~n 下面行是 0~n-1&lt;/li&gt;
&lt;li&gt;所有终点为一组，行列标上 x&lt;/li&gt;
&lt;li&gt;任意找两个其他未标注的点，看两个点到终点的路径，分别看输入一个数，输入两个数，输入三个数后，是否相同，只要存在相同的路径，则两个点为不可区分，不用标注；无论怎么都找不到，则为可区分，标上 x。注意，不能走自环，只能走直路。&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655482140507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655482151183.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;上下文无关语言&#34;&gt;上下文无关语言&lt;/h1&gt;
&lt;p&gt;上下文无关文法：CFG&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生树：&lt;/strong&gt; 一定是上下文无关文法 CFG 的派生树。&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655469230531.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;最左派生：从最左边开始替换，最右、随机同理。&lt;br&gt;
派生树越靠近叶子节点（越在下面），优先级越高。&lt;br&gt;
随机派生有多少种方式，就有多少种派生。计算派生时，找到派生树种所有的变量（ABC），计算所有变量的排列数，即为派生数。但是要注意固有顺序不能变。&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655470345207.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据派生树写出原 CFG 直接看图就行。&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655470533945.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CFG 的化简&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;步骤&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除无用符号（注意要把不可达状态的整个表达式都删了，比如 S→AB，B 不存在，则 AB 都删）&lt;/li&gt;
&lt;li&gt;删除 ɛ 产生式&lt;/li&gt;
&lt;li&gt;删除单一产生式（形如 A → B）&lt;/li&gt;
&lt;li&gt;再次出现无用符号时，再次删除无用符号&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;例&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655470845354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;去除 ɛ 产生式的例子&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655471117714.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
任何不含空串的CFG都能转化为 CNF / GNF&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乔姆斯基范式：&lt;/strong&gt; CNF，形如 A → BC 、 A → a，在化为 CNF 前需先简化&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655472152865.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;格雷巴赫范式：&lt;/strong&gt; GNF，形如 A → a 、 A → aBCDE.... ，在化为 GNF 前需先简化&lt;br&gt;
需要消除左递归（把左递归变为右递归），形如：A → Aβ&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655476112225.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;简例&lt;/code&gt;&lt;br&gt;
A → A0 | 1&lt;br&gt;
变为：&lt;br&gt;
A → 1&lt;br&gt;
A → 1B&lt;br&gt;
B → 0B&lt;br&gt;
B → 0&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655476340663.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;下推自动机-pda&#34;&gt;下推自动机 PDA&lt;/h1&gt;
&lt;p&gt;PDA 是 ɛ-NFA 增加了一个栈&lt;br&gt;
PDA 用于识别一个·句子是否满足上下文无关文法（识别上下文无关语言）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PDA 的构成：&lt;/strong&gt;&lt;br&gt;
M = （Q ，∑，Γ，δ，q0，Z0，F）&lt;br&gt;
Q ：状态的集合 {q0 q1 q2}&lt;br&gt;
∑：输入字母表，要识别的句子含有的符号，如{a,b,c} {1,2,3}&lt;br&gt;
Γ：栈符号表，对应 CFG 中的变量 {S,A,B,C}&lt;br&gt;
δ：状态转移函数，有两种格式，在下面给出&lt;br&gt;
q0：起始状态&lt;br&gt;
Z0：开始符号，开始时栈底的元素&lt;br&gt;
F：终止状态集合{q1 q2 q3}，空栈接受时 F 为 Ø&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移函数 δ 的两种格式&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;常规转移&lt;/code&gt;&lt;br&gt;
δ(q，a，Z)={(p1，γ1)0(p2，γ2)，...，(pm，γm)}&lt;br&gt;
表示状态 q 时，读入句子中的符号 a ，弹出栈顶符号 Z ，转移到新状态 pi ，将 γi 中的符号从右向左压入栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例1&lt;/strong&gt;&lt;br&gt;
δ1(q0，1，S)={(q0，SB)}&lt;br&gt;
在状态 q0 时，读入 1 ，弹出栈顶元素 S ，转移到新状态 q0 ，将 SB 串以 B、S 的顺序入栈（B 在 S 的下面）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例2&lt;/strong&gt;&lt;br&gt;
δ1(q0，0，A)={(q0，ε)}&lt;br&gt;
在状态 q0 时，读入 0 ，弹出栈顶元素 A ，转移到新状态 q0 ，将 ε 入栈&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ɛ 转移&lt;/code&gt;&lt;br&gt;
δ(q，ɛ，Z)={(p1，γ1)0(p2，γ2)，...，(pm，γm)}&lt;br&gt;
表示状态 q 时，读入句子中的符号 a ，弹出栈顶符号 Z ，转移到新状态 pi ，将 γi 中的符号从右向左压入栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;br&gt;
δ2(q0，ε，Z)={(q1，ε)}&lt;br&gt;
在状态 q0 时，读入 1 ，弹出栈顶元素 S ，转移到新状态 q0 ，将 SB 串以 B、S 的顺序入栈（B 在 S 的下面）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造 PDA&lt;/strong&gt;&lt;br&gt;
CFG → PDA&lt;br&gt;
&lt;code&gt;空栈接受&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;化为 CFG&lt;/li&gt;
&lt;li&gt;CFG → GNF&lt;/li&gt;
&lt;li&gt;写出 GNF 的最左派生，注明 PDA 转移函数要做的动作&lt;/li&gt;
&lt;li&gt;写出 PDA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4001/post-images/1655535184644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655535222307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655535227819.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;终态接受&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;和空栈接受对比：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符号的添加：&lt;br&gt;
添加一个开始符号 Z0、一个栈底符号 Z 、一个终止状态 q1&lt;br&gt;
从 Z0 开始，弹出 Z0，把 Z 压入栈底，当栈内只剩 Z 时，跳转到 q1 终止状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转移函数的添加：&lt;br&gt;
原状态转移函数都不变，找到原栈底元素的转移函数，这里是含有 S 的三个转移函数，把 S 改为新定义的栈底符号 Z0，在右边入栈中加上新的栈底元素 Z 。对于右边是 ε 的转移，只改动 Z0，ε 不变。&lt;br&gt;
此外，还需在最后添加遇到 Z 转移到 q1 的转移函数。&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655536498042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空栈接受的 PDA → 终态接受的 PDA （二者等价）&lt;/p&gt;
&lt;p&gt;CFG → 空栈接受的 PDA&lt;/p&gt;
&lt;h1 id=&#34;图灵机-tm&#34;&gt;图灵机 TM&lt;/h1&gt;
&lt;p&gt;M=(Q, ∑, Γ, δ,q0 , B, F)&lt;br&gt;
Q ：状态的集合 {q0 q1 q2}&lt;br&gt;
∑：输入字母表，要识别的句子含有的符号，如{a,b,c} {1,2,3}&lt;br&gt;
Γ：带符号表，对应 CFG 中的变量 {S,A,B,C}&lt;br&gt;
δ：状态转移函数，有两种格式，在下面给出&lt;br&gt;
q0：起始状态&lt;br&gt;
B：空白符&lt;br&gt;
F：终止状态集合{q1 q2 q3}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移函数 δ 的两种格式&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;右移&lt;/code&gt;&lt;br&gt;
δ(q，X)=(p，Y，R)&lt;br&gt;
表示状态 q 时，读入句子中的符号 X ，弹出栈顶符号 Z ，将状态改为 p ，并在 X 所在的带方格中印刷符号 Y，然后将读头右移一格&lt;br&gt;
&lt;code&gt;左移&lt;/code&gt;&lt;br&gt;
δ(q，X)=(p，Y，L)&lt;br&gt;
表示状态 q 时，读入句子中的符号 X ，弹出栈顶符号 Z ，将状态改为 p ，并在 X 所在的带方格中印刷符号 Y，然后将读头左移一格&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图灵机接受的语言&lt;/strong&gt;&lt;br&gt;
若可接受：停机+接受&lt;br&gt;
若不可接受：停机+拒绝 / 永不停机&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655562933815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655562939698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4001/post-images/1655562944073.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造图灵机&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把要识别的句子模拟写在纸带上&lt;/li&gt;
&lt;li&gt;逐渐向右移动，观察能否用替换（标记）等方式识别走过的路&lt;/li&gt;
&lt;li&gt;设置好不同的状态，不同的输入，列出表格&lt;/li&gt;
&lt;/ol&gt;
">《形式语言与自动机》笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/keras-qian-ru-qian-chu/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">Keras 浅入浅出</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/xing-shi-yu-yan-python-shi-xian-e-nfa-greater-dfa/"" data-c="
          &lt;p&gt;&lt;code&gt;参考资料&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;http://www.srcmini.com/7313.html&#34;&gt;自动机从ε NFA到DFA的转换&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Step1&lt;br&gt;
构建ε闭包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ε-ΝFA -&amp;gt; DFA
import re  # 引入正则表达式模块

# 打开文件
with open(r&#39;.\ΝFA1.txt&#39;, encoding=&#39;utf-8&#39;) as file:  # 第一例
# with open(r&#39;.\ΝFA2.txt&#39;, encoding=&#39;utf-8&#39;) as file:  # 第二例
    lines = file.readlines()  # 按行读取文件
    # for line in lines:  # 展示文件
    #     print(line, end=&#39;&#39;)

# 创建全局字典，为后面函数所用
e_closure = {}  # 创建空状态转移字典（ε闭包）
state_closure = {}  # 创建状态转移字典，用于保存原状态转移函数


# 创建每一个状态的ε闭包
def Closure():  # 定义e闭包函数
    p1 = re.compile(r&amp;quot;[{](.*?)[}]&amp;quot;, re.S)  # 正则表达式匹配大括号中状态

    # ————————————先单独处理第一行，因为带有起始符#————————————
    linelist0 = lines[1].split()  # 将一行解析为列表形式
    # 求第一行的状态转移函数，并保存
    state_closure[linelist0[0][1:3] + &#39;0&#39;] = linelist0[1][1:-1].split()
    state_closure[linelist0[0][1:3] + &#39;1&#39;] = linelist0[2][1:-1].split()

    trdstate = str(re.findall(p1, linelist0[3]))  # third state 用于保存e转移的所有状态
    if trdstate == &amp;quot;[&#39;&#39;]&amp;quot;:  # 如果e转移为空
        e_closure[linelist0[0][1:3]] = [linelist0[0][1:3]]  # 那么e闭包只包含当前状态
    else:
        string1 = [linelist0[0][1:3]]
        for i in trdstate[2:-2].split(&#39;,&#39;):
            string1.append(i)
        for j in range(2, len(lines)):  # 遍历当前行下面每一行的e转移
            linelist01 = lines[j].split()
            trdstate = str(re.findall(p1, linelist01[3]))  # third state 用于保存e转移的所有状态
            if trdstate == &amp;quot;[&#39;&#39;]&amp;quot;:  # 如果e转移为空
                break
            string1.append(trdstate[2:-2])
        e_closure[linelist0[0][1:3]] = string1

    # ————————————遍历中间行————————————
    for i in range(2, len(lines) - 1):
        linelist = lines[i].split()  # 将一行解析为列表形式
        # 求状态转移函数
        state_closure[linelist[0] + &#39;0&#39;] = linelist[1][1:-1].split()
        state_closure[linelist[0] + &#39;1&#39;] = linelist[2][1:-1].split()

        trdstate = str(re.findall(p1, linelist[3]))  # third state 用于保存e转移的所有状态
        if trdstate == &amp;quot;[&#39;&#39;]&amp;quot;:  # 如果e转移为空
            e_closure[linelist[0]] = [linelist[0]]  # 那么e闭包只包含当前状态
        else:
            string1 = [linelist[0], trdstate[2:-2]]
            for j in range(i + 1, len(lines)):  # 遍历当前行下面每一行的e转移
                linelist01 = lines[j].split()
                trdstate = str(re.findall(p1, linelist01[3]))  # third state 用于保存e转移的所有状态
                if trdstate == &amp;quot;[&#39;&#39;]&amp;quot;:  # 如果e转移为空
                    break
                string1.append(trdstate[2:-2])
            e_closure[linelist[0]] = string1

    # ————————————单独处理最后一行，因为带有终止符*————————————
    i = len(lines) - 1
    linelisti = lines[i].split()  # 将一行解析为列表形式
    # 求状态转移函数
    state_closure[linelisti[0][1:3] + &#39;0&#39;] = linelisti[1][1:-1].split()
    state_closure[linelisti[0][1:3] + &#39;1&#39;] = linelisti[2][1:-1].split()

    trdstate = str(re.findall(p1, linelisti[3]))  # third state 用于保存e转移的所有状态
    if trdstate == &amp;quot;[&#39;&#39;]&amp;quot;:  # 如果e转移为空
        e_closure[linelisti[0][1:3]] = [linelisti[0][1:3]]  # 那么e闭包只包含当前状态
    else:
        e_closure[linelisti[0][1:3]] = [linelisti[0][1:3], trdstate[2:-2]]

    return e_closure, state_closure  # 返回元组，0号元素为e闭包，1号元素为状态转移字典


# 构造新状态列表
def New_state_closure():
    q = []  # 创建新状态列表
    # ————————————处理第一个状态————————————
    q.append(e_closure[&#39;q0&#39;])  # 第一个状态设置为q0的ε闭包

    l0 = []  # 创建input为0时的状态列表
    l1 = []  # 创建input为1时的状态列表
    for state in e_closure[&#39;q0&#39;]:  # 遍历第一个新状态的子状态
        for i in state_closure.keys():  # 遍历子状态转移集
            if i == state + &#39;0&#39; and state_closure[i] != []:  # 如果为当前状态，且input = &#39;0&#39;，并排除空集
                l0 += state_closure[i]  # 保存状态
            if i == state + &#39;1&#39; and state_closure[i] != []:
                l1 += state_closure[i]

    # 将新状态分情况保存在新状态列表
    if l0 == [] and l1 != []:
        q.append([])
        q.append(e_closure[l1[0]])
    elif l0 != [] and l1 == []:
        q.append(e_closure[l0[0]])
        q.append([])
    elif l0 == [] and l1 == []:
        q.append([])
        q.append([])
    else:
        q.append(e_closure[l0[0]])  # 保存的为其ε闭包
        q.append(e_closure[l1[0]])

    # ————————————处理其余状态————————————
    n = 1  # 从状态列表q中第一个元素开始遍历
    chongfu = 0  # 重复判定初始为0（不重复）
    while True:
        l0 = []  # 创建input为0时的状态列表
        l1 = []  # 创建input为1时的状态列表
        if n != 1:
            for i in range(1, n):  # 判断前面是否有该状态
                if q[n] == q[i]:
                    chongfu = 1  # 重复
                    break
                else:
                    chongfu = 0  # 不重复
        if q[n] == [] or chongfu:  # 如果该状态为空集或重复
            if len(q) == n + 1:  # 如果列表结束
                return q  # ~~~~~~~~~~~~函数结束，返回新状态列表~~~~~~~~~~~~
            else:  # 则跳到下一状态
                n += 1

        else:  # 继续更新新状态列表
            for state in q[n]:  # 遍历第n个新状态的子状态
                for i in state_closure.keys():  # 遍历子状态转移集
                    if i == state + &#39;0&#39; and state_closure[i] != []:  # 如果为当前状态，且input = &#39;0&#39;，并排除空集
                        l0 += state_closure[i]  # 保存状态
                    if i == state + &#39;1&#39; and state_closure[i] != []:
                        l1 += state_closure[i]

            if l0 == [] and l1 != []:
                q.append([])
                q.append(e_closure[l1[0]])
            elif l0 != [] and l1 == []:
                q.append(e_closure[l0[0]])
                q.append([])
            elif l0 == [] and l1 == []:
                q.append([])
                q.append([])
            else:
                q.append(e_closure[l0[0]])
                q.append(e_closure[l1[0]])
            n += 1

# 格式化输出新状态列表
def Print_New_state(Q):
    # 重命名
    record = []  # 记录列表，用于保存已经重新命名的元素
    n = 1
    i = 1
    while True:
        if (f&#39;q{n}&#39; not in record) and (Q[i] not in record):
            now = Q[i]
            if now == []:
                Q[i] = &#39;&#39;
                i += 1
                if i == len(Q):
                    break
            else:
                for j in range(i, len(Q)):
                    if Q[j] == now:
                        Q[j] = f&#39;q{n}&#39;
                record.append(f&#39;q{n}&#39;)
                n += 1
                i += 1
        else:
            i += 1
            if i == len(Q):
                break
    for i in range(1, len(Q)):  # 加括号
        Q[i] = &#39;{&#39; + Q[i] + &#39;}&#39;

    # 按格式输出
    print(&#39;0 1 epsilon&#39;)
    for i in range(1, len(Q), 2):
        if i == 1:
            print(&#39;#q0 %s %s&#39; % (Q[i], Q[i + 1]))
        elif i == len(Q) - 2:
            print(&#39;*q%s %s %s&#39; % (i - 3, Q[i], Q[i + 1]))
        else:
            print(&#39;q%s %s %s&#39; % (i - 2, Q[i], Q[i + 1]))


if __name__ == &#39;__main__&#39;:
    closures = Closure()
    # print(Closure())  # 展示e闭包和状态转移字典
    Q = New_state_closure()
    # print(Q)  # 展示新状态列表Q
    Print_New_state(Q)

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;经验总结&#34;&gt;经验总结：&lt;/h1&gt;
&lt;p&gt;先把所有要点都明确之后再搞，要不全是bug&lt;br&gt;
先用伪代码在pycharm里写一遍&lt;br&gt;
可以用思维导图解释算法流程&lt;/p&gt;
">【形式语言】python实现 ε-ΝFA -> DFA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ji-wang-bian-cheng-shi-yan/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://m653uatd6t.feishu.cn/docs/doccn1134QQsBECAj32x7hzIndf&#34;&gt;要求文档&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_37500516/article/details/120149101&#34;&gt;参考博客&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_33690566/article/details/105415681&#34;&gt;可靠传输协议&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;gbn协议&#34;&gt;GBN协议&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1fU4y1h7Sw?spm_id_from=333.337.search-card.all.click&#34;&gt;b站讲解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/fung30678/GBN-Simulator&#34;&gt;参考代码&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;rdt-30比特交替协议alternating-bit-protocol&#34;&gt;Rdt 3.0：比特交替协议(alternating-bit protocol)&lt;/h1&gt;
&lt;h1 id=&#34;环境配置&#34;&gt;环境配置&lt;/h1&gt;
&lt;p&gt;本实验采用c语言实现，用 Visual Studio，我想要在一个项目中用多个源文件来调试不同的子文件（多个 main 函数）遇到的问题：&lt;br&gt;
1、不能正确创建源文件&lt;br&gt;
2、不能正确运行源文件&lt;br&gt;
&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_39886612/article/details/117056754&#34;&gt;创建源文件&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_30815237/article/details/87452311&#34;&gt;分别运行各个文件&lt;/a&gt;&lt;br&gt;
同时注意，若创建空项目，是不可以直接运行的。而创建控制台文件可以直接运行，也可以后续添加源文件。&lt;/p&gt;
&lt;h1 id=&#34;调试&#34;&gt;调试&lt;/h1&gt;
&lt;p&gt;使用 vs 调试时不能直接在 shell 中输入参数，需要在运行前设置参数，要在命令参数中设置好各个参数&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/u012750702/article/details/51508214#:~:text=%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E5%9C%A8VS%E4%B8%AD%E5%90%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8D%B3%E5%90%91main%28%29%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%B3%E9%94%AE%E5%8D%95%E5%87%BB%E8%A6%81,%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0%E7%9A%84%E5%B7%A5%E7%A8%8B%E2%80%93%3E%E5%B1%9E%E6%80%A7%E2%80%93%3E%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E2%80%93%3E%E8%B0%83%E8%AF%95%EF%BC%8C%E5%9C%A8%E5%8F%B3%E4%BE%A7%E2%80%9C%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E2%80%9D%E6%A0%8F%E8%BE%93%E5%85%A5%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%90%84%E5%8F%82%E6%95%B0%E9%97%B4%E7%94%A8%E7%A9%BA%E6%A0%BC%E5%88%86%E7%A6%BB&#34;&gt;VS 传参&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;遇到的c语言问题&#34;&gt;遇到的C语言问题&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_36020968/article/details/72805661&#34;&gt;向函数传入结构体&lt;/a&gt;&lt;br&gt;
在函数中定义的变量为局部变量&lt;/p&gt;
">【计网】可靠运输协议编程实验</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-bp-shen-jing-wang-luo/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_39441762/article/details/80446692?spm=1001.2101.3001.6650.1&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&amp;amp;utm_relevant_index=2&#34;&gt;介绍1&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;sklearn-相关实现sklearnneural_network&#34;&gt;sklearn 相关实现——sklearn.neural_network&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.weixueyuan.net/a/913.html&#34;&gt;MLPClassifier分类演示&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://scikit-learn.org.cn/view/713.html&#34;&gt;MLPClassifier参数&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://scikit-learn.org.cn/view/714.html&#34;&gt;MLPRegressor参数&lt;/a&gt;&lt;/p&gt;
">【ML】人工神经网络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/surfing/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://edurank.org/uni/beijing-university-of-posts-and-telecommunications/rankings/&#34;&gt;来点鸡血&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20824615&#34;&gt;如何优雅地使用 Stack Overflow？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/415782127&#34;&gt;三步就可以把代码块完美插入到word中&lt;/a&gt;&lt;/p&gt;
">Surfing</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shuo-du-ke-yi-shuo/"" data-c="
          &lt;h1 id=&#34;欢迎来到博客隐藏部分&#34;&gt;欢迎来到博客隐藏部分&lt;/h1&gt;
&lt;p&gt;https://bbs.boniu123.cc/forum.php?mod=viewthread&amp;amp;tid=178940&lt;/p&gt;
&lt;p&gt;https://bbs.pediy.com/thread-202110.htm&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/345269352&#34;&gt;网警是怎么在线下抓住造谣者的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ssrshare.github.io/2019/04/07/tor/&#34;&gt;洋葱路由&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/71805955&#34;&gt;洋葱路由1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://program-think.blogspot.com/&#34;&gt;编程随想&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pincong.rocks/article/32003&#34;&gt;简谈网警是怎么找到海外网站发帖之人的&lt;/a&gt;&lt;/p&gt;
">说，都可以说</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/pandas-mei-tian-yi-dian-pandas/"" data-c="
          &lt;h1 id=&#34;读取数据&#34;&gt;读取数据&lt;/h1&gt;
&lt;p&gt;pd.read_csv()&lt;br&gt;
&lt;a href=&#34;https://www.runoob.com/pandas/pandas-dataframe.html&#34;&gt;pandas.DataFrame()：创建数据表格&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;展示数据&#34;&gt;展示数据&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_24754061/article/details/103738513&#34;&gt;Pandas.describe()：展示数据统计信息&lt;/a&gt;&lt;br&gt;
dataframe.head(n)：展示数据前 n 行&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/lost0910/article/details/107746751&#34;&gt;pd.set_option() 取消折叠显示&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;数据处理&#34;&gt;数据处理&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_42067550/article/details/106260512&#34;&gt;Pandas 统计方法总汇&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/W_weiying/article/details/84626260&#34;&gt;pd.drop()：删除指定行列&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_18351157/article/details/113520345&#34;&gt;data.to_csv()：写入/修改 csv 文件&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://huang-tong-xue.blog.csdn.net/article/details/119222439?spm=1001.2101.3001.6650.2&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.pc_relevant_default&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.pc_relevant_default&amp;amp;utm_relevant_index=4&#34;&gt;Pandas.set_option()：设置数据集的展示参数&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/393930947&#34;&gt;Pandas map()：修改数据集中行列值&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/jhr112/article/details/115631246&#34;&gt;pandas 数据清洗：drop() del() 等&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/walking_visitor/article/details/85128461&#34;&gt;相关系数 (correlation coefficient) 函数 corr()&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/9dec47bac5b9&#34;&gt;corr() 的三个相关系数：Pearson相关、Spearman相关、Kendall相关&lt;/a&gt;&lt;a href=&#34;https://www.biaodianfu.com/pearson-kendall-spearman.html#Scipy%E7%9A%84pearsonr%E6%96%B9%E6%B3%95&#34;&gt;；另一篇&lt;/a&gt;&lt;/p&gt;
">【Pandas】每天一点 Pandas</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/python-shui-de-python-xue-de-bu-zha-shi/"" data-c="
          &lt;h1 id=&#34;基础操作&#34;&gt;基础操作&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;多个变量在一行赋值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a, b = 1, 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_39700394/article/details/111418838&#34;&gt;浮点数格式化输出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.py.cn/faq/python/14859.html&#34;&gt;无穷大 inf 和 非数字的 NaN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.w3school.com.cn/python/ref_string_index.asp&#34;&gt;字符串 index() 方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/xiaomifanhxx/article/details/81537506&#34;&gt;多文件调用&lt;/a&gt;&lt;br&gt;
若要在 A 文件运行整个 B 文件，则在 A 文件中如下写：（同一目录下）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import B
if __name__ == &#39;__main__&#39;:
    B
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;列表常见操作&#34;&gt;列表常见操作&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;获取列表数据的 index&lt;/strong&gt;&lt;br&gt;
list.index(num)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表排序&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;不改变原 list&lt;/code&gt;&lt;br&gt;
newlist = sorted(list)&lt;br&gt;
&lt;code&gt;改变原 list&lt;/code&gt;&lt;br&gt;
list.sort()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表切片&lt;/strong&gt;&lt;br&gt;
例：单独对列表前 n 个数据求和&lt;br&gt;
sum(nums[0:n])  # 从 0 到 n - 1&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/view/2209.html&#34;&gt;&lt;strong&gt;删除列表元素的四种方法&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表最后一个元素&lt;/strong&gt;&lt;br&gt;
list[-1]&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/GumpYan/p/12334839.html&#34;&gt;&lt;strong&gt;倒叙遍历列表&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_38564268/article/details/91445719&#34;&gt;&lt;strong&gt;倒序输出列表&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;list.pop()&lt;/strong&gt;&lt;br&gt;
pop() 括号中的是元素的 index，返回 pop 的值。若直接pop则返回最后一个元素。&lt;br&gt;
注意，pop是对原列表直接删除的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整体替换列表&lt;/strong&gt;&lt;br&gt;
list1[m:] = list2  # 第 m 个元素后面的元素都替换成 list2 中的元素，list1 变成两个列表的合并&lt;br&gt;
&lt;a href=&#34;https://leetcode.cn/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/&#34;&gt;leetcode 相关题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表合并（六种方法）&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_38739735/article/details/115451727&#34;&gt;前五种&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_31281613/article/details/112889007&#34;&gt;切片法（同整体替换列表）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_40797015/article/details/112171892&#34;&gt;&lt;strong&gt;将输入的数字转换为列表&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qdPython/article/details/120845987&#34;&gt;开辟一定空间的数组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[enumerate()：将可迭代对象加编号] (https://zhuanlan.zhihu.com/p/92544989)&lt;br&gt;
&lt;a href=&#34;https://leetcode.cn/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/&#34;&gt;leetcode 相关题解&lt;/a&gt;&lt;br&gt;
这样 for 循环遍历列表可以直接遍历出序号和值，也方便用该列表构造字典 / 哈希表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;continue 和 break 的区别&lt;/strong&gt;&lt;br&gt;
continue 是结束本次循环（执行到该条语句后面不执行了，进行下一次循环）&lt;br&gt;
break 是跳出整个循环&lt;/p&gt;
&lt;h1 id=&#34;os-操作&#34;&gt;OS 操作&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/108211297&#34;&gt;创建文件夹 —— os.mkdir ; os.makedirs&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_51697369/article/details/119864944&#34;&gt;参数解析&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
os.mkdir(r&amp;quot;C:\Users\ZJL\Desktop\test&amp;quot;)  # 执行之后会发现桌面产生文件夹 test

# 两函数区别
# 假设 r&amp;quot;C:\Users\ZJL\Desktop\test 路径已存在
# 现在要创建 r&amp;quot;C:\Users\ZJL\Desktop\test\1\2
# os.makedirs 可以，os.mkdir 不行

os.mkdir(r&amp;quot;C:\Users\ZJL\Desktop\test\1\2&amp;quot;)
os.makedirs(r&amp;quot;C:\Users\ZJL\Desktop\test\1\2&amp;quot;)

# 总结：os.mkdir 只能创建最后一级的目录，os.makedirs 可以全创建
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;python继承&lt;/strong&gt;&lt;/p&gt;
">【Python】谁 Python 学的不扎实？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/android/"" data-c="
          &lt;h1 id=&#34;root&#34;&gt;Root&lt;/h1&gt;
&lt;p&gt;安卓手机最高权限，可以修改系统设置，卸载系统自带软件。有些手机自带 root，有些需要手动获取 root&lt;/p&gt;
&lt;h1 id=&#34;adb&#34;&gt;ADB&lt;/h1&gt;
&lt;p&gt;安卓调试桥梁，连接电脑时会需要ADB&lt;/p&gt;
&lt;h1 id=&#34;安卓神器软件分享&#34;&gt;安卓神器软件分享&lt;/h1&gt;
&lt;p&gt;黑域：省电管控&lt;br&gt;
Tasker：手机自动化&lt;br&gt;
&lt;a href=&#34;https://taskerm.com/?p=218&#34;&gt;Tasker良心博客分享&lt;/a&gt;&lt;/p&gt;
">【Android】</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shu-ju-jie-gou-ke-she-1tou-cha-fa-gou-zao-lian-biao/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Node():  # 定义节点类
    def __init__(self, item):  # 初始化数据
        self.item = item  # 把数据存入节点
        self.next = None  # 默认next节点为None

# 注意，传入的数据形式为列表，可一次性插入多个数据
def creat_head(datalist, linklist):  # 分别传入要插入的数据列表，和非空单链表
    head_node = Node(datalist[0])  # 定义头节点，把datalist的第一个元素赋给头节点
    head_node.next = linklist  # 把该节点连接在链表最开头
    for data in datalist[1:]:  # 遍历剩余数据
        node = Node(data)  # 创建新节点
        node.next = head_node  # 把新节点插在头节点的前面
        head_node = node  # 把新节点命名为头节点，以便重复上述操作
    return head_node  # 返回改链表的首地址，从而可遍历展示该链表

def print_linklist(current_node):  # 打印链表（传入头节点）
    while current_node:  # 当前节点非空时
        print(current_node.item, end = &#39; &#39;)  # 打印链表节点的数据元素
        current_node = current_node.next  # 移动指针，重复循环

# 下面用最朴素的方法创建一个非空单链表
a = Node(1)  # 创建一个独立节点
a.next = Node(2)  # 在a后连接新节点
a.next.next = Node(3)  # 连接新节点
print_linklist(a)  # 展示该链表 （ 1 2 3 ）

print(&#39;\n&#39;)

linklist1 = creat_head([8,7,6], a)  # 头插法把该列表插入a链表
print_linklist(linklist1)  # 展示链表
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】课设1：头插法构造链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/seaborn-shu-ju-ke-shi-hua/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/98729226&#34;&gt;pairplot()：展示数据集变量之间的关系&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/cymx66688/p/10536403.html&#34;&gt;sns.countplot()：柱状图显示&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/96040773?from_voters_page=true&#34;&gt;sns.heatmap()：显示变量之间相关系数矩阵&lt;/a&gt;&lt;/p&gt;
">【Seaborn】数据可视化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-he-han-shu/"" data-c="
          &lt;p&gt;将低维数据映射到高维，从而对数据进行分类。&lt;/p&gt;
">【ML】核函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/sklearn-mei-tian-yi-dian-sklearn/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://scikit-learn.org.cn/&#34;&gt;sklearn中文社区1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://sklearn.apachecn.org/#/&#34;&gt;sklearn中文社区2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/algorithmPro/article/details/103045824&#34;&gt;超详细入门&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;案例&#34;&gt;案例&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/admin11111111/article/details/116570878&#34;&gt;鸢尾花svm&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/Together_CZ/article/details/78697664?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_aa&amp;amp;spm=1001.2101.3001.4242.2&amp;amp;utm_relevant_index=4&#34;&gt;鸢尾花2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://cxymm.net/article/qianyunzzz/122885761&#34;&gt;乳腺癌svm，from UCI&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;数据集&#34;&gt;数据集&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://archive.ics.uci.edu/&#34;&gt;UCI数据集&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_40583722/article/details/121800784&#34;&gt;UCI使用教程（注意看文章里面的链接）&lt;/a&gt;&lt;br&gt;
数据集页面后缀为 .data .csv 的为数据集，剩余的文件均为数据集信息&lt;/p&gt;
&lt;h1 id=&#34;sklearn项目一般步骤&#34;&gt;sklearn项目一般步骤：&lt;/h1&gt;
&lt;p&gt;获取数据&lt;br&gt;
数据预处理&lt;br&gt;
特征工程&lt;br&gt;
建立模型、训练模型、调参&lt;br&gt;
模型评估&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读入数据：&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/xizi_ghq/article/details/108660671&#34;&gt;datasets 详解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/tcy23456/article/details/106388651/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&amp;amp;spm=1001.2101.3001.4242.1&amp;amp;utm_relevant_index=3&#34;&gt;数据集文件读取的几种方式&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/29af03788ff6&#34;&gt;数据集文件读取的几种方式2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/4dfe5ce3bda9&#34;&gt;利用urllib直接网络读入&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/zyj3955/p/15414382.html&#34;&gt;鸢尾花的导入与划分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;导入的UCI的数据的表头（ names 列表）如何确定？&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一般都在UCI主页的 Attribute Information 中列出来了，可以直接对应其表头。
个别数据集，比如乳腺癌数据集，3种癌细胞每个有10个特征，需要自行对三种癌细胞进行命名/编号
这就需要对数据集的信息进行分析，观察数据特征，分析其含义，给出适合的 names
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据预处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/program_developer/article/details/78637711?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165123847616782391882623%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=165123847616782391882623&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78637711.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;amp;utm_term=%E5%BD%92%E4%B8%80%E5%8C%96&amp;amp;spm=1018.2226.3001.4187&#34;&gt;&lt;code&gt;归一化&lt;/code&gt;&lt;/a&gt;&lt;br&gt;
注：归一化和标准化不同，标准化是变为正态分布&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征工程&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/29af03788ff6&#34;&gt;sklearn-pandas 示例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据集划分&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/Yanjy-OnlyOne/p/11288098.html&#34;&gt;train_test_split()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据可视化&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;未完成任务&#34;&gt;未完成任务：&lt;/h1&gt;
&lt;p&gt;1 sklearn svm 图 （分类结果可视化&lt;br&gt;
2 实验代码中调参部分函数&lt;/p&gt;
">【sklearn】每天一点 sklearn</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/matplotlib-mei-tian-yi-dian-matplotlib-yong-fa/"" data-c="
          &lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/matplotlib/&#34;&gt;详细教程&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.runoob.com/w3cnote/matplotlib-tutorial.html&#34;&gt;简易教程&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/258106097&#34;&gt;plt.plot()&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/m0_37362454/article/details/81511427&#34;&gt;plt.figure()：设置图像参数&lt;/a&gt;&lt;/p&gt;
">【matplotlib】每天一点 matplotlib 用法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/numpy-mei-tian-yi-dian-numpy-xiao-ji-qiao/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/38353562#:~:text=Scipy%EF%BC%9A%20%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E6%95%B0%E5%AD%A6%E3%80%81%E7%A7%91%E5%AD%A6%E3%80%81%E5%B7%A5%E7%A8%8B%E9%A2%86%E5%9F%9F%E7%9A%84%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E6%8F%92%E5%80%BC%E3%80%81%E7%A7%AF%E5%88%86%E3%80%81%E4%BC%98%E5%8C%96%E3%80%81%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%81%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3%E7%9A%84%E6%B1%82%E8%A7%A3%E3%80%81%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AD%89%E9%97%AE%E9%A2%98%E3%80%82%20Pandas%EF%BC%9A,%E5%9F%BA%E4%BA%8E%20NumPy%20%E7%9A%84%E4%B8%80%E7%A7%8D%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%BB%E5%8A%A1%E8%80%8C%E5%88%9B%E5%BB%BA%E7%9A%84%E3%80%82&#34;&gt;numpy，scipy，pandas这些库的区别是什么？&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_39072607/article/details/89321495&#34;&gt;np.zeros：用于生成全 0 的数组&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_41800366/article/details/86589680&#34;&gt;np.arange()：生成序列（等差数列）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.w3cschool.cn/article/54960412.html&#34;&gt;np.linspace()：当要生成浮点数序列时，用该函数代替arange()，来保证精度&lt;/a&gt;&lt;/p&gt;
">【Numpy】每天一点 Numpy 小技巧</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shou-ji-zi-dong-hua-cao-zuo-de-yi-xie-tan-suo/"" data-c="
          &lt;p&gt;tasker&lt;br&gt;
自动精灵（操作简单，适合简易任务&lt;br&gt;
Hamibot 需要js&lt;/p&gt;
">手机自动化操作的一些探索</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-zhi-chi-xiang-liang-ji-svm/"" data-c="
          &lt;p&gt;支持向量机（support vector machines, SVM）&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV16T4y1y7qj?from=search&amp;amp;seid=9938878737703056911&amp;amp;spm_id_from=333.337.0.0&#34;&gt;b站入门讲解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1UR4y147AT?p=7&#34;&gt;b站详细讲解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/tj_O8H3S_kdag30jivBy6g&#34;&gt;文档讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#转导式支持向量机&lt;br&gt;
转导式学习在训练过程中使用较少的有标签样本和较多的无标签样本进行学习&lt;/p&gt;
">【ML】支持向量机（SVM）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-hopfield-shen-jing-wang-luo/"" data-c="
          &lt;p&gt;开个帖&lt;/p&gt;
">【ML】Hopfield 神经网络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/kao-yan-kao-yan-zi-liao/"" data-c="
          &lt;p&gt;&lt;a href=&#34;http://qzbltushu.ysepan.com/&#34;&gt;http://qzbltushu.ysepan.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cskaoyan.com/forum.php?mod=viewthread&amp;amp;tid=661957&amp;amp;highlight=%C8%CB%B9%A4%D6%C7%C4%DC&#34;&gt;2021上海交通大学人工智能专硕一战上岸经验贴&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cskaoyan.com/forum.php?mod=viewthread&amp;amp;tid=654181&amp;amp;highlight=%C8%CB%B9%A4%D6%C7%C4%DC&#34;&gt;2019南大人工智能学院经验贴&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.cskaoyan.com/thread-661983-1-1.html&#34;&gt; 2021菜鸡三战最终上岸北大经验贴----最值得一看的经验贴之一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/536024217&#34;&gt;2022清华深研院人工智能考研经验贴&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/498483239&#34;&gt;2022北大软微上岸客观分析贴！！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/550477200&#34;&gt;人工智能领域导师推荐列表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bbs.byr.cn/#!article/AimGraduate/1216195&#34;&gt;北大信科考研上岸经验帖&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bbs.byr.cn/#!article/AimGraduate/1212516&#34;&gt;北大软微报录比5:1，点击就送&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;北邮 上交 复旦 浙大&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://csrankings.org/#/fromyear/2012/toyear/2022/index?all&amp;amp;cn&#34;&gt;CSRankings: Computer Science Rankings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#北邮&lt;br&gt;
&lt;strong&gt;导师&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://bbs.byr.cn/#!article/AimGraduate/1220097&#34;&gt;【问题】请问有人工智能学院模式识别实验室张洪刚老师的师哥师姐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://download.csdn.net/download/qq_42543379/85213340&#34;&gt;北京邮电大学809数据结构复习指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://yzb.bupt.edu.cn/content/content.php?p=8_4_69&#34;&gt;2023年人工智能学院硕士专业目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://yzb.bupt.edu.cn/content/content.php?p=8_4_69&#34;&gt;人工智能学院2023年研究生招生导师信息&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;上交&#34;&gt;上交&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://yzb.sjtu.edu.cn/info/1022/2464.htm&#34;&gt;上交研究生&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;数学1&#34;&gt;数学1&lt;/h1&gt;
&lt;p&gt;高数 武忠祥&lt;br&gt;
线代 | 概率论 张宇&lt;/p&gt;
&lt;h1 id=&#34;408复习&#34;&gt;408复习&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://bbs.byr.cn/#!article/IWhisper/5163169&#34;&gt;408如何复习啊，有推荐教材吗，真诚求问&lt;/a&gt;&lt;/p&gt;
">【考研】考研资料</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/shi-yong-github-desktop-tong-bu-gridea-cai-keng-ji-lu/"" data-c="
          &lt;p&gt;先放一篇其他大佬的文章，说的已经很详细了&lt;br&gt;
&lt;a href=&#34;https://sonatta.top/post/Ux6xKOeOx/&#34;&gt;https://sonatta.top/post/Ux6xKOeOx/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;踩坑：&lt;/code&gt;&lt;br&gt;
写好博客直接把 output push 上去，导致 url 为本地地址，无法打开&lt;/p&gt;
&lt;p&gt;&lt;code&gt;这里再总结一下&lt;/code&gt;&lt;br&gt;
在 gridea 中写好之后，点击同步，不用管是否同步成功，同步是为了生成正确的 url&lt;br&gt;
等待大约 15 - 20 s之后，文件已经生成成功。&lt;/p&gt;
&lt;p&gt;这时，找到站点源文件的 output 文件夹，打开文件夹&lt;br&gt;
复制里面所有内容，粘贴到从 GitHub 上 Pull 下来的文件夹中。&lt;br&gt;
这时 Github Desktop 中会出现刚才新添加的项目&lt;br&gt;
然后注意一定要填写 summary 名称，否则不能 Push&lt;br&gt;
填写之后，就可以 Push 上去了&lt;/p&gt;
&lt;p&gt;注意有时候用校园网挂梯子不好使，建议连接手机热点&lt;br&gt;
只有点了同步之后 GitHub desktop 上才会出现分支变动&lt;/p&gt;
">使用 Github Desktop 同步 Gridea 踩坑记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/github-desktop-guan-li-ben-di-dai-ma/"" data-c="
          &lt;p&gt;首次使用需要用 Git Bash 进行 ssh 密钥配置&lt;br&gt;
&lt;code&gt;ssh密钥配置&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/youzi-xuchongyou/p/15093336.html&#34;&gt;https://www.cnblogs.com/youzi-xuchongyou/p/15093336.html&lt;/a&gt;&lt;br&gt;
&lt;code&gt;总览&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV13W411U7HY?from=search&amp;amp;seid=9646375911820432461&amp;amp;spm_id_from=333.337.0.0&#34;&gt;https://www.bilibili.com/video/BV13W411U7HY?from=search&amp;amp;seid=9646375911820432461&amp;amp;spm_id_from=333.337.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;当需要 push 的文件过大时候报错：&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/69427700/error-rpc-failed-curl-55-send-failure-connection-was-aborted&#34;&gt;https://stackoverflow.com/questions/69427700/error-rpc-failed-curl-55-send-failure-connection-was-aborted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GitHub教程 仓库的创建、同步、删除&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.likecs.com/show-204599371.html&#34;&gt;https://www.likecs.com/show-204599371.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;push时报错：&lt;br&gt;
&lt;code&gt;1&lt;/code&gt;&lt;br&gt;
fatal: unable to access &#39;https://github.com/jeromezjl/jeromezjl.github.io.git/&#39;: Failed to connect to github.com port 443 after 21055 ms: Timed out&lt;br&gt;
没挂梯子&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt;&lt;br&gt;
Authentication failed. Some common reasons include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You are not logged in to your account: see File &amp;gt; Options.&lt;/li&gt;
&lt;li&gt;You may need to log out and log back in to refresh your token.&lt;/li&gt;
&lt;li&gt;You do not have permission to access this repository.&lt;/li&gt;
&lt;li&gt;The repository is archived on GitHub. Check the repository settings to confirm you are still permitted to push commits.&lt;/li&gt;
&lt;li&gt;If you use SSH authentication, check that your key is added to the ssh-agent and associated with your account.&lt;/li&gt;
&lt;li&gt;If you use SSH authentication, ensure the host key verification passes for your repository hosting service.&lt;/li&gt;
&lt;li&gt;If you used username / password authentication, you might need to use a Personal Access Token instead of your account password. Check the documentation of your repository hosting service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查是否有权限操作该仓库；检查对应仓库的URL是否适配，使用https还是ssh&lt;/p&gt;
&lt;p&gt;lastest更新：建议重新配置ssh&lt;br&gt;
删除user文件下中 .ssh 文件中所有文件，按照上述步骤重新配置ssh&lt;/p&gt;
&lt;p&gt;配置完之后，如果还是出现，那么点进github原仓库，在Code按钮下拉栏里面，选择SSH，复制信息，&lt;br&gt;
点击github desktop，repository - repository setting - remote 改成刚才复制的数据&lt;/p&gt;
&lt;p&gt;注意同步一定要先点预览，再点同步，然后才能同步&lt;/p&gt;
">Github Desktop 管理本地代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/wechat/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4001/post-images/1648906251060.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Wechat</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ji-wang-socket-bian-cheng-shi-yan/"" data-c="
          &lt;p&gt;&lt;strong&gt;原文档：&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://m653uatd6t.feishu.cn/docs/doccnBhfhSQ8wZ3krkTnQ3GbDHf#KJ735Z&#34;&gt;https://m653uatd6t.feishu.cn/docs/doccnBhfhSQ8wZ3krkTnQ3GbDHf#KJ735Z&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;参考文章：&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/387279376&#34;&gt;https://zhuanlan.zhihu.com/p/387279376&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;服务器端代码：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
from socket import *
# 使用 AF_INET 套接字家族，SOCK_DGRAM 代表面向非连接（UDP）
serverSocket = socket(AF_INET, SOCK_DGRAM)

# 将 socket 绑定在本机 IP 的 10000 端口
serverSocket.bind((&#39;127.0.0.1&#39;, 10000))

while True:
    # 生成一个 [1, 10] 的随机数，包含两端
    rand = random.randint(1, 10)
    # 将收到的 packet 中的数据存入 message，将地址存入 address（客户端地址）
    message, address = serverSocket.recvfrom(1024)
    # 下面是对收到的 message 进行处理
    # 将 bytes 类型的 message 转换为 string 类型
    message_str = message.decode(&#39;utf-8&#39;)
    # 在 30% 的概率下丢弃收到的 packet
    if rand &amp;lt; 4:
        continue
    # 对收到的 message 做简单处理
    ret = &#39;{&#39; + message_str + &#39;}&#39;
    # 做出响应（将处理后的数据通过sendto函数送回客户端），注意还要将 string 编码为 bytes 类型
    serverSocket.sendto(ret.encode(), address)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;客户端代码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from socket import *
import time

# SOCK_DGRAM 表示使用UDP协议
client = socket(AF_INET, SOCK_DGRAM)
# 设置超时时间为1秒
client.settimeout(1)
# 服务端的ip和端口
server_address = (&#39;152.136.19.235&#39;, 10000)
for i in range(10):
    # 发送ping命令
    client.sendto(b&amp;quot;2020212487&amp;quot;, server_address)
    send_time = time.time()
    try:
        message, adr = client.recvfrom(1024)
        recv_time = time.time()  # 获取
        print(f&amp;quot;[{i}]\t{message.decode()}\tRTT: {(recv_time - send_time) * 1000:.2f}ms&amp;quot;)
    except timeout as e:  # 超时就打印LOST
        print(f&amp;quot;[{i}]\tLOST&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;
">【计网】Socket 编程实验</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/git-shi-yong/"" data-c="
          &lt;p&gt;&lt;strong&gt;使用 Git 上传文件夹到 Github&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/136355306&#34;&gt;https://zhuanlan.zhihu.com/p/136355306&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_45309916/article/details/108273988&#34;&gt;https://blog.csdn.net/weixin_45309916/article/details/108273988&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/dontla/article/details/100017358&#34;&gt;Github 代码上边的Raw、Blame、History是啥意思？&lt;/a&gt;&lt;/p&gt;
">Github 使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ml-jue-ce-shu/"" data-c="
          &lt;p&gt;&lt;strong&gt;b站讲解&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1T7411b7DG?from=search&amp;amp;seid=4602675497552466282&amp;amp;spm_id_from=333.337.0.0&#34;&gt;https://www.bilibili.com/video/BV1T7411b7DG?from=search&amp;amp;seid=4602675497552466282&amp;amp;spm_id_from=333.337.0.0&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;决策树的构建&#34;&gt;决策树的构建&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;C4.5算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;参考文章：&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/zjsghww/article/details/51638126&#34;&gt;https://blog.csdn.net/zjsghww/article/details/51638126&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;算法步骤：&lt;/code&gt;&lt;br&gt;
1）计算总信息熵 Entropy&lt;br&gt;
2）分别计算每个属性信息熵&lt;br&gt;
3）总信息熵 - 属性信息熵 得到信息增益 Gain(A)&lt;br&gt;
4）计算信息增益率 GainRatio(A) = Gain / Ent&lt;br&gt;
5）增益率max的为根节点&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;&lt;br&gt;
总信息熵用结果的概率进行计算&lt;br&gt;
属性信息熵：&lt;br&gt;
∑（ p(属性概率) * ∑ -（ p(该属性内成功概率) log2 p + p(该属性内失败概率)log2 p ））&lt;/p&gt;
&lt;p&gt;&lt;code&gt;习题&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/166393579&#34;&gt;https://zhuanlan.zhihu.com/p/166393579&lt;/a&gt;&lt;/p&gt;
">【ML】决策树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/opencv-qian-ji/"" data-c="
          &lt;h1 id=&#34;matplotlib-显示-opencv-图像失真原因&#34;&gt;matplotlib 显示 opencv 图像失真原因&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Strive_For_Future/article/details/108566534&#34;&gt;https://blog.csdn.net/Strive_For_Future/article/details/108566534&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br&gt;
opencv 在 anaconda 中文件夹的名称叫 cv2&lt;br&gt;
可在编译器中输入 cv2.path 来查看 cv2 安装地址，从而找到对应的算法文件&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.lsbin.com/7111.html&#34;&gt;如何使用OpenCV截取图片指定区域？&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/fjswcjswzy/article/details/105881899&#34;&gt;cv2.selectROI：框取指定区域&lt;/a&gt;&lt;/p&gt;
">OpenCV 浅记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/jupyter-notebook-de-anaconda-pei-zhi/"" data-c="
          &lt;p&gt;下载anaconda之后，用pycharm分配虚拟环境自己摸索一下就会了&lt;br&gt;
但是jupyter一直只有一个虚拟环境，于是上网搜索了一下&lt;br&gt;
jupyter需要手动分配内核，&lt;strong&gt;具体参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_44799217/article/details/116056976&#34;&gt;https://blog.csdn.net/weixin_44799217/article/details/116056976&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/81605893&#34;&gt;https://zhuanlan.zhihu.com/p/81605893&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;每次创建虚拟环境的时候，两步配置jupyter内核：&lt;/p&gt;
&lt;p&gt;pip install -i https://pypi.tuna.tsinghua.edu.cn/simple ipykernel # 在该虚拟环境下安装 ipykernel 包&lt;br&gt;
python -m ipykernel install --name 环境名 # 向 jupyter 中添加虚拟内核&lt;/p&gt;
">Jupyter notebook 的 Anaconda 配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/cmd/"" data-c="
          &lt;p&gt;&lt;strong&gt;cmd 中 curl 命令的使用&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/zhuzhenwei918/p/6781314.html&#34;&gt;https://www.cnblogs.com/zhuzhenwei918/p/6781314.html&lt;/a&gt;&lt;/p&gt;
">cmd</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/ji-zu-qian-ji/"" data-c="
          &lt;h1 id=&#34;思维导图&#34;&gt;思维导图&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/98226508&#34;&gt;https://zhuanlan.zhihu.com/p/98226508&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_47423314/article/details/114875087&#34;&gt;https://blog.csdn.net/weixin_47423314/article/details/114875087&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/read/cv5340324/&#34;&gt;https://www.bilibili.com/read/cv5340324/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进制转换&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/a9254778/article/details/8513086&#34;&gt;https://blog.csdn.net/a9254778/article/details/8513086&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器字长、指令字长、存储字长&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_43627631/article/details/106738058&#34;&gt;https://blog.csdn.net/qq_43627631/article/details/106738058&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ALU&lt;/strong&gt;&lt;br&gt;
算术逻辑单元（Arithmetic&amp;amp;logical Unit）是中央处理器(CPU)的执行单元，是所有中央处理器的核心组成部分，由&amp;quot;And Gate&amp;quot;（与门） 和&amp;quot;Or Gate&amp;quot;（或门）构成的算术逻辑单元，主要功能是进行二位元的算术运算，如加减乘(不包括整数除法)。基本上，在所有现代CPU体系结构中，二进制都以补码的形式来表示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weibo1230123/article/details/83106141&#34;&gt;CPU中的主要寄存器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/vavid317/article/details/110946947&#34;&gt;Cache 主存映射&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;第四章-指令系统&#34;&gt;第四章 指令系统&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;操作数：&lt;/strong&gt; 地址码指向的真实数据&lt;/p&gt;
">计组浅记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/pykeyboard-he-pymouse-zi-dong-hua-cao-zuo/"" data-c="
          &lt;h1 id=&#34;三篇参考文章&#34;&gt;三篇参考文章：&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_51802807/article/details/121179861&#34;&gt;https://blog.csdn.net/weixin_51802807/article/details/121179861&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/zjutlitao/p/10188434.html&#34;&gt;https://www.cnblogs.com/zjutlitao/p/10188434.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/137133751&#34;&gt;https://zhuanlan.zhihu.com/p/137133751&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;技巧&#34;&gt;技巧：&lt;/h1&gt;
&lt;p&gt;用cmd命令打开网页，这种方法可以省去鼠标操作可能带来的延迟，而且可以运行电脑上任何位置的程序&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/yekui/article/details/83802667&#34;&gt;https://blog.csdn.net/yekui/article/details/83802667&lt;/a&gt;&lt;br&gt;
start 网站 （用该语法打开网站）&lt;br&gt;
下面给出代码演示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pykeyboard import *
import time   # 连续进行两个动作可能太快而效果不明显，因此加入暂停时间

k = PyKeyboard() #建立键盘对象

k.press_key(k.windows_l_key)  # 按住Win键
k.tap_key(&#39;r&#39;)  # 点击r键
k.release_key(k.windows_l_key)  # 松开Win键
time.sleep(0.2)  # 需等待界面跳转，0.2是极限，0.1就不好用了
k.tap_key(k.enter_key)

time.sleep(0.2)
k.type_string(&#39;start https://www.bilibili.com/?spm_id_from=333.999.b_696e7465726e6174696f6e616c486561646572.1&#39;)
k.tap_key(k.enter_key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，用cmd更便于打开本地的文件，只需复制文件地址一步打开，下面给出演示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pymouse import *    # 模拟鼠标所使用的包
from pykeyboard import *
import pyperclip
import time   # 连续进行两个动作可能太快而效果不明显，因此加入暂停时间

m = PyMouse()   # 鼠标的实例m
k = PyKeyboard() #建立键盘对象
x_dim, y_dim = m.screen_size()


k.press_key(k.windows_l_key)  # 按住win键
k.tap_key(&#39;r&#39;)  # 点击r键
k.release_key(k.windows_l_key)  # 松开win 键
time.sleep(0.5)
k.tap_key(k.enter_key)

pyperclip.copy(r&amp;quot;C:\Users\ZJL\Desktop\软件\Firefox.lnk&amp;quot;)
time.sleep(0.5)
k.press_key(k.control_key)
k.tap_key(&#39;v&#39;)
k.release_key(k.control_key)
k.tap_key(k.enter_key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里要说明的是，pykeyboard不能输入中文，需要用pyperclip对字符串进行copy，然后模拟键盘CTRL cv&lt;/p&gt;
&lt;h1 id=&#34;另外注意&#34;&gt;另外注意：&lt;/h1&gt;
&lt;p&gt;1）pykeyboard 组合键使用时，需要用小写字母&lt;br&gt;
&lt;strong&gt;例如：&lt;/strong&gt;&lt;br&gt;
模拟 alt+z&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;k.press_key(k.alt_key)  # 按住Alt键
k.tap_key(&#39;z&#39;)  # 点击z键
k.release_key(k.alt_key)  # 松开Alt键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）用 m.position() 获取当前鼠标位置坐标&lt;br&gt;
3）需要引入time模块，调整触发时间&lt;/p&gt;
">Pykeyboard 和 Pymouse 自动化操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/pa-chong-curl-zhuan-wei-python-pa-chong-dai-ma/"" data-c="
          &lt;p&gt;&lt;a href=&#34;http://tool.yuanrenxue.com/curl&#34;&gt;http://tool.yuanrenxue.com/curl&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.kemaowang.org.cn/n/197417.html&#34;&gt;十大爬虫软件排行（好用的爬虫软件推荐）&lt;/a&gt;&lt;/p&gt;
">【爬虫】curl转为python爬虫代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/markdown-yu-fa/"" data-c="
          &lt;h1 id=&#34;官方教程&#34;&gt;官方教程：&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://markdown.com.cn/basic-syntax/paragraphs.html&#34;&gt;https://markdown.com.cn/basic-syntax/paragraphs.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;常用&#34;&gt;常用:&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;主标题&lt;/strong&gt;&lt;br&gt;
‘#’ + 字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加粗&lt;/strong&gt;&lt;br&gt;
’** ‘ + 字符+ ’**‘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;换行&lt;/strong&gt;&lt;br&gt;
Markdown 换行语法 在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行 (&lt;br&gt;
)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加链接&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://markdown.com.cn/basic-syntax/links.html&#34;&gt;https://markdown.com.cn/basic-syntax/links.html&lt;/a&gt;&lt;/p&gt;
">Markdown 语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/leetcode-1323-6-he-9-zu-cheng-de-zui-da-shu-zi/"" data-c="
          &lt;p&gt;给你一个仅由数字 6 和 9 组成的正整数 num。&lt;/p&gt;
&lt;p&gt;你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。&lt;/p&gt;
&lt;p&gt;请返回你可以得到的最大数字。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：num = 9669&lt;br&gt;
输出：9969&lt;br&gt;
解释：&lt;br&gt;
改变第一位数字可以得到 6669 。&lt;br&gt;
改变第二位数字可以得到 9969 。&lt;br&gt;
改变第三位数字可以得到 9699 。&lt;br&gt;
改变第四位数字可以得到 9666 。&lt;br&gt;
其中最大的数字是 9969 。&lt;br&gt;
示例 2：&lt;/p&gt;
&lt;p&gt;输入：num = 9996&lt;br&gt;
输出：9999&lt;br&gt;
解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。&lt;br&gt;
示例 3：&lt;/p&gt;
&lt;p&gt;输入：num = 9999&lt;br&gt;
输出：9999&lt;br&gt;
解释：无需改变就已经是最大的数字了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;提示：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1 &amp;lt;= num &amp;lt;= 10^4&lt;br&gt;
num 每一位上的数字都是 6 或者 9 。&lt;/p&gt;
&lt;h1 id=&#34;my-solution&#34;&gt;My Solution：&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def maximum69Number (self, num):
            list1 = []
            stnum = list(str(num))
            for i in range(len(stnum)):
                stnum = list(str(num))
                stnum[i] = &#39;9&#39;
                list1.append(&#39;&#39;.join(stnum))
            return int(max(list1))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;python的简单方法&#34;&gt;Python的简单方法：&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def func(num):
    return int(str(num).replace(&#39;6&#39;,&#39;9&#39;,1))
print(func(9669))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用replace函数，替换第一个6。根据贪心思想，把最前面的一个6替换为9即可得到最大值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本题总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;int 为不可迭代对象，str可&lt;/li&gt;
&lt;li&gt;join函数的用法&lt;/li&gt;
&lt;li&gt;贪心思想&lt;/li&gt;
&lt;/ol&gt;
">【leetcode】1323. 6 和 9 组成的最大数字</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/lan-qiao-bei-zui-xiao-ju-chi-python/"" data-c="
          &lt;p&gt;&lt;strong&gt;资源限制&lt;/strong&gt;&lt;br&gt;
时间限制：1.0s 内存限制：256.0MB&lt;br&gt;
　　最小距离&lt;br&gt;
　　&lt;br&gt;
&lt;strong&gt;问题描述&lt;/strong&gt;&lt;br&gt;
　　数轴上有n个数字，求最近的两个数，即min(abs(x-y))&lt;br&gt;
　　&lt;br&gt;
&lt;strong&gt;输入格式&lt;/strong&gt;&lt;br&gt;
　　第一行包含一个整数n。&lt;br&gt;
　　接下来一行，表示n整数。&lt;br&gt;
　　&lt;br&gt;
&lt;strong&gt;输出格式&lt;/strong&gt;&lt;br&gt;
　　一个整数表示最小距离&lt;br&gt;
　　&lt;br&gt;
&lt;strong&gt;样例输入&lt;/strong&gt;&lt;br&gt;
6&lt;br&gt;
7 3 4 11 9 17&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例输出&lt;/strong&gt;&lt;br&gt;
1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例说明&lt;/strong&gt;&lt;br&gt;
　　取3和4&lt;br&gt;
　　&lt;br&gt;
&lt;strong&gt;数据规模和约定&lt;/strong&gt;&lt;br&gt;
　　n&amp;lt;=100000&lt;br&gt;
　　所有整数&amp;lt;=10^7&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本题要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入格式：a = list(map(int, input().split())) 空格分隔&lt;br&gt;
两次for循环复杂度过大，不能通过，采取先排序，再算min的方法&lt;/p&gt;
&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n = int(input())
numlist = list(map(int, input().split()))
numlist.sort()
min = float(&#39;inf&#39;)  # min初始值设为正无穷
for i in range(1, n):
    value = numlist[i] - numlist[i-1]
    if value &amp;lt; min:
        min = value
print(min)
&lt;/code&gt;&lt;/pre&gt;
">【蓝桥杯】最小距离 - Python</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/next-zhu-ti-shi-yong-jiao-cheng/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://yeming.site/post/1JA_OJlig/&#34;&gt;https://yeming.site/post/1JA_OJlig/&lt;/a&gt;&lt;/p&gt;
">Next主题使用教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/the-first-article/"" data-c="
          &lt;p&gt;第一篇文章!&lt;/p&gt;
&lt;p&gt;本站于2022/1/25正式成立&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4001/post-images/1648733500854.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">The First Article</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/about/"" data-c="
          &lt;p&gt;welcome！&lt;/p&gt;
&lt;h2 id=&#34;jerome-的个人网站-佛系更新&#34;&gt;🏠 Jerome 的个人网站 | 佛系更新&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://team.byrio.work/&#34;&gt;BYR 系列网站&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://ec.jray.xyz/&#34;&gt;BUPT 空教室查询&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;悄咪咪夹带私货&#34;&gt;悄咪咪夹带私货&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;放两张图片可以作为博客 背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;赛博朋克主题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://img.3dmgame.com/uploads/images/news/20201216/1608109166_366000.jpg&#34;&gt;赛博房间1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://img.3dmgame.com/uploads/images/news/20200914/1600072653_344511.jpg&#34;&gt;赛博房间2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://tse1-mm.cn.bing.net/th/id/R-C.0b7b7f15b83e7326de9078d0998d5eac?rik=KDIsnoDnAZ%2b5mw&amp;amp;riu=http%3a%2f%2fwww.obzhi.com%2fwp-content%2fuploads%2f2020%2f09%2fkejigan.jpg&amp;amp;ehk=6nuckhqgEl%2fAyE7ZDxsZnTs1%2bLpurRBJEk6V%2fhbe1cw%3d&amp;amp;risl=&amp;amp;pid=ImgRaw&amp;amp;r=0&#34;&gt;赛博房间3 这个超酷！！&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://tse1-mm.cn.bing.net/th/id/R-C.d64c8f7bf000786740b9be4a0731c8b0?rik=F23wyPNFdcYDzA&amp;amp;riu=http%3a%2f%2fi0.hdslb.com%2fbfs%2farchive%2f42a67c4c29a152ed9496f2f459dd1b4ede9a2659.jpg&amp;amp;ehk=mXdqZreTLQwnvxqIp2jmV7nU9MivTInwzvOWBX8tXjQ%3d&amp;amp;risl=&amp;amp;pid=ImgRaw&amp;amp;r=0&#34;&gt;赛博房间4 这个是我最喜欢壁纸的平替！&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://tse1-mm.cn.bing.net/th/id/R-C.d05131b1eed12bd35ef5ebc1b44a2bd5?rik=Wq3EEaINBRSCpg&amp;amp;riu=http%3a%2f%2fi2.hdslb.com%2fbfs%2farchive%2ff423317e628a2b0d323a72e47c87061709c4da61.jpg&amp;amp;ehk=PzA5T9xku%2feJAab8nvE2oFcsmmZFcRAk%2bf9iQHUKUyg%3d&amp;amp;risl=&amp;amp;pid=ImgRaw&amp;amp;r=0&#34;&gt;赛博房间5 绚烂版&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://tse1-mm.cn.bing.net/th/id/R-C.4f518eb58b5be4c0c51de8d535e0f4c3?rik=SdDpw9hBq6IUrg&amp;amp;riu=http%3a%2f%2fi0.hdslb.com%2fbfs%2farchive%2f84c424a45e06f7e099a7c8fa2a9ba08d9c230c2a.jpg&amp;amp;ehk=L5SoLj6%2b4pysTCpz1QxgD5ywSXOrCwPjcki0oDptfak%3d&amp;amp;risl=&amp;amp;pid=ImgRaw&amp;amp;r=0&#34;&gt;赛博房间6 又是一个喜欢的壁纸&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://tse1-mm.cn.bing.net/th/id/R-C.c4c224c431cdb2cfd70150e8e13955ff?rik=I5xqEwEGkWHq3g&amp;amp;riu=http%3a%2f%2fup.desktx.net%2fpic%2f26%2fb1%2fa1%2f26b1a186df16bfaa83754085a32bbc9b.jpg&amp;amp;ehk=4sIJUj6AIsD%2bRJOc3Vdns0KZrimsuhrg0jXmjYxVThI%3d&amp;amp;risl=&amp;amp;pid=ImgRaw&amp;amp;r=0&#34;&gt;赛博房间7&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://yxbao-img.xiazaibao2.com/patch/image/201911/12/27fa377303.jpg&#34;&gt;国风房间&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://tse1-mm.cn.bing.net/th/id/R-C.8af0a7c2c80b8d3b02f0bd8f0d159331?rik=c8cbKRpcqg7vmA&amp;amp;riu=http%3a%2f%2fup.desktx.net%2fpic_360%2f1d%2f91%2faa%2f1d91aaa58f2afcc5e2b0411c0c3b0ca0.jpg&amp;amp;ehk=W9aEoqN9K6yJWm4rczzIWtFDUF%2fbryueo1g0lEFoHbo%3d&amp;amp;risl=&amp;amp;pid=ImgRaw&amp;amp;r=0&amp;amp;sres=1&amp;amp;sresct=1&#34;&gt;赛博大厅&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://pic3.zhimg.com/v2-2eca64da78d43daca1e085c5a7688b3c_r.jpg&#34;&gt;赛博构图 这张很nice很有感觉！！&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://img.zcool.cn/community/01b96a5e86071da80120a89528e00c.jpg@1280w_1l_2o_100sh.jpg&#34;&gt;赛博city1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://pic1.zhimg.com/v2-02fef084396c04290fd94fedaba5a8f0_r.jpg&#34;&gt;赛博city2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://pic3.zhimg.com/v2-be45a8574cec110668120b88a568e9af_1200x500.jpg&#34;&gt;赛博city3&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://pic1.zhimg.com/v2-b0277265665a7c6fca4782a8fcd50fd8_r.jpg&#34;&gt;赛博city4&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://pic4.zhimg.com/v2-60a102c86ce742c5f588687dbbe989d3_r.jpg&#34;&gt;赛博city5 成都太古里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;其他房间主题&lt;/code&gt; （我好像很喜欢房间？？&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://image.lnstzy.cn/aoaodcom/2020-08/04/20200804022855d8a3bc046d0ecb0189247bd82fb31d45.jpg.h700.jpg&#34;&gt;夏日房间&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://cdn.max-c.com/heybox/dailynews/img/051d4a61594116698e004a4f1c2208ac.jpg?imageMogr2/format/jpg&#34;&gt;电子厨房&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4001/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = 'en';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>







</html>