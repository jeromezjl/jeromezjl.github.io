<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jeromezjl.github.io</id>
    <title>Jerome</title>
    <updated>2022-04-13T01:19:02.147Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jeromezjl.github.io"/>
    <link rel="self" href="https://jeromezjl.github.io/atom.xml"/>
    <subtitle>Jerome&apos;s blog</subtitle>
    <logo>https://jeromezjl.github.io/images/avatar.png</logo>
    <icon>https://jeromezjl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Jerome</rights>
    <entry>
        <title type="html"><![CDATA[【ML】Hopfield 神经网络]]></title>
        <id>https://jeromezjl.github.io/post/ml-hopfield-shen-jing-wang-luo/</id>
        <link href="https://jeromezjl.github.io/post/ml-hopfield-shen-jing-wang-luo/">
        </link>
        <updated>2022-04-11T02:16:51.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【考研】考研资料]]></title>
        <id>https://jeromezjl.github.io/post/kao-yan-kao-yan-zi-liao/</id>
        <link href="https://jeromezjl.github.io/post/kao-yan-kao-yan-zi-liao/">
        </link>
        <updated>2022-04-09T05:42:47.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://qzbltushu.ysepan.com/">http://qzbltushu.ysepan.com/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Github Desktop 同步 Gridea 踩坑记录]]></title>
        <id>https://jeromezjl.github.io/post/shi-yong-github-desktop-tong-bu-gridea-cai-keng-ji-lu/</id>
        <link href="https://jeromezjl.github.io/post/shi-yong-github-desktop-tong-bu-gridea-cai-keng-ji-lu/">
        </link>
        <updated>2022-04-08T14:08:32.000Z</updated>
        <content type="html"><![CDATA[<p>先放一篇其他大佬的文章，说的已经很详细了<br>
<a href="https://sonatta.top/post/Ux6xKOeOx/">https://sonatta.top/post/Ux6xKOeOx/</a></p>
<p><code>踩坑：</code><br>
写好博客直接把 output push 上去，导致 url 为本地地址，无法打开</p>
<p><code>这里再总结一下</code><br>
在 gridea 中写好之后，点击同步，不用管是否同步成功，同步是为了生成正确的 url<br>
等待大约 15 - 20 s之后，文件已经生成成功。</p>
<p>这时，找到站点源文件的 output 文件夹，打开文件夹<br>
复制里面所有内容，粘贴到从 GitHub 上 Pull 下来的文件夹中。<br>
这时 Github Desktop 中会出现刚才新添加的项目<br>
然后注意一定要填写 summary 名称，否则不能 Push<br>
填写之后，就可以 Push 上去了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github Desktop 管理本地代码]]></title>
        <id>https://jeromezjl.github.io/post/github-desktop-guan-li-ben-di-dai-ma/</id>
        <link href="https://jeromezjl.github.io/post/github-desktop-guan-li-ben-di-dai-ma/">
        </link>
        <updated>2022-04-08T12:22:41.000Z</updated>
        <content type="html"><![CDATA[<p><code>总览</code><br>
<a href="https://www.bilibili.com/video/BV13W411U7HY?from=search&amp;seid=9646375911820432461&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV13W411U7HY?from=search&amp;seid=9646375911820432461&amp;spm_id_from=333.337.0.0</a></p>
<p><code>当需要 push 的文件过大时候报错：</code><br>
<a href="https://stackoverflow.com/questions/69427700/error-rpc-failed-curl-55-send-failure-connection-was-aborted">https://stackoverflow.com/questions/69427700/error-rpc-failed-curl-55-send-failure-connection-was-aborted</a></p>
<p><code>GitHub教程 仓库的创建、同步、删除</code><br>
<a href="https://www.likecs.com/show-204599371.html">https://www.likecs.com/show-204599371.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【计网】Socket 编程实验]]></title>
        <id>https://jeromezjl.github.io/post/ji-wang-socket-bian-cheng-shi-yan/</id>
        <link href="https://jeromezjl.github.io/post/ji-wang-socket-bian-cheng-shi-yan/">
        </link>
        <updated>2022-04-01T10:20:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文档：</strong><br>
<a href="https://m653uatd6t.feishu.cn/docs/doccnBhfhSQ8wZ3krkTnQ3GbDHf#KJ735Z">https://m653uatd6t.feishu.cn/docs/doccnBhfhSQ8wZ3krkTnQ3GbDHf#KJ735Z</a><br>
<strong>参考文章：</strong><br>
<a href="https://zhuanlan.zhihu.com/p/387279376">https://zhuanlan.zhihu.com/p/387279376</a></p>
<p><code>服务器端代码：</code></p>
<pre><code class="language-python">import random
from socket import *
# 使用 AF_INET 套接字家族，SOCK_DGRAM 代表面向非连接（UDP）
serverSocket = socket(AF_INET, SOCK_DGRAM)

# 将 socket 绑定在本机 IP 的 10000 端口
serverSocket.bind(('127.0.0.1', 10000))

while True:
    # 生成一个 [1, 10] 的随机数，包含两端
    rand = random.randint(1, 10)
    # 将收到的 packet 中的数据存入 message，将地址存入 address（客户端地址）
    message, address = serverSocket.recvfrom(1024)
    # 下面是对收到的 message 进行处理
    # 将 bytes 类型的 message 转换为 string 类型
    message_str = message.decode('utf-8')
    # 在 30% 的概率下丢弃收到的 packet
    if rand &lt; 4:
        continue
    # 对收到的 message 做简单处理
    ret = '{' + message_str + '}'
    # 做出响应（将处理后的数据通过sendto函数送回客户端），注意还要将 string 编码为 bytes 类型
    serverSocket.sendto(ret.encode(), address)
</code></pre>
<p><code>客户端代码</code></p>
<pre><code class="language-python">from socket import *
import time

# SOCK_DGRAM 表示使用UDP协议
client = socket(AF_INET, SOCK_DGRAM)
# 设置超时时间为1秒
client.settimeout(1)
# 服务端的ip和端口
server_address = ('152.136.19.235', 10000)
for i in range(10):
    # 发送ping命令
    client.sendto(b&quot;2020212487&quot;, server_address)
    send_time = time.time()
    try:
        message, adr = client.recvfrom(1024)
        recv_time = time.time()  # 获取
        print(f&quot;[{i}]\t{message.decode()}\tRTT: {(recv_time - send_time) * 1000:.2f}ms&quot;)
    except timeout as e:  # 超时就打印LOST
        print(f&quot;[{i}]\tLOST&quot;)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 使用]]></title>
        <id>https://jeromezjl.github.io/post/git-shi-yong/</id>
        <link href="https://jeromezjl.github.io/post/git-shi-yong/">
        </link>
        <updated>2022-03-31T13:51:33.000Z</updated>
        <content type="html"><![CDATA[<p><strong>使用 Git 上传文件夹到 Github</strong><br>
<a href="https://zhuanlan.zhihu.com/p/136355306">https://zhuanlan.zhihu.com/p/136355306</a><br>
<a href="https://blog.csdn.net/weixin_45309916/article/details/108273988">https://blog.csdn.net/weixin_45309916/article/details/108273988</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【ML】决策树]]></title>
        <id>https://jeromezjl.github.io/post/ml-jue-ce-shu/</id>
        <link href="https://jeromezjl.github.io/post/ml-jue-ce-shu/">
        </link>
        <updated>2022-03-27T13:27:29.000Z</updated>
        <content type="html"><![CDATA[<p><strong>b站讲解</strong><br>
<a href="https://www.bilibili.com/video/BV1T7411b7DG?from=search&amp;seid=4602675497552466282&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1T7411b7DG?from=search&amp;seid=4602675497552466282&amp;spm_id_from=333.337.0.0</a></p>
<h1 id="决策树的构建">决策树的构建</h1>
<p><strong>C4.5算法</strong></p>
<p><code>参考文章：</code><br>
<a href="https://blog.csdn.net/zjsghww/article/details/51638126">https://blog.csdn.net/zjsghww/article/details/51638126</a></p>
<p><code>算法步骤：</code><br>
1）计算总信息熵 Entropy<br>
2）分别计算每个属性信息熵<br>
3）总信息熵 - 属性信息熵 得到信息增益 Gain(A)<br>
4）计算信息增益率 GainRatio(A) = Gain / Ent<br>
5）增益率max的为根节点</p>
<p><code>注意</code><br>
总信息熵用结果的概率进行计算<br>
属性信息熵：<br>
∑（ p(属性概率) * ∑ -（ p(该属性内成功概率) log2 p + p(该属性内失败概率)log2 p ））</p>
<p><code>习题</code><br>
<a href="https://zhuanlan.zhihu.com/p/166393579">https://zhuanlan.zhihu.com/p/166393579</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenCV 浅记]]></title>
        <id>https://jeromezjl.github.io/post/opencv-qian-ji/</id>
        <link href="https://jeromezjl.github.io/post/opencv-qian-ji/">
        </link>
        <updated>2022-03-22T13:25:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="matplotlib-显示-opencv-图像失真原因">matplotlib 显示 opencv 图像失真原因</h1>
<p><a href="https://blog.csdn.net/Strive_For_Future/article/details/108566534">https://blog.csdn.net/Strive_For_Future/article/details/108566534</a></p>
<p><strong>注意：</strong><br>
opencv 在 anaconda 中文件夹的名称叫 cv2<br>
可在编译器中输入 cv2.path 来查看 cv2 安装地址，从而找到对应的算法文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jupyter notebook 的 Anaconda 配置]]></title>
        <id>https://jeromezjl.github.io/post/jupyter-notebook-de-anaconda-pei-zhi/</id>
        <link href="https://jeromezjl.github.io/post/jupyter-notebook-de-anaconda-pei-zhi/">
        </link>
        <updated>2022-03-22T13:24:19.000Z</updated>
        <content type="html"><![CDATA[<p>下载anaconda之后，用pycharm分配虚拟环境自己摸索一下就会了<br>
但是jupyter一直只有一个虚拟环境，于是上网搜索了一下<br>
jupyter需要手动分配内核，<strong>具体参考：</strong></p>
<p><a href="https://blog.csdn.net/weixin_44799217/article/details/116056976">https://blog.csdn.net/weixin_44799217/article/details/116056976</a><br>
<a href="https://zhuanlan.zhihu.com/p/81605893">https://zhuanlan.zhihu.com/p/81605893</a></p>
<h1 id="总结">总结</h1>
<p>每次创建虚拟环境的时候，两步配置jupyter内核：</p>
<p>pip install ipykernel # 在该虚拟环境下安装 ipykernel 包<br>
python -m ipykernel install --name 环境名 # 向 jupyter 中添加虚拟内核</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cmd]]></title>
        <id>https://jeromezjl.github.io/post/cmd/</id>
        <link href="https://jeromezjl.github.io/post/cmd/">
        </link>
        <updated>2022-03-17T13:23:16.000Z</updated>
        <content type="html"><![CDATA[<p><strong>cmd 中 curl 命令的使用</strong><br>
<a href="https://www.cnblogs.com/zhuzhenwei918/p/6781314.html">https://www.cnblogs.com/zhuzhenwei918/p/6781314.html</a></p>
]]></content>
    </entry>
</feed>