<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jeromezjl.github.io</id>
    <title>Jerome</title>
    <updated>2024-05-20T07:45:31.028Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jeromezjl.github.io"/>
    <link rel="self" href="https://jeromezjl.github.io/atom.xml"/>
    <subtitle>Jerome&apos;s blog</subtitle>
    <logo>https://jeromezjl.github.io/images/avatar.png</logo>
    <icon>https://jeromezjl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, Jerome</rights>
    <entry>
        <title type="html"><![CDATA[【读论文】Seeing Through the Glass Neural 3D Reconstruction of Object Inside a Transparent Container]]></title>
        <id>https://jeromezjl.github.io/post/du-lun-wen-seeing-through-the-glass-neural-3d-reconstruction-of-object-inside-a-transparent-container/</id>
        <link href="https://jeromezjl.github.io/post/du-lun-wen-seeing-through-the-glass-neural-3d-reconstruction-of-object-inside-a-transparent-container/">
        </link>
        <updated>2024-05-20T07:39:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="对标方法">对标方法</h3>
<p>这篇文章对标现有的神经隐式表示方法，特别是Neural Implicit Surface（NeuS）方法【4†source】。NeuS能够在多视角重建中表现出色，但在处理透明容器内部的物体时存在局限性。传统的结构光（Structure from Motion，SfM）和现代神经重建方法在面对透明容器的多重光反射和折射时，无法可靠地重建3D几何结构【4†source】【4†source】。</p>
<h3 id="现有方法的缺点">现有方法的缺点</h3>
<ol>
<li><strong>传统SfM方法</strong>：这些方法在透明介质的多重光反射和折射面前表现不佳，因为它们依赖单一视角的假设【4†source】。</li>
<li><strong>神经隐式表示方法</strong>：虽然这些方法在新视图合成和3D重建任务中表现出色，但它们没有考虑到光的反射。尽管NeRFReN尝试包含反射效应，但无法处理复杂的多重折射和反射场景【4†source】。</li>
</ol>
<h3 id="文章解决的问题">文章解决的问题</h3>
<p>这篇文章提出了一种新的研究问题：从多个2D视图重建透明容器内物体的3D几何形状【4†source】。透明容器会导致严重的图像畸变，现有的多视角3D重建方法难以解决这个问题。因此，本文旨在通过显式建模场景的内部和外部空间，解决光在不同介质间的复杂交互，最终实现对透明容器内部物体的高质量3D重建【4†source】【4†source】。</p>
<h3 id="创新点">创新点</h3>
<ol>
<li><strong>新问题定义</strong>：首次定义了透明容器内物体的3D重建问题【4†source】。</li>
<li><strong>ReNeuS方法</strong>：提出了一种新的3D重建方法ReNeuS，能够处理多重光反射和折射。该方法使用了一种新颖的混合渲染策略，将体渲染与光线追踪相结合【4†source】。</li>
<li><strong>场景分割策略</strong>：通过显式分割场景为内部空间和外部空间，分别对透明容器内外的光交互进行建模【4†source】。</li>
</ol>
<h3 id="实验结果">实验结果</h3>
<p>实验结果表明，ReNeuS在合成数据和真实数据集上的表现均优于现有的SOTA方法【4†source】。具体表现为：</p>
<ol>
<li>在合成数据集上，ReNeuS在有透明容器的情况下能够实现比现有方法更低的Chamfer-L1距离【4†source】。</li>
<li>在真实数据集上，ReNeuS能够成功重建出透明容器内的物体，包括细小的结构，如昆虫的翅膀和触角【4†source】。</li>
</ol>
<p>总体而言，本文在处理透明容器内物体的3D重建问题上取得了显著的进展，提出的方法在多重光交互的复杂场景中展示了强大的能力。</p>
<h3 id="模型的输入输出">模型的输入输出</h3>
<p><strong>输入</strong>：</p>
<ul>
<li>(N) 个姿态已知的图像：这些图像包含了透明矩形盒子中物体的多个视角  。</li>
<li>透明矩形盒子的已知几何形状：模型假设透明盒子的几何形状和位置是已知的，以简化问题【4†source】 。</li>
</ul>
<p><strong>输出</strong>：</p>
<ul>
<li>内部物体的几何形状和体积外观表示：通过优化渲染图像与真实图像之间的差异，模型输出物体的3D重建结果 。</li>
</ul>
<h3 id="模型结构">模型结构</h3>
<p><strong>ReNeuS模型结构</strong>：</p>
<ol>
<li>
<p><strong>场景表示</strong>：</p>
<ul>
<li><strong>内部空间（Sin）</strong>：使用隐式神经网络表示，包含一个用于几何的符号距离函数（SDF）和一个体积辐射表示  。</li>
<li><strong>外部空间（Sout）</strong>：假设为空间，具有均匀的环境光照条件 。</li>
</ul>
</li>
<li>
<p><strong>渲染策略</strong>：</p>
<ul>
<li><strong>光线追踪</strong>：用于模拟光在不同子空间的交互。光线在内部空间中按照体积辐射场的方式传播，通过反射和折射计算反射光线和折射光线 。</li>
<li><strong>体积渲染</strong>：结合光线追踪技术，处理光在线与外部空间交互时的传播路径  。</li>
</ul>
</li>
<li>
<p><strong>损失函数</strong>：</p>
<ul>
<li><strong>颜色损失（Lcolor）</strong>：通过L1损失函数计算渲染像素颜色与真实像素颜色之间的差异 。</li>
<li><strong>透射损失（Ltrans）</strong>：利用稀疏先验来正则化内部空间的透射率，确保大部分内部空间是透明的 。</li>
<li><strong>正则化损失（Lreg）</strong>：使用Eikonal正则化来正则化几何MLP 。</li>
</ul>
</li>
</ol>
<h3 id="模型优化过程">模型优化过程</h3>
<ol>
<li>对每个像素生成一个相机光线，并根据相应的相机姿态进行光线追踪。</li>
<li>将场景分割为内部空间和外部空间，并分别处理这些空间中的光线交互。</li>
<li>通过体积渲染和光线追踪的混合渲染策略，计算光线在内部和外部空间中的传播路径，并累积得到最终的像素颜色。</li>
<li>最后，通过最小化渲染图像与真实图像之间的差异，优化模型参数  。</li>
</ol>
<p>通过以上结构和优化过程，ReNeuS模型能够在透明容器内物体的3D重建任务中表现出色，解决了现有方法在处理复杂光线反射和折射问题上的不足。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【读论文】S3-NeRF]]></title>
        <id>https://jeromezjl.github.io/post/du-lun-wen-s3-nerf/</id>
        <link href="https://jeromezjl.github.io/post/du-lun-wen-s3-nerf/">
        </link>
        <updated>2024-05-20T07:16:58.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://ywq.github.io/s3nerf/">原文链接</a></p>
<p>S3-NeRF: Neural Reflectance Field from Shading and Shadow under a Single Viewpoint<br>
单视点下基于阴影和影子的神经反射场</p>
<p><strong>对标方法</strong></p>
<p>这篇文章对标的方法主要是现有的多视角重建和单视角重建方法。具体来说，与多视角重建（如NeRF）和单视角重建（如光度立体法和影子形状法）相比，该方法通过从单个视点下不同点光源的单视图图像来学习神经场表示，从而解决了现有方法的一些局限性。</p>
<p><strong>现有方法的缺点</strong></p>
<p>现有单视角重建方法（例如光度立体法和影子形状法）有以下几个缺点：</p>
<ol>
<li><strong>只能恢复2.5D场景表示</strong>：现有单视角方法通常只能恢复可见表面的法线或深度图，无法描述背面和被遮挡的表面。</li>
<li><strong>处理深度不连续性困难</strong>：使用表面法线表示的方法在处理深度不连续性时存在困难。</li>
</ol>
<p><strong>文章解决的问题</strong></p>
<p>这篇文章提出了一种基于单视角不同点光源图像的神经反射场表示方法，解决了以下问题：</p>
<ol>
<li><strong>完整的3D几何和BRDF恢复</strong>：通过利用单视角图像中的阴影和影子线索，该方法能够从单视角图像中恢复场景的3D几何和BRDF，包括可见和不可见部分。</li>
<li><strong>深度不连续性鲁棒性</strong>：采用神经反射场表示，使方法在处理深度不连续性时更加鲁棒。</li>
<li><strong>支持新视角合成和重光照</strong>：由于神经反射场表示的灵活性，该方法能够支持新视角合成和重光照等应用。</li>
</ol>
<p><strong>创新点</strong></p>
<ol>
<li><strong>神经反射场优化</strong>：首次提出利用单视角图像中的阴影和影子线索进行神经反射场优化的方法。</li>
<li><strong>物理渲染和在线影子计算</strong>：结合表面几何和BRDF模型，通过物理渲染计算3D点颜色，并通过光线追踪计算光线可见性以实现在线影子计算，从而充分利用了信息丰富的阴影和影子线索。</li>
</ol>
<p><strong>实验结果</strong></p>
<p>实验结果表明，该方法在多个具有挑战性的数据集上能够准确重建完整的场景几何，包括可见和不可见部分，并且在处理深度不连续性方面表现出色。此外，该方法支持新视角合成和重光照应用。实验结果的详细数据和对比分析可以在文章的实验部分找到。</p>
<p>具体来说，实验结果展示了在重光照和法线估计任务上的优越表现，例如在多个数据集上，该方法相较于现有方法在PSNR和MAE指标上均表现更优【4†source】。</p>
<h3 id="模型结构">模型结构</h3>
<p>这篇文章提出的模型主要包括三个关键部分：神经反射场表示、基于物理的颜色渲染和在线阴影计算。以下是模型结构的详细介绍，包括输入和输出的含义：</p>
<h3 id="1-神经反射场表示-neural-reflectance-field-representation">1. 神经反射场表示 (Neural Reflectance Field Representation)</h3>
<p><strong>输入</strong>：3D点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">x \in \mathbb{R}^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>和观察方向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">d \in \mathbb{R}^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>输出</strong>：占据值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">o(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>和颜色<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">c(x, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></p>
<p>模型采用一个多层感知器（MLP）将3D点和观察方向映射到场景的占据值和颜色。通过体渲染技术，模型可以计算每个像素（或光线）的颜色。</p>
<p>公式如下：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>N</mi><mi>V</mi></msub></msubsup><mi>o</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><msub><mo>∏</mo><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></msub><mo>(</mo><mn>1</mn><mo>−</mo><mi>o</mi><mo>(</mo><msub><mi>x</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo><mi>c</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(r) = \sum_{i=1}^{N_V} o(x_i) \prod_{j&lt;i} (1 - o(x_j)) c(x_i, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.417049em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是沿着光线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>o</mi><mo>+</mo><mi>t</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">r = o + td</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">d</span></span></span></span>采样的3D点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span></span></span></span>是相机中心，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>是由像素指定的光线方向，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">N_V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是每条光线的采样点数 。</p>
<h3 id="2-基于物理的颜色渲染-physics-based-color-rendering">2. 基于物理的颜色渲染 (Physics-based Color Rendering)</h3>
<p><strong>输入</strong>：表面点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>、观察方向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>、光源位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">p_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和光源强度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">L_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><strong>输出</strong>：颜色<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>c</mi></msub><mo>(</mo><mi>d</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>L</mi><mi>e</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_c(d, p_l, L_e; x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p>模型考虑具有空间变化的BRDF（双向反射分布函数）。渲染方程如下：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>c</mi></msub><mo>(</mo><mi>d</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>L</mi><mi>e</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo><mo>=</mo><msub><mi>L</mi><mrow><mi>i</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>L</mi><mi>e</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo><mo>⋅</mo><msub><mi>f</mi><mi>m</mi></msub><mo>(</mo><mi>d</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo><mo separator="true">;</mo><mi>x</mi><mo>)</mo><mo>⋅</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo><mo>⋅</mo><mi>n</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_c(d, p_l, L_e; x) = L_{int}(p_l, L_e; x) \cdot f_m(d, w_i(p_l; x); x) \cdot \max(w_i(p_l; x) \cdot n(x), 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>i</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>L</mi><mi>e</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">L_{int}(p_l, L_e; x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>表示入射光，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">w_i(p_l; x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>是入射光方向，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>m</mi></msub><mo>(</mo><mi>d</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo><mo separator="true">;</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_m(d, w_i(p_l; x); x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>是BRDF值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>是法线   。</p>
<h3 id="3-在线阴影计算-online-shadow-computation">3. 在线阴影计算 (Online Shadow Computation)</h3>
<p><strong>输入</strong>：光源位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">p_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、表面点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和占据值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">o(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p><strong>输出</strong>：光照可见性<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>v</mi></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">,</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_v(p_l, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p>模型通过从表面点到光源位置的光线跟踪来计算光照可见性。公式如下：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>v</mi></msub><mo>(</mo><msub><mi>p</mi><mi>l</mi></msub><mo separator="true">;</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>N</mi><mi>L</mi></msub></msubsup><mi>o</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><msub><mo>∏</mo><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></msub><mo>(</mo><mn>1</mn><mo>−</mo><mi>o</mi><mo>(</mo><msub><mi>x</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f_v(p_l; x) = 1 - \sum_{i=1}^{N_L} o(x_i) \prod_{j&lt;i} (1 - o(x_j))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.417049em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">N_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是沿光线采样的点数 。</p>
<h3 id="模型优化">模型优化</h3>
<p>模型的优化目标是通过图像重建损失来进行优化：</p>
<ol>
<li>
<p>体渲染损失<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">L_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>v</mi></msub><mo>=</mo><mo>∑</mo><mi mathvariant="normal">∥</mi><msub><mi>C</mi><mi>v</mi></msub><mo>−</mo><mi>I</mi><msub><mi mathvariant="normal">∥</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_v = \sum \| C_v - I \|_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">C_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是体渲染的图像，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>是输入图像 。</p>
</li>
<li>
<p>表面渲染损失<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">L_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>s</mi></msub><mo>=</mo><mo>∑</mo><mi mathvariant="normal">∥</mi><msub><mi>C</mi><mi>s</mi></msub><mo>−</mo><mi>I</mi><msub><mi mathvariant="normal">∥</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_s = \sum \| C_s - I \|_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">C_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是表面渲染的颜色 。</p>
</li>
<li>
<p>法线平滑损失<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub><mo>=</mo><mo>∑</mo><mi mathvariant="normal">∥</mi><mi>n</mi><mo>(</mo><msub><mi>x</mi><mi>s</mi></msub><mo>)</mo><mo>−</mo><mi>n</mi><mo>(</mo><msub><mi>x</mi><mi>s</mi></msub><mo>+</mo><mi>ϵ</mi><mo>)</mo><msubsup><mi mathvariant="normal">∥</mi><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">L_n = \sum \| n(x_s) - n(x_s + \epsilon) \|_2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∥</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϵ</span><span class="mclose">)</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>是一个小的随机扰动 。</p>
</li>
</ol>
<p>综合损失函数如下：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><msub><mi>L</mi><mi>v</mi></msub><mo>+</mo><msub><mi>L</mi><mi>s</mi></msub><mo>+</mo><mi>α</mi><msub><mi>L</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L = L_v + L_s + \alpha L_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>通常设为0.005 。</p>
<p>这篇文章通过结合阴影和阴影线索，提出了一种从单视点图像中恢复完整场景几何和BRDF的新方法。这种方法在处理深度不连续性方面表现优越，并支持新视角合成和重新光照等应用。</p>
<h2 id="relative-works">Relative Works</h2>
<p>BRDF是Bidirectional Reflectance Distribution Function的缩写，中文称为双向反射分布函数。它是用于描述物体表面反射特性的一个函数，即在给定入射角和出射角的情况下，物体表面反射光线的分布情况。BRDF函数通常被用来计算在特定角度下的反射光强。<br>
BRDF在计算机图形学、光学、遥感等领域有广泛的应用。例如，在计算机图形学中，BRDF可以帮助模拟物体表面的反射效果，使渲染的图像更加逼真。在遥感领域，BRDF可以用来解释和分析地表反射特性，从而获取地面的信息。</p>
<p><strong>辨析</strong><br>
<strong>Neural Reflectance Field</strong> 和 <strong>Neural Radiance Field</strong> 是两种用于场景重建和表示的不同神经网络模型，它们的主要区别如下：</p>
<h3 id="neural-radiance-field-nerf">Neural Radiance Field (NeRF)</h3>
<p>Neural Radiance Field，简称NeRF，是一种通过多层感知器（MLP）来表示连续3D空间的模型，特别适用于多视图场景重建和新视角合成。它的主要特点包括：</p>
<ol>
<li><strong>输入</strong>：3D点坐标和视角方向。</li>
<li><strong>输出</strong>：3D点的颜色和体积密度。</li>
<li><strong>渲染方式</strong>：通过体渲染技术，累积不同视角下的光线颜色，生成逼真的2D图像。</li>
<li><strong>应用</strong>：主要用于新视角合成和多视图场景重建。</li>
<li><strong>优点</strong>：能够生成高质量的、细节丰富的图像，尤其适用于具有复杂几何形状和光照的场景。</li>
</ol>
<h3 id="neural-reflectance-field-nrf">Neural Reflectance Field (NRF)</h3>
<p>Neural Reflectance Field，是一种结合了反射率（BRDF）和几何信息的模型，适用于从单视点图像中恢复场景的3D几何和材质。它的主要特点包括：</p>
<ol>
<li><strong>输入</strong>：3D点坐标、光源位置和观察方向。</li>
<li><strong>输出</strong>：3D点的颜色和反射率（BRDF）信息。</li>
<li><strong>渲染方式</strong>：采用基于物理的渲染方法，考虑光照、阴影和反射率来计算颜色。</li>
<li><strong>应用</strong>：主要用于单视点图像的3D重建，支持新视角合成和重新光照。</li>
<li><strong>优点</strong>：能够恢复场景的完整3D几何，包括可见和不可见部分，并且在处理深度不连续性和复杂光照效果方面表现优越。</li>
</ol>
<h3 id="区别总结">区别总结</h3>
<ul>
<li><strong>目标不同</strong>：NeRF主要用于多视图场景重建，而NRF则致力于从单视点图像中恢复场景的3D几何和材质。</li>
<li><strong>输入输出不同</strong>：NeRF的输入是3D点和视角方向，输出是颜色和体积密度；NRF的输入是3D点、光源位置和观察方向，输出是颜色和反射率。</li>
<li><strong>渲染方法不同</strong>：NeRF采用体渲染技术，而NRF则使用基于物理的渲染方法来考虑光照和阴影。</li>
</ul>
<p>通过这些区别，可以看出NeRF和NRF各自针对不同的应用场景和需求进行了优化，从而在各自领域中发挥最大的作用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【读论文】NeRFrac]]></title>
        <id>https://jeromezjl.github.io/post/du-lun-wen-nerfrac/</id>
        <link href="https://jeromezjl.github.io/post/du-lun-wen-nerfrac/">
        </link>
        <updated>2024-05-18T03:19:02.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/Yifever20002/NeRFrac">代码链接</a></p>
<p>NeRFrac: Neural Radiance Fields through Refractive Surface<br>
通过折射表面的神经辐射场</p>
<p>通过折射表面捕捉场景的神经新视角合成，典型的例子是水面。对于每条查询光线，基于MLP的折射场被训练用来估计从光线起点到折射表面的距离。在每个交点处，根据输入光线和近似的局部法线，通过斯涅尔定律计算折射光线。场景中的点沿折射光线采样，并被送到辐射场进行进一步的辐射估计。我们展示了从一组稀疏图像中，我们的模型能够准确地实现折射表面下场景的新视角合成，并同时重建折射表面。我们通过在合成和真实的通过水面观察的场景中评估了我们方法的有效性。实验结果表明，NeRFrac在建模通过波动的折射表面看到的场景时具有高精度。</p>
<p><code>一句话总结：</code><br>
NeRFrac 使用稀疏图像，基于折射场显式恢复折射表面（如水面）捕获的场景，改进了原始NeRF无法处理复杂折射表面的缺陷。</p>
<h2 id="whats-the-problem">what's the problem</h2>
<p>NeRF 对非朗伯反射处理不好，由于 NeRF 是沿直线采样，会导致有折射现象时，建模畸变<br>
使用变形层的 NeRF 也不能建模折射，且建模水下的时候，严重失真</p>
<p>NeRFrac<br>
从基本原理建模折射引起的变形的NeRF。我们首先估计折射表面的深度，然后根据斯涅尔定律（Snell）弯曲光线而不是点。我们基于MLP的神经折射场允许直接推断光线与折射表面的交点，并能隐式学习多视角一致性。一旦估计出交点，我们就可以根据斯涅尔定律计算每条折射光线。然后在折射光线上采样3D点，并将其输入我们的水下辐射场。</p>
<h2 id="whats-new">What's new</h2>
<ol>
<li><strong>引入折射场（Refractive Field）</strong>：设计了一个基于MLP的折射场，用于估计从光线起点到折射表面的距离。</li>
<li><strong>物理模型计算折射光线</strong>：在光线与折射表面相交后，利用Snell定律计算折射光线，并在折射光线上采样点进行进一步的辐射估计。</li>
<li><strong>复杂水面数据集</strong>：创建了一个包含真实和合成水面场景的数据集，用于评估方法的有效性。</li>
</ol>
<h2 id="method">Method</h2>
<h3 id="snells-law">Snell's Law</h3>
<p>3D 斯涅尔定律<br>
<img src="https://jeromezjl.github.io/post-images/1716004075379.png" alt="" loading="lazy"></p>
<h3 id="refractive-field">Refractive Field</h3>
<p><img src="https://jeromezjl.github.io/post-images/1716005598962.png" alt="" loading="lazy"><br>
用于估算从输入光线起点到折射表面的距离</p>
<p>Refractive Field（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Ψ</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">Ψ_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）：8 层 MLP（ReLU激活，每层256个通道）<br>
表示为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Ψ</mi><mi>R</mi></msub><mo>(</mo><mi>o</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">Ψ_R(o,v)=d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span><br>
其中：<br>
通过相机内参计算出光线的起点和方向向量，分别表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">o_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">v_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
网络输出每条光线的深度 𝑑，即光线起点到与折射表面交点之间的距离，也就是光线在碰到水面之前走了多远</p>
<p>Refractive Field 具体步骤如下：</p>
<ol>
<li><strong>光线计算和转换</strong>：给定相机的内外参数，计算出光线 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>c</mi></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>=</mo><msub><mi>o</mi><mi>c</mi></msub><mo>+</mo><mi>t</mi><msub><mi>v</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">r_c(t) = o_c + t v_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后将这些光线从平均相机坐标系转换到NDC中。</li>
<li><strong>NDC帧中的表示</strong>：在NDC中，所有光线起点o的z值应该相同，即z = -1（即NDC近平面），而方向向量v应该满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>z</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v_z &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li>
<li><strong>输入到Refractive Field</strong>：起点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span></span></span></span>和方向向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>被送入包含8个全连接层（使用ReLU激活函数，每层256个通道）的Refractive Field <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Ψ</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Psi_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。该网络输出每条光线的深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>。</li>
<li><strong>计算交点</strong>：利用输出的深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>计算光线与折射表面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>的估计交点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">X_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>=</mo><mi>o</mi><mo>+</mo><mi>d</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">r(d) = o + d v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">r(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>即为上述所提到的估计交点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">X_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>计算距离d和交点X的原因：<br>
计算光线起点到折射表面的距离d是为了找到光线在折射表面上的确切位置，也就是交点X。计算交点是为了确定光线在哪里穿过折射表面（如水面）。这个交点是光线发生弯曲的位置，从这个位置开始，光线会按照折射定律改变方向。知道这个交点后，可以准确地模拟光线在水中的路径，从而实现更真实的水下场景渲染。</p>
<h2 id="实验结果">实验结果</h2>
<p>实验结果表明，NeRFrac 在处理复杂波动水面上的场景时，能够实现准确的场景新视图合成和折射表面重建。具体而言：</p>
<ol>
<li><strong>合成数据</strong>：在两种不同形状的合成折射表面数据集上，NeRFrac的表现优于所有基准方法，在PSNR、SSIM和LPIPS指标上均取得了更好的结果。</li>
<li><strong>真实数据</strong>：在真实水面场景数据集上，NeRFrac同样表现出色，能够准确重建折射表面并生成高质量的场景新视图。</li>
</ol>
<h2 id="relative-works">Relative Works</h2>
<p><strong>NDC（normalized device coordinate）</strong><br>
标准化设备坐标（NDC）是一种将三维场景转换为标准化坐标系的方式，使所有坐标都位于一个特定范围内（通常是[-1, 1]）。<br>
转换到NDC中有两个主要原因：<br>
简化计算：在NDC中，所有光线的起点都在相同的平面上（z = -1），这使得计算和插值更简单。<br>
统一表示：NDC提供了一种统一的表示方式，方便不同相机视角的数据进行比较和处理。</p>
<h2 id="英文积累">英文积累</h2>
<p>Refractive 折射<br>
Lambertian surfaces 朗伯表面<br>
interpolate 插入、插值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【读论文】EPPS]]></title>
        <id>https://jeromezjl.github.io/post/du-lun-wen-EPPS/</id>
        <link href="https://jeromezjl.github.io/post/du-lun-wen-EPPS/">
        </link>
        <updated>2024-05-15T15:32:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/GH-HOME/EPPS">代码页</a><br>
title：Edge-preserving Near-light Photometric Stereo with Neural Surfaces<br>
标题：基于神经曲面的保边近光光度立体</p>
<p>abstract：本文提出了一种近光源光度立体方法，该方法在3D重建中能够真实地保留锐利的深度边缘。与依赖于有限差分来近似深度偏导数和表面法线的以往方法不同，我们在近光源光度立体中引入了一种解析可微分的神经表面，从而避免在锐利深度边缘处的微分误差，其中深度被表示为图像坐标的神经函数。通过进一步将朗伯反照率表述为由表面法线和深度得出的依赖变量，我们的方法不易受不准确深度初始化的影响。对合成和真实场景的实验表明，我们的方法在细节形状恢复和边缘保留方面的有效性。</p>
<p>关键词：边缘保留，神经表面，光度立体</p>
<h2 id="whats-the-problem">Whats the problem？</h2>
<p>给定近光源图像观测和校准的点光源位置，近光源光度立体法 (NLPS) 旨在恢复每个场景点的<strong>深度、表面法线和反射率</strong>。由于表面法线与由深度偏导数建模的表面切平面垂直，NLPS 问题自然涉及表面的微分以将其与表面法线关联。</p>
<p>以往的 NLPS 方法以离散方式将深度和表面法线表示为网格图，并依赖有限差分来近似深度偏导数。然而，这种近似在锐利深度边缘处表现不佳，导致表面法线和深度的不一致估计。</p>
<p>为<strong>避免有限差分并实现边缘保留的</strong> NLPS，本文提出使用解析可微分的表面表示。所提方法可以忠实地恢复形状和表面法线，特别是在深度不连续处比现有最先进方法 [24] 表现更好。</p>
<p>我们将深度表示为图像坐标的解析函数，深度偏导数通过函数导数的解析表达式建模。可以从解析函数中获得一致的表面法线和深度，而无需依赖有限差分。除了确保深度和法线的一致性外，解析深度函数在表示复杂和锐利深度边缘方面也很有效。具体来说，我们使用基于可微分神经网络的神经表面表示作为解析深度函数。通过神经表面，我们的 NLPS 方法能够实现细节形状恢复和边缘保留。</p>
<p>此外，通过将反照率视为由表面法线和深度得出的依赖变量，我们的方法在面对不准确的表面初始化时具有鲁棒性。与需要精心形状初始化的以往 NLPS 方法相比，我们的方法在各种初始形状下表现出优越的收敛性，如图1（底部）所示。</p>
<h3 id="对标的方法">对标的方法</h3>
<p>文章对标了现有的一些近光源光度立体（NLPS）方法，特别是以下方法：</p>
<ol>
<li><strong>QD18</strong> [24]</li>
<li><strong>LB20</strong> [14]</li>
<li>其他方法如<strong>SM20</strong> [26]和<strong>MQ16</strong> [17]也在补充材料中有提及</li>
</ol>
<h3 id="现有方法的缺点">现有方法的缺点</h3>
<ol>
<li>
<p><strong>有限差分近似误差</strong>：</p>
<ul>
<li>现有方法依赖于有限差分来近似深度的偏导数和表面法线，这在深度边缘（深度不连续处）会导致误差和不一致的估计。</li>
</ul>
</li>
<li>
<p><strong>对初始深度敏感</strong>：</p>
<ul>
<li>很多现有方法对初始形状估计非常敏感，初始深度设置不准确会导致形状重建的误差。</li>
</ul>
</li>
<li>
<p><strong>边缘保留不足</strong>：</p>
<ul>
<li>很多方法无法在深度边缘处保留锐利的深度变化，这对于详细形状恢复尤其重要。</li>
</ul>
</li>
</ol>
<h3 id="文章解决的问题">文章解决的问题</h3>
<ol>
<li>
<p><strong>引入分析可微的神经表面表示</strong>：</p>
<ul>
<li>通过使用神经网络来表示深度，使得深度和其偏导数都能通过解析表达式得到，从而避免了有限差分近似带来的误差。</li>
</ul>
</li>
<li>
<p><strong>边缘保留</strong>：</p>
<ul>
<li>通过使用神经表面，确保在深度不连续处仍能保持一致的深度和表面法线估计，从而实现边缘保留。</li>
</ul>
</li>
<li>
<p><strong>对初始深度不敏感</strong>：</p>
<ul>
<li>通过将反照率作为表面法线和深度的依赖变量，该方法对初始深度的准确性不敏感，能够在多种初始深度设置下保持收敛到正确的形状。</li>
</ul>
</li>
</ol>
<h2 id="whats-new">What's new?</h2>
<p>我们通过以下两个技术贡献提出了一种准确的 NLPS 方法：</p>
<ol>
<li>在 NLPS 中使用解析神经表面表示以实现准确的形状恢复，特别是在深度不连续处效果显著。</li>
<li>通过将反照率视为依赖变量，我们仅将 NLPS 作为神经表面参数的优化，使我们的方法对各种初始猜测具有鲁棒性。</li>
</ol>
<h2 id="pipeline">Pipeline</h2>
<p><strong>输入：</strong></p>
<ol>
<li>近光源图像观察值</li>
<li>校准好的点光源位置</li>
</ol>
<p><strong>输出：</strong></p>
<ol>
<li>场景每个点的深度</li>
<li>表面法线</li>
<li>反射率（反照率）</li>
</ol>
<p>该模型使用一种分析可微的神经表面表示方法，通过避免在深度边缘进行有限差分来减少误差，以保留3D重建中的锐利深度边缘。通过进一步将Lambertian反照率表示为表面法线和深度的依赖变量，该方法对初始深度的准确性不敏感，能够有效地在合成和现实场景中进行详细的形状恢复，并保留边缘。</p>
<p>根据文章内容，以下是对标的方法、现有方法的缺点、文章解决的问题以及实验结果的总结：</p>
<h3 id="实验结果">实验结果</h3>
<ol>
<li>
<p><strong>合成数据集</strong>：</p>
<ul>
<li>实验使用了五个合成对象（如Tent, Bunny, Buddha等），在这些对象中，作者的方法在深度边缘保留和整体形状恢复方面优于现有方法。</li>
<li>平均表面法线角度误差（MAngE）和深度绝对误差（MAbsE）显著低于对标方法。</li>
</ul>
</li>
<li>
<p><strong>真实世界数据集</strong>：</p>
<ul>
<li>实验使用了捕获的真实数据，包括三个物体（如Stair, Angel, Plato）。</li>
<li>结果表明，作者的方法在深度不连续处（如台阶区域、天使的翅膀和脖子区域、柏拉图的书本区域）比现有方法恢复出更合理的形状。</li>
</ul>
</li>
<li>
<p><strong>LUCES数据集</strong>：</p>
<ul>
<li>该数据集包含了14个具有不同形状和材料的物体，实验结果显示作者的方法在12个物体上比现有方法表现更好，特别是在表面法线和相对深度估计上。</li>
</ul>
</li>
</ol>
<p>通过这些实验结果，文章展示了提出的方法在形状恢复、边缘保留以及对初始深度不敏感方面的优势。</p>
<h2 id="relative-works">Relative Works</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【读论文】Microgeometry Capture using an Elastomeric Sensor]]></title>
        <id>https://jeromezjl.github.io/post/microgeometry-capture-using-an-elastomeric-sensor/</id>
        <link href="https://jeromezjl.github.io/post/microgeometry-capture-using-an-elastomeric-sensor/">
        </link>
        <updated>2024-05-15T14:51:28.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dl.acm.org/doi/10.1145/1964921.1964941">原文链接</a></p>
<p>标题：Microgeometry Capture using an Elastomeric Sensor<br>
翻译：使用弹性传感器进行微几何捕获</p>
<h2 id="abstract">Abstract</h2>
<p>我们描述了一个用于捕捉显微表面几何形状的系统。该系统将逆投影传感器扩展到显微领域，展示了小至2微米的空间分辨率。与现有的微几何捕捉技术不同，该系统不受被测表面光学特性的影响——无论物体是哑光、光滑还是透明，它都能捕捉到相同的几何形状。此外，硬件设计允许多种形态因素，包括一种便携式设备，可用于在现场捕捉高分辨率的表面几何形状。我们通过改进传感器材料、照明设计和重建算法实现了这些方法。</p>
<p>总结：捕捉小至2微米的、任何材质的几何形状</p>
<h2 id="whats-the-problem">What's the problem</h2>
<p>传统的，基于被动或主动扫描的系统通常会被显微尺度上的表面光学性质所混淆。例如，大多数基于主动光扫描的系统假设主体材料是不透明的、漫反射的。虽然这个假设在宏观尺度上通常是成立的，但在微观尺度上通常不成立。例如，纸张在宏观尺度上看起来是哑光的，但当在微观尺度下观察时，单个纤维素纤维是透明且具有镜面反射的。<br>
而现有解决方案，技巧复杂，如白光干涉法或扫描聚焦显微镜。这些基于实验室的设备往往体积大、速度慢、价格昂贵（10万美元或更多）。</p>
<p>Johnson和Adelson提出的逆投影传感器对透明或镜面反射表面带来的问题免疫，因为传感器皮肤施加了一个已知的BRDF。然而，传感器材料、照明设计和重建算法的限制阻止了原始逆投影传感器达到我们系统可能的保真度。本文介绍了一种新的传感器材料、相应的新的照明设计，以及一个新的近场光度立体算法，该算法处理空间变化的照明和投射阴影。这些进步使得测量比以前的系统更准确，并在x和y方向上提高了空间分辨率一个数量级，产生了每毫米2高达100万像素的图像（即每个像素1微米的成像）。这些相同的进步也简化了构建紧凑型现场捕捉表面几何形状的设备的实际操作。我们展示了一个台式配置（图1a）和便携式版本（图1d），两者都是由低成本、容易获得的组件构建的。</p>
<h2 id="whats-new">What's new</h2>
<p>采用了Johnson和Adelson提出的逆投影传感器方法（retrographic sensor approach），并对其进行了扩展</p>
<h2 id="relative-works">Relative works</h2>
<p><strong>BRDF</strong><br>
BRDF是“双向反射分布函数”（Bidirectional Reflectance Distribution Function）的缩写，它是计算机图形学、光学和材料科学中的一个概念，用于描述一个表面如何在一个给定的入射方向上反射光，并在另一个观察方向上被看到。BRDF是一个数学函数，它将四个变量作为输入：入射光的方向、观察方向、入射光的波长以及表面本身的属性，然后输出反射光的强度。<br>
BRDF可以帮助我们理解不同材质和表面在不同光照条件下如何反射光线，这对于在计算机生成的图像中创建真实感光照效果至关重要。例如，在3D渲染和游戏设计中，通过模拟BRDF，可以更加精确地计算出场景中物体表面的光照效果，使得渲染的图像更加接近真实世界中的视觉效果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Blender]]></title>
        <id>https://jeromezjl.github.io/post/blender/</id>
        <link href="https://jeromezjl.github.io/post/blender/">
        </link>
        <updated>2024-05-14T14:57:42.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/349393000">3D神器Blender：从准备入门到跨过门槛（基础操作快查）</a><br>
<a href="https://www.bilibili.com/video/BV14u41147YH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33">【Kurt】Blender零基础入门教程 | Blender中文区新手必刷教程(已完结)</a><br>
<a href="https://www.bilibili.com/video/BV1qq4y1772P/?vd_source=3d9ada7d42c971c0c3f04a22270daf33">Blender完全入门教程 | 一个教程学会Blender，最佳入门教程</a></p>
<h1 id="快捷键">快捷键</h1>
<p>移动：G+(X, Y, Z)<br>
缩放：S+(X, Y, Z)<br>
旋转：R+(X, Y, Z)<br>
着色方式：Z</p>
<p>隐藏：选中+H<br>
没选中的隐藏：shift+H<br>
还原隐藏：Alt+H</p>
<p>还原：Alt+快捷键<br>
右键插销操作</p>
<p>移动并复制：shift+D</p>
<p>切换视图：按住~键</p>
<p>最大化中心面板：ctrl+空格</p>
<p>相机视角预览：F12</p>
<p>关联材质：ctrl+L</p>
<p>快速找到物体：点物体 shift+C</p>
<p><strong>游标</strong><br>
游标位置：shift+右键<br>
移动到游标：选中，shift+s<br>
游标移动到原点：shift+c</p>
<figure data-type="image" tabindex="1"><img src="https://jeromezjl.github.io/post-images/1715752969323.png" alt="" loading="lazy"></figure>
<h1 id="操作">操作</h1>
<p>滚轮调整视角大小<br>
按住滚轮调整视角<br>
点击右上角 xyz 轴切换视图，或按住~键</p>
<p>左边菜单栏，右下角带小箭头的图标可以长按选择操作</p>
<p>在窗口边缘，出现+时，向左拖拽为新增窗口，向右拖拽为合并窗口<br>
新增窗口后，用滚轮选择菜单</p>
<p><strong>调整摄像机位置</strong><br>
选择摄像机，按N<br>
选择视图，选择锁定摄像机<br>
调整视图到合适位置后，取消勾选<br>
调整完毕</p>
<h1 id="一般流程">一般流程</h1>
<p>建模<br>
布光<br>
材质<br>
渲染</p>
<h1 id="render">Render</h1>
<figure data-type="image" tabindex="2"><img src="https://jeromezjl.github.io/post-images/1715763253549.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NeuS]]></title>
        <id>https://jeromezjl.github.io/post/neus/</id>
        <link href="https://jeromezjl.github.io/post/neus/">
        </link>
        <updated>2024-05-13T13:09:00.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lingjie0206.github.io/papers/NeuS/">原文地址</a><br>
<a href="https://www.bilibili.com/video/BV1JM411o7iP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33">论文分享-《NeuS: Learning Neural Implicit Surfaces by Volume Rendering for Multi-vie》</a></p>
<p>把符号距离函数（SDF）作为先验信息，加到密度估计之前</p>
<p>nerf：新视角合成<br>
NeuS、IDR：表面重建</p>
<h1 id="读论文">读论文</h1>
<p>标题：NeuS: Learning Neural Implicit Surfaces by Volume Rendering for Multi-view Reconstruction<br>
翻译：基于体渲染的神经隐式曲面多视图重构学习</p>
<p>input：2D images<br>
output：3D场景</p>
<p>用于多视图表面重建</p>
<h2 id="conclusion">conclusion</h2>
<p>现有的神经表面重建方法，如DVR（Niemeyer等，2020年）和IDR（Yariv等，2020年），需要前景掩码作为监督，容易陷入局部最小值，因此在重建具有严重自遮挡或细薄结构的物体时遇到困难。同时，最近的用于新视角合成的神经方法，如NeRF（Mildenhall等，2020年）及其变体，由于在表示中没有足够的表面约束，所以从这种学习到的隐式表示中提取高质量的表面是困难的。</p>
<p>在NeuS中，我们提出将表面表示为符号距离函数（SDF）的零水平集，并开发了一种新的体渲染方法来训练神经SDF表示。我们观察到，传统的体渲染方法会导致表面重建的固有几何误差（即偏差），因此提出了一种在一阶近似中无偏的新公式，从而即使在没有掩码监督的情况下也能进行更准确的表面重建。</p>
<p><strong>Advantage</strong><br>
DTU数据集和BlendedMVS数据集实验表明，NeuS 能够生成高质量的重建结果，在不需要掩码的情况下，成功重建具有严重遮挡和复杂结构的物体</p>
<p><strong>Drawbacks</strong></p>
<ol>
<li>尽管 NeuS 不严重依赖于纹理特征的对应匹配，但对于无纹理的物体，其性能仍会下降。</li>
<li>NeuS 只有一个用于建模所有空间位置的概率分布标准偏差的单一尺度参数s。因此，一个有趣的未来研究课题是根据不同的局部几何特征，使用不同的方差来建模不同空间位置的概率，并优化场景表示。</li>
<li>大量计算</li>
</ol>
<h2 id="whats-new">What's new</h2>
<p>将3D表面表示为神经符号距离函数（SDF），并开发了一种新的体渲染方法来训练隐式SDF表示</p>
<p><strong>SDF（Signed Distance Field，有符号距离场）</strong><br>
NeuS 使用符号距离函数（SDF）进行表面表示，并采用一种新颖的体渲染方案来学习神经SDF表示。具体而言，通过引入由SDF引导的密度分布，能够将体渲染方法应用于学习隐式SDF表示，从而实现两全其美的效果，即使用神经SDF模型进行准确的表面表示，并在存在深度突变的情况下，通过体渲染实现鲁棒的网络训练。</p>
<p><a href="https://www.bilibili.com/video/BV1Jt4y1x7PJ?p=2&amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33">CV Master基于神经网络的3D重建（NeRF, SDF 等）</a></p>
<p><strong>新体渲染</strong><br>
简单地将标准体渲染方法应用于与SDF相关的密度会导致重建表面出现明显的偏差（即固有的几何误差）。因此，提出了一种新的体渲染方案，以确保在SDF的一阶近似中实现无偏的表面重建。对DTU数据集和BlendedMVS数据集的实验表明，NeuS能够在没有前景掩码监督的情况下，重建具有严重遮挡和细致结构的复杂3D物体和场景。在重建质量方面，它优于最先进的神经场景表示方法，即 IDR 和 NeRF 。</p>
<h2 id="relative-works">Relative Works</h2>
<p>前景掩码（foreground masks）是在图像处理中用于区分前景（感兴趣的物体）和背景的二值图像。前景掩码中的每个像素通常只有两个值：一种值（如1或白色）表示前景，另一种值（如0或黑色）表示背景。前景掩码常用于计算机视觉任务中，如对象检测、分割、跟踪和重建，以帮助算法专注于图像中的目标对象，而忽略背景的干扰。</p>
<p>What is the problem?</p>
<ul>
<li>Input</li>
<li>Output</li>
</ul>
<p>Why do we care?<br>
3DGS vs 2DGS</p>
<ul>
<li>Advantage</li>
<li>Drawbacks</li>
</ul>
<p>What's new</p>
<ul>
<li>Insight</li>
<li>Method</li>
</ul>
<p>What's the experimental results?</p>
<ul>
<li>结果</li>
<li>Speed vs Quality</li>
</ul>
<p>Bring-home message<br>
一句话总结<br>
How this research benefit your project?</p>
<h1 id="英文单词">英文单词</h1>
<p>reconstruction 重建<br>
fidelity 精确度<br>
foreground 前景<br>
sufficient 充足的<br>
inherent 内在的<br>
self-occlusion 自遮挡<br>
abrupt changes 突变<br>
signed 有符号的，有正负之分的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Diffusion]]></title>
        <id>https://jeromezjl.github.io/post/diffusion/</id>
        <link href="https://jeromezjl.github.io/post/diffusion/">
        </link>
        <updated>2024-04-29T13:16:44.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1p8411777A/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33">18【3分钟AI】爆火的Diffusion从何而来？</a><br>
<a href="https://www.bilibili.com/video/BV14c411J7f2/?spm_id_from=333.337.search-card.all.click">扩散模型 - Diffusion Model【李宏毅2023】</a></p>
<h1 id="u-net">U-net</h1>
<p><a href="https://www.bilibili.com/video/BV1oN4y1Y7tB/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3d9ada7d42c971c0c3f04a22270daf33">十分钟讲懂Unet | 中文字幕 | The U-Net (actually) explained in 10 minutes</a></p>
<p>U-Net 最初是为了解决医学图像分割的问题而设计的。由于其在小规模数据集上表现良好，因此它也被广泛应用于其他类型的图像分割任务中。U-Net 的 U 形结构使得网络能够精确地定位分割边界。<br>
U-Net 的核心思想是结合了全卷积网络（FCN）和跳跃连接。网络由一个收缩路径（编码器）和一个对称的扩张路径（解码器）组成。收缩路径用于捕获上下文信息，而扩张路径则用于精确定位分割边界。跳跃连接将编码器中的特征图与解码器中的对应特征图拼接起来，这样可以保留更多的细节信息，有助于提高分割的精度。<br>
U-Net具有以下特点：</p>
<ol>
<li><strong>端到端的训练</strong>：U-Net可以直接从原始图像学习到像素级的分类，不需要额外的预处理或后处理步骤。</li>
<li><strong>较少的训练样本</strong>：由于医学图像数据通常比较难获取，U-Net在小规模数据集上也能取得很好的效果。</li>
<li><strong>高效的内存利用</strong>：U-Net采用了重叠的卷积和池化操作，这样可以减少内存的使用，同时也有助于提高分割的精度。</li>
<li><strong>多尺度的特征融合</strong>：通过跳跃连接，U-Net能够将不同尺度的特征信息融合起来，有助于提高分割的准确性。</li>
</ol>
<h1 id="论文">论文</h1>
<p>Diffusion是《NeurIPS-2020-denoising-diffusion-probabilistic-models-Paper》这篇文章提出的，先来分析一下这篇文章<br>
标题：去噪概率扩散模型</p>
<h1 id="过程">过程</h1>
<p>噪声→denoise→denoise→denoise</p>
<h1 id="相关模型">相关模型</h1>
<p>DALL<br>
CLIP（contrastive language-image pre-training）<br>
Imagen</p>
<p>在过去的一年里，diffusion model火遍整个学术界，而24年初sora的诞生更是让大家看到了diffusion model的无穷潜力。相信不少人都会跟我有一样的疑问：</p>
<p>diffusion model是什么？<br>
diffusion model好在哪里？<br>
diffusion model是怎么来的？<br>
这篇文章里，我将会带着这几个问题，由浅入深地剖析diffusion model的结构、训练过程、数学原理及其发展脉络。因为本人是一个看到太多公式会头疼的人（相信很多人有相同的烦恼），因此与大多数文章不同，本篇文章不会堆砌太多的数学公式，而是从整体入手，先带着大家对diffusion model有一个整体的了解，再逐渐细化到深处，争取让没有数学基础的人也可以轻松看懂。因为本人也是刚刚接触diffusion model，有些地方是基于自己的理解，如果有讲的不对的地方，欢迎大家指出！</p>
<p>Diffusion Model是什么？<br>
概述<br>
Diffusion Model是一种生成模型，所谓生成模型就是能够随机生成观测数据的模型，在很多场景下这种数据都是图片。下图展现了生成模型中的几个经典模型的发展脉络。本文所介绍的diffusion model基本是基于Pieter Abbeel的Denoising Diffusion Probabilistic Models这篇论文[2]。</p>
<p>图1 生成模型概述（来源[1]）<br>
Diffusion Model和其他模型最大的区别我认为有两个，1）diffusion model中的latent code z和图片是同维度的；2）diffusion model的加噪声和去噪过程都是一步一步来的，不是一步到latent code也不是一步从latent code恢复成一张图片。</p>
<p>Diffusion Model的训练简单来说，主要由两个步骤组成：加噪声和去噪声。加噪声就是由图1所示的从<br>
逐渐加噪声到latent code<br>
的过程，这个<br>
在理论上是完全的白噪声，在实际操作中我们加T次噪声就形成了<br>
。注意这里所有操作都没有改变输入的维度。而去噪声是从<br>
一步步去噪恢复到输入<br>
的过程。</p>
<p>前传：加噪声<br>
加噪声准确来说不是加噪声，而是原输入和高斯噪声的一个加权平均，对于每一步<br>
来说，权重分别为<br>
和<br>
。（后文中提到的<br>
）</p>
<p>由独立高斯分布可加性，有<br>
，于是我们可以将(1)式再往前推:</p>
<p>令<br>
，递推到<br>
，有：</p>
<p>这里的<br>
的各种标识是不重要的，因为各种<br>
本质上都是从标准高斯分布中独立采样的噪声，这也是由(1)式推到(2)式的根源。</p>
<p>到这里我们已经知道了任意时刻的<br>
可以由<br>
和一系列的<br>
得到，但是这个<br>
是怎么来的呢？为了使<br>
可以快速收敛到标准高斯分布，原文令<br>
逐渐减小。在DDPM论文[2]中，令<br>
从<br>
到<br>
线性增长，从而使得<br>
线性减小。</p>
<p>由此，我们可以总结得到，加噪声的过程是一个从慢到快逐渐改变原图像，让图像变成最终均值为0，方差为I的标准高斯噪声的过程。</p>
<p>逆过程：去噪<br>
在正向过程中，我们人为设置了T步加噪声过程。而在逆向过程中，我们希望能够倒过来去除所加的噪声，让一幅纯噪声图像变回原始的输入图像。</p>
<p>直接求得去噪操作的理论解是不现实的，我们只能训练神经网络去拟合它。数学原理表明，当<br>
​足够小时，每一步加噪声的逆操作也满足正态分布，即：<br>
那么现在的问题就变成了怎么拟合每一步的<br>
和<br>
。我们知道<br>
和<br>
，那么是否可以列出已知<br>
和<br>
时的<br>
条件分布呢？答案是可以，通过贝叶斯公式，我们可以得到：<br>
看到这里已经可以发现，通过贝叶斯公式，逆向操作的未知分布可以被全部转化为前向操作的已知分布。<br>
由前传的马尔可夫性等价为<br>
，可以由(1)式得到；<br>
和<br>
可以由(2)式得到。代入(4)式，经过计算，简化之后可以得到(3)式中的均值<br>
和方差<br>
：</p>
<p>在(5)式中，逆操作去噪时唯一一个不知道的值是<br>
，因此，我们可以训练神经网络去预测噪声<br>
去拟合生成<br>
的噪声<br>
​。相应的训练loss即为两者的MSE loss:<br>
总结去噪过程：去噪过程就是一步步从<br>
去噪得到<br>
的过程，这个去噪过程实际上是在用神经网络去拟合生成<br>
时的用到的随机噪声<br>
，从而拟合正向过程的逆操作。</p>
<p>训练算法和推断算法<br>
首先看看DDPM的训练算法：</p>
<p>图2 DDPM训练算法<br>
我们来逐行分析训练算法：</p>
<p>第二行是指从训练集里取一个数据<br>
。<br>
第三行是指随机从1到T中取一个时刻用来训练。在前面的分析中，我们虽然希望神经网络从<br>
逐步恢复成为<br>
，但在实际训练时，我们不用一轮预测T个结果，而是只用随机预测T个时刻中某一个时刻的结果就行；当数据量足够大时效果是一样的。<br>
第四行指随机生成一个高斯噪声<br>
，该噪声是用于执行前向过程生成<br>
的。之后，我们把<br>
和<br>
传给神经网络得到<br>
，即为预测噪声。<br>
第五行则进行梯度下降来优化网络，损失函数是预测噪声和实际噪声之间的均方误差。<br>
训练得到网络<br>
（这里的网络结构可以自己定义）之后，就可以从任意一副噪声图中生成图像了，下面是DDPM的推断算法（原文叫做采样算法）：</p>
<p>图3 DDPM推断算法<br>
逐行分析推断算法：</p>
<p>第一行是指生成一个标准高斯噪声。不同的噪声可以生成出不同的图像。<br>
第二～四行是重复进行反向操作，令时刻从T到1，根据（5）式计算每一时刻去噪声操作的均值和方差，从而得到<br>
。<br>
到这里，我们已经了解了Diffusion Model的基本原理、训练及推断过程了。</p>
<p>Diffusion Model好在哪里？<br>
要了解一个模型好在哪里，我们可以先去了解这个模型是怎么诞生的。</p>
<p>Diffusion 扩散模型的第一次提出在 2015 年的 Deep Unsupervised Learning using Nonequilibrium Thermodynamics [3]这篇文章中。但当时，这个扩散模型并没有立刻得到广泛的关注，而是在2020年Pieter Abbeel的Denoising diffusion probabilistic models[2]这篇文章出来之后大家才广泛注意到Diffusion Model的潜力，本文所介绍的算法也是来源于DDPM这篇文章。 Deep Unsupervised Learning using Nonequilibrium Thermodynamics [3]这篇文章是受到非平衡热力学的启发，其基本思想是通过前向扩散过程系统地、缓慢地破坏数据分布中的结构（类似于布朗运动），把原始状态一步步地破坏为混沌态，然后再让机器去学习反向扩散过程，从这片混沌中恢复出原始状态。因为每一步的破坏都足够微小，微小到其逆过程可以被神经网络拟合，所以神经网络才可以在单步逆过程中恢复出一个“以假乱真”的状态。这样微小的破坏可以慢慢“温水煮青蛙”式的导致原状态变为混沌态，那么神经网络每一步微小的拟合也可以一步步的从混沌态“恢复”出一个“以假乱真”的原状态。</p>
<p>图4 Diffusion扩散过程示意图<br>
个人认为Diffusion Model的好就好在它更加接近自然的本质。当我们在谈生成模型时，我们在谈论什么？从一片混沌的噪声中“无中生有”是墒减的过程，是违背自然规律的，正如一滴墨可以在水里扩散开来，但一杯混满了墨的水不能轻易的分成一滴墨和一杯干净的水。但如果每一滴墨在水里的扩散过程可以被完整的记录下来并且我们可以在小范围内去拟合其扩散的逆过程，那么我们就可以一步步的模仿出原来的状态。这里我们模仿出来的状态已经不是原来的那滴墨和那杯水了，但这并不重要，因为我们的目的是让神经网络去拟合这个“墒减”的过程，从而达到“无中生有”的目的。</p>
<p>简单来说，diffusion model把“无中生有”这个看似不可能的任务拆解成了可以一步步完成的简单任务，我们很难从噪声中直接生成图片，但是我们可以先把噪声变的不那么像噪声，然后再一步步的1+1+1...因此扩散模型可以更加真实准确地还原数据，对图像细节的保持能力更强，写实性也更好。但有优点必然有代价，由于其计算步骤的繁琐，扩散模型也存在采样速度较慢的问题。</p>
<p>Diffusion Model的应用<br>
这里先占个坑，之后我不断学习现在diffusion model的各种发展及其应用，会总结到这里。</p>
<p>1.title<br>
2.abstract<br>
3.introduction<br>
4.method<br>
5.experiments<br>
6.conclusion<br>
第一遍：标题、摘要、结论。可以看一看方法和实验部分重要的图和表。这样可以花费十几分钟时间了解到论文是否适合你的研究方向。<br>
第二遍：确定论文值得读之后，可以快速的把整个论文过一遍，不需要知道所有的细节，需要了解重要的图和表，知道每一个部分在干什么，圈出相关文献。觉得文章太难，可以读引用的文献。<br>
第三遍：提出什么问题，用什么方法来解决这个问题。实验是怎么做的。合上文章，回忆每一个部分在讲什么。</p>
<p>Summary: 今天要讲什么，亮点是什么</p>
<p>What is the problem?</p>
<ul>
<li>Input</li>
<li>Output</li>
</ul>
<p>Why do we care?<br>
和其他模型对比</p>
<ul>
<li>Advantage</li>
<li>Drawbacks</li>
</ul>
<p>What's new</p>
<ul>
<li>Insight</li>
<li>Method</li>
</ul>
<p>What's the experimental results?</p>
<ul>
<li>结果</li>
<li>Speed vs Quality</li>
</ul>
<p>Bring-home message<br>
一句话总结<br>
How this research benefit your project?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【摄影】扫街]]></title>
        <id>https://jeromezjl.github.io/post/she-ying-sao-jie/</id>
        <link href="https://jeromezjl.github.io/post/she-ying-sao-jie/">
        </link>
        <updated>2024-04-20T14:24:23.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.sohu.com/a/160831308_417563">用相机扫街时，怎样设定光圈快门组合？</a></p>
<p>除了需要虚化和捕捉快速物体时，用小光圈来获得全局合焦</p>
<p>在阳光灿烂的正午：f/8、1/500、ISO 400</p>
<p>在阳光明媚的午后：f/8、1/250、ISO 400</p>
<p>在阳光明媚的午后，稀疏的树荫底下：f/5.6、1/125、ISO 400</p>
<p>在阳光明媚的午后，浓密的树荫底下：f/4、1/60、ISO 400</p>
<p>多云：f/8、1/125、ISO 400</p>
<p>阴天：f/8、1/60、ISO 400</p>
<p>在地铁车厢里：f/2.8、1/30、ISO 400</p>
<p>室内的商场：f/2.8、1/30、ISO 400</p>
<p>夜晚有路灯的大街上：f/2.8、1/15、ISO 400</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[读论文]]></title>
        <id>https://jeromezjl.github.io/post/du-lun-wen/</id>
        <link href="https://jeromezjl.github.io/post/du-lun-wen/">
        </link>
        <updated>2024-04-15T08:33:14.000Z</updated>
        <content type="html"><![CDATA[<p>论文：技术介绍、验证假设、探索问题、复现结果<br>
综述 review article：总结或介绍某一领域的发展历程、研究现状、未来趋势</p>
<p>判断一篇文章是综述还是研究论文</p>
<h3 id="1-观察题目的关键词">1. <strong>观察题目的关键词</strong></h3>
<ul>
<li><strong>综述文章</strong>的题目通常会包含如“Review”、“Overview”、“Summary”、“State of the Art”、“Synthesis”等词汇，这些词汇表明文章可能是对某一领域的文献或进展的总结。</li>
<li><strong>研究论文</strong>的题目通常更具体，可能会提到特定的研究方法、数据或实验结果，如“Case Study”、“Effects of”、“Analysis of”、“Response of”等。</li>
</ul>
<h3 id="2-分析题目的内容">2. <strong>分析题目的内容</strong></h3>
<ul>
<li>综述文章的题目往往比较广泛，涉及某一学科或子领域的广泛内容，没有具体的实验或数据分析。</li>
<li>研究论文的题目通常具体到某一特定的研究问题、对象或变量，显示出对特定假设或模型的探讨。</li>
</ul>
<h3 id="3-查看文章的摘要和引言">3. <strong>查看文章的摘要和引言</strong></h3>
<p>如果可以访问到文章的摘要（abstract）或引言（introduction）部分，这些内容可以提供更多线索：</p>
<ul>
<li>综述文章的摘要通常说明了作者调研的范围、目的和方法，可能会提到是对哪个时间段内的文献进行了回顾。</li>
<li>研究论文的摘要会具体说明研究的方法、主要发现和结论，通常还会提及研究的重要性和创新点。</li>
</ul>
<h3 id="4-审查文章的结构">4. <strong>审查文章的结构</strong></h3>
<ul>
<li>综述文章可能没有典型的研究论文结构（即“引言、方法、结果、讨论”模式），而是按照主题或时间顺序组织文献。</li>
<li>研究论文则通常遵循严格的科学报告格式，包括研究方法、数据分析和结果讨论。</li>
</ul>
<p>读论文流程<br>
阅读→提问→梳理→提问→解决问题→再次梳理</p>
<h1 id="chatgpt提问话术">ChatGPT提问话术</h1>
<p>这篇文章对标什么方法？现有方法的缺点是什么？这篇文章解决了什么问题？创新点有哪些？实验结果如何？<br>
模型的输入输出是什么？模型结构是什么？</p>
]]></content>
    </entry>
</feed>